** Basic Idea

- Add a time parameter to verbs.
- Quantify over time intervals

** TODO Handling negation
ATM we handle negation by simply negating at the level of
propositions. This does not work for our temporal analysis, (See 038) but it
already did not work for quantifiers with narrow scoping. (But Fracas
does not test this combination !?)
** Scoping of quantification on time intervals
Note that we introduce the quantification at the level of the
predicate, not at the level of the lexical item.

This is necessary to have the "repeatability of accomplishments"
properties (see below and examples in Fracas).


** Transitivity of "before"

Consider Fracas 261:

P1	Smith left before Jones left.
P2	Jones left before Anderson left.
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
H  	Smith left before Anderson left. 


First idea:

P1   ∃t1, t2. s(t1) ∧ j(t2) ∧ t1 < t2
P2   ∃t3, t4. j(t3) ∧ a(t4) ∧ t3 < t4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
H    ∃t5, t6. s(t3) ∧ a(t4) ∧ t5 < t6

Not possible, because we cannot identify t2 and t3. Informally, "jones
left" may refer to two different events (times).


We can try to use some dynamic semantics to do the identification. We could have:


     ∀t1, t2, t3.
P1   s(t1) ∧ j(t2) ∧ t1 < t2
P2   j(t2) ∧ a(t3) ∧ t2 < t3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
H    s(t1) ∧ a(t3) ∧ t1 < t3


Whenever a (past) clause is evaluated.
  - allocate a fresh time t, evaluate.
  - P(t) be the result.
  - check if P(t) anti-unifies with any clause Q in "true facts", such that P(τ) ⊆ Q for some τ.
  - no:
    - push it in "true facts"
    - return P(t)
  - yes:
    - push it in "true facts" -- it may be a slightly different version!
    - return P(τ)

** Referencing previous times

We search for an event (τ) using a predicate P(t). P mentions all the
arguments of the verb. The principle seems to be that one should use
atomic events. Indeed, consider "Jones left quickly. Smith left before
jones left." The adverb "quickly" should be ignored when looking for
"jones left". Thus it seems that the right level to search for events
should be lexical items. Unfortunately, due to the left-to-right
nature of the dynamic semantics, all the objects of the verb are not
available at this point. (The motegovian semantics PTQ dictate that
the subject isn't available *as a dynamic object* at the point of
processing the verb.) So instead with process events at the predVP
combinator. To acess atoms we break down the logical formula. See the
(ATOM) marks in the code.

** Reference time

Each clause returns the time which is the reference for it
happening. This allows interpretation of "before", etc.

** Time adverbs

Time adverbs, such as "Since", "always", "never", "in two years", "by
11 am", etc. introduce *local* quantification over a timespan. (In
constrast to the global creation of time references for VPs in
general.)

This scope may be extended if the event is referred to (actually just an optimization):

"john has been eating meat since 1978. When he eats meat he gets sick."

** Dealing with Aspects

- Every verb is associated 2 time parameters (start and end of the
  event), called x and y below.
- Possible aspects:

| Name                   | Example                   | Interpretation     | Unicity   |
|------------------------+---------------------------+--------------------+-----------|
| activity               | swam (269)                | x <= y             | yes       |
| activity with interval | swam *for* 1 minute (269) | x+1min <= y        | yes       |
| accomplishment         | signed the contract (268) | x = y+epsilon      | yes       |
| accomplishment w/ ivl. | wrote a book *in* 2 hours | x+2hours = y       | yes       |
| achievement            | drownend                  | x = y              | yes       |
| stative                | live in london            | TODO (for now x=y) | inclusion |

** Repeatability of accomplishments
We capture repeatability via the use of an existential. Example:

smith wrote his novel.

∀t<NOW. ∀x. Novel(x) ∧ Has(smith,x) ∧ write(smith,x,t,t)

And it will be possible to lookup other instances of
write(smith,x,?,?) in the environment.

On the other hand:

smith wrote a novel.

∀t<NOW. ∃x. novel(x) ∧ write(smith,x,t,t)

but further mentions of "smith wrote a novel" will introduce another
variable in the existential which won't match that of the environment.

Another evidence for the correctness of the analyis is that, if we have:


smith wrote a novel in 1992
----------------------------
not (smith wrote it in 1993)

the inference can be made because the object will be the same variable
again.
** Intervals

Each predicate is associated a start and stop time. 

swim t0 t1 jones

We could imagine
using a FOL representation; eg:

forall t in [t0,t1].  swim t jones

But we need to have access to time intervals in the semantics of
before/after (fracas 269).

** Tricks

- PredVP is the deepest level which has access to the subject
- Therefore, it is the deepest place which can lookup events/times
  (because events depend on the subject)
- In turn, is also the deepest place where we can introduce time points
  (because we have access to the dynamic semantics of the clause as a
  whole)
- However, it is only at an even deeper place (lexical items) that we
  - construct the predicate (and so we need to lookup time info here)
  - have access to the aspects of the verb
** Activity modal verbs (start, finish)

Lexical semantics transform the interval (see start_VVTiming in Coq code)

** Duration adverbs

see "in_two_hours_Adv"

(Basically we have current interval modifiers)

** Interval adverbs
see "inInterval"

** Leading explanantion in terms of temporal reference

We can resolve all temporal references using the "UniqueActivity"
idiom (strictly speaking, no need for an environment nor dynamic
semantics).

"UniqueActivity" applies only for atomic verbs of the right aspect
(eg. not statives as "be in paris" (314))

For statives, StativeInclusion applies instead.
** _VS lexical class
The time info propagates into the embedded close of know_VS, etc. (see FraCas 322)
