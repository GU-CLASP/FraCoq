\documentclass[11pt]{beamer}
\usepackage{beamerthemesplit}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{gb4e}
\usetheme{Boadilla}
\newcommand{\Sem}[1]{\sem{#1}}
\logo{\includegraphics{clasp.ps}} 
\renewcommand{\theenumi}{\alph{enumi}}
\input{texhacks-beamer1}
\usefoottemplate{%
\vbox{%
\tinycolouredline{structure!75}%
{\textbf{Bernardy and Chatzikyriakidis\hfill \textsc{IWCS2017, Montpellier} \hfill \insertframenumber/\inserttotalframenumber}}%
}}\title{A Type-Theoretical system for the FraCaS test suite: Grammatical Framework meets Coq
}
\author{Jean-Philippe Bernardy and Stergios Chatzikyriakidis}
\begin{document}
\date{September 20, 2017}
\frame{\titlepage}
\begin{frame}[fragile]
	\frametitle{Brief summary of the talk}
	
	
	\begin{itemize}
		\item  Present a type-theoretical framework for formal semantics leveraging two well-studied tools
		\begin{itemize}
			\item Grammatical Framework (GF, Ranta 2004, 2011)
			\item Coq 
			

		
		
			
			
			
		
	
		
	\end{itemize}
	\item Providing a compositional resource semantics for GF
	
	\item Evaluation on the FraCaS test suite
	
	\item State-of-the-art results	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Structure the talk}
	
	\begin{itemize}
		\item Brief intro to the systems used, GF and Coq
		
		\item Presenting the FraCoq system
		
		\begin{itemize}
			\item We concentrate on the most linguistically relevant features and also the features relevant for the FraCaS
			
\end{itemize}
	
	\item Evaluation against the FraCaS test suite
	
	\begin{itemize}
		\item Some brief remarks about the FraCaS and NLI platforms
			\begin{itemize}
			
			\item Results and comparison with previous logical approaches
			
			\item The issue of automation
			
\end{itemize}\end{itemize}
						
						\item Conclusions and Future work
		
\end{itemize}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Background: Grammatical Framework (GF)}

\begin{itemize}
	\item Functional programming language for writing multi-lingual grammars
	
	\item Involves an abstract syntax, comprised of:
	
	
\begin{itemize}
	\item  A number of syntactic
	categories
	
	\item A number of syntactic construction functions, which
	provide the means to compose basic syntactic categories into more complex
	ones
	
\begin{itemize}
	\item
	
	$AdjCN : AP \to CN \to CN$ (appending an adjectival phrase to a common noun and obtaining a new common noun)
\end{itemize}\end{itemize}
\item GF comes with a library of mappings from abstract
syntax to concrete
\begin{itemize}
	\item These mappings can be inverted by GF, thus offering
parsers from natural text into abstract syntax

\item   We use the parse trees constructed by Ljungl\"of (2012)
thereby avoiding any syntactic ambiguity (GF FraCaS treebank).\end{itemize}\end{itemize}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Background: Type-Theoretical Semantics}
	
	\begin{itemize}
		\item We use the type of logics that have been traditionally dubbed as constructive
		
			\begin{itemize}
				\item Initiated by the work of Martin-L\"of (1971, 1984)
				
				\item In linguistics this types of logics go back to Ranta's seminal work (Ranta 1994) or even earlier to Sundholm (1988)
				\begin{itemize}

				\item More recent approaches can be found as well. Please see Chatzikyriakidis and Luo (2017) for a collection of papers on constructive type theories for NL semantics


\end{itemize}\end{itemize}\end{itemize}

\end{frame}


\begin{frame}[fragile]
	\frametitle{Background: Type Theoretical Semantics}
	
	\begin{itemize}
		\item Main features of MTTs
		
			\begin{itemize}
				\item  Type many-sortedness.
				
				\item Dependent sum and product types
				
				\begin{itemize}
					\item  $\Sigma$-types, often written
					$\sum_{x:A}B[x]$ and which have product types $A\times B$ as a
					special case when $B$ does not depend on $x$.
					
					\item Dependent product, $\Pi$-types, often written
					($\prod_{x:A}B[x]$), and which have arrow-types $A\to B$ as a
					special case
					
					\item They generalize universal quantification and function types and they offer type polymorphism
					
					\end{itemize}
				
				\item Proof-theoretical specification and support for effective
				reasoning.
				
					\begin{itemize}
						\item Most powerful proof assistants implement MTTs (e.g. Coq, Agda)
		
		
\end{itemize}\end{itemize}\end{itemize}
\end{frame}		


\begin{frame}[fragile]
	\frametitle{Background: Coq}
	
	\begin{itemize}
		
		\item	Proof assistant based on the calculus of inductive
		constructions (CiC, Coquand and Paulin-Mohring 1988)
		
		

	\begin{itemize}
		
		\item Arguably one of the leading proof assistants
	\begin{itemize}
		
		\item  a proof of the four-color
theorem (Gonthier 2008)
\item  a proof of the odd order theorem (Gonthier et al. 2013)
\item  developing CompCert, a formally verified compiler for C (Leroy 2013)
\item One of the assistants used in the Univalent Foundations project (Homotopy Type Theory, The Univalent Foundations Program 2013)
\end{itemize}\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Background: Coq}
	
	\begin{itemize}
		
		\item Important features used
		
		\begin{itemize}
			
			\item $\Pi$ types 
			
			\begin{itemize}
				
				\item	in Coq: $\prod_{x:A}B[x]$ is written \texttt{forall (x:A), B} or (simply
			\texttt{A $\to$ B} when \texttt{B} does not depend on \texttt{x}) \end{itemize}
		\item 	Record types
			\begin{itemize}
				
				\item  Generalization of $\Sigma$-types and are encoded as (trivial) inductive types with a single
			constructor.
			
	 
		\item	$\Sigma x:A. B(x)$ can be expressed as a dependent record type in Coq:
			
\begin{verbatim}
Record AB:Type:=mkAB{x:> A;P:B x}
\end{verbatim}
\end{itemize}\end{itemize}\end{itemize}

\end{frame}


\begin{frame}[fragile]
	\frametitle{The FraCoq system}
	
	\begin{itemize}
	
		\item We use Lj\"unglof's FraCaS treebank and take these trees to their semantic counterparts
		
			\item The structure of the semantic representation 
			
		\begin{enumerate}
			\item Every GF syntactic category $C$ is mapped to a Coq $Set$, noted $\sem{C}$.
			\item GF Functional types are mapped compositionally : $\sem{A \to B}$ $=$ $\sem{A} \to \sem{B}$
			\item Every GF syntactic construction function $f : X$ is mapped to a function $\sem{f}$ such that $\sem{f} : \sem{X}$.
			\item GF function applications are mapped compositionally: $\sem{t(u)} = \sem{t} (\sem{u})$.
		\end{enumerate} 

\end{itemize}
\end{frame}



\begin{frame}[fragile]
	\frametitle{The FraCoq system}
	
	\begin{itemize}
		
\item Sentences

	\begin{itemize}
		
		\item We interpret sentences as propositions: $\sem{S} =
		Prop$. 
		
		\item To verify that
		$P$ entails $H$, we prove the proposition $\sem{P} \to \sem{H}$.
		
		\begin{verbatim}
Definition S := Prop.
		\end{verbatim}



\end{itemize}
\item Common Nouns
	\begin{itemize}
		
		\item Predicates over an abstract object type
		
			\begin{verbatim}
Parameter object : Set.
Definition CN := object->Prop.
			\end{verbatim}
			
\end{itemize}\end{itemize}
\end{frame}
\begin{frame}[fragile]
	\frametitle{The FraCoq system}
	
	\begin{itemize}
		
		\item Verb phrases
		
		\begin{itemize}
			
			\item Parameterize over the
			\emph{noun} of the subject (using $\Pi$ types)
			
			\begin{verbatim}
  Definition VP := forall (subjectClass : CN) 
  object -> Prop.
			\end{verbatim}	
\end{itemize}			
\end{itemize}
\end{frame}


\begin{frame}[fragile]
	\frametitle{The FraCoq system}
	
\begin{itemize}
		
\item Adjectives


	\begin{itemize}
		
		\item Functions from cn to cn (predicates to predicates)
		
		
		\begin{verbatim}
Definition A := CN -> CN.
		\end{verbatim}	
		
\item Different classes of adjectives are captured using coercions (subtyping). All special classes of adjectives are subtypes of A. 

\begin{verbatim}
Definition IntersectiveA := object -> Prop.
Definition wkIntersectiveA : IntersectiveA -> A
:= fun a cn (x:object) => a x /\ cn x.
Coercion wkIntersectiveA : IntersectiveA >-> A.
\end{verbatim}	


\item Provision is made for intersective, subsective, privative and non-committal adjectives

\end{itemize}\end{itemize}
\end{frame}




\begin{frame}[fragile]
	\frametitle{The FraCoq system}
	
	\begin{itemize}
		
		\item Adverbs
		
		\begin{itemize}
			
			\item Similar method to adjectives but instead the modification is on verbal predicates
			
			\item The adverb cases in the FraCaS are all veridical and covariant. 
			
			\item We define such a subclass $VeridicalAdv$ and declare it as a coercion $Adv$
			
				\begin{itemize}
					
					\item Adverbs of type $VeridicalAdv$ are also of type $Adv$
			
\begin{verbatim}			
Parameter on_time_Adv : VeridicalAdv .	
\end{verbatim}


			


\end{itemize}\end{itemize}\end{itemize}
\end{frame}


\begin{frame}[fragile]
	\frametitle{The FraCoq system}
	
	\begin{itemize}
		
		\item Noun Phrases and Predeterminers
		
		
	\begin{itemize}
		
		\item A clean definition of NPs as functions from predicates to truth values will not work
		
			\begin{itemize}
				
				\item	Problem with GF's abstract syntax: existence of pre-determiners which include cases like \textit{most}, \textit{all} among others and are defined as functions from NPs to NPs
				
				\item In general, the category includes elements that are naturally interpreted as GQs
				
				\item Solution: Remember the components of NPs (number, quantifier and common noun)
				
				\item Pre-determiners then are able to substistute the quantifier part with the appropriate quantifier
				
				\item This has to be done, otherwise pre-determiners introduce a dummy indefinite in these cases
		
\end{itemize}\end{itemize}\end{itemize}
\end{frame}		


\begin{frame}[fragile]
	\frametitle{The FraCoq system}
	
	\begin{itemize}
		
		\item Generalized Quantifiers
		
		\begin{itemize}
			
			\item They turn a number
			and a common noun into a noun-phrase (which we call $NP0$).
			
			
\begin{verbatim}
	Definition Quant := Num -> CN -> NP0.
\end{verbatim}	

\item Some quantifiers ignore the number and are given usual definitions (e.g. \textit{some} or \textit{all}), whereas others make essential use of number (e.g. \textit{at most})	
			

\begin{itemize}
	

\item In the latter case, the function \texttt{CARD}, a context-dependent
abstract function which turns a predicate into a natural number	is used to get the correct semantics 	
\end{itemize}\end{itemize}\end{itemize}
\end{frame}	


\begin{frame}[fragile]
	\frametitle{The FraCoq system}
	
	\begin{itemize}
		
		\item The definite article
		
		
	\begin{itemize}
		
		\item Checks for plural noun phrases
		
			\begin{itemize}
				
				\item If found, then universal quantification
				
				\item If not, it
				looks up the object of discourse in an abstract $environment$, which
				is a function which turns a common noun into an object



\end{itemize}\end{itemize}\end{itemize}
\begin{verbatim}
	Definition DefArt:Quant:= fun (num : Num) (P:CN)=> fun Q:VP
	=> match num with plural => (forall x, P x -> Q P x)
	 /\ Q P (environment P) /\ P (environment P) |
	_ => Q P (environment P) /\ P (environment P) end.
\end{verbatim}



\end{frame}

\begin{frame}[fragile]
	\frametitle{Evaluation: The FraCaS test suite}
	
	\begin{itemize}
		
		\item A test suite for NLI
		
		
	\begin{itemize}
		
		\item 346 NLI examples in the form of one or more premises followed
		by a question along with an answer to that question


\item Three potential answers

\begin{itemize}
	
	\item YES: The declarative sentence formed out of the question follows from the premises
	
	\item NO: The declarative sentence does not follow from the premises
	
	\item UNK: The declarative sentence neither follows nor does not follow fro the premises
\end{itemize}\end{itemize}\end{itemize}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Evaluation: The FraCaS test suite}
	
	 
		
		\begin{exe}
			\ex
			A Swede won the Nobel Prize.
			
			Every Swede is  Scandinavian.
			
			Did a Scandinavian win the Nobel prize? [Yes, FraCas 049]
		\end{exe}
		
		
		
		 \begin{exe}
		 	\ex
		 	No delegate finished the report on time..
		 	
		 	Did any Scandinavian delegate finish the report on time? [No, FraCaS 070]
		 \end{exe}
		 
		 
		 \begin{exe}
		 	\ex
		 	A Scandinavian won the Nobel Prize.
		 	
		 	Every Swede is  Scandinavian.
		 	
		 	Did a Swede win the Nobel prize? [UNK, FraCaS 065]\end{exe}



\end{frame}

\begin{frame}[fragile]
	\frametitle{Evaluation: The FraCaS test suite}
	
	\begin{itemize}
		
		\item The FraCaS has considerable weaknesses
		
		\begin{itemize}
			
			\item Small size
			
			\item Artificial nature of the
			examples

\end{itemize}

\item However, it covers a lot of phenomena associated with NLI

\item It is still a very good suite to test logical approaches\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Evaluation}
	
	\begin{itemize}
		
		\item Evaluation against 5 sections of the FraCaS
		
		\begin{itemize}
			
			\item Total of 174 examples
		
		\item Excluded sections where a lot of context-dependency has to be taken into consideration (e.g. the section on ellipsis)
		
\end{itemize}

\item YES: a proof
can be constructed from the premises to the hypothesis

\item NO: a proof
of the negated hypothesis can be constructed

\item UNK: otherwise

\end{itemize}
\end{frame}		
		
		
	\begin{frame}[fragile]
		\frametitle{Evaluation}
		
		\begin{itemize}
			
			\item		The following table presents the results (Ours) as well as a comparison with the approach in Mineshima et al. (MINE, 2015), Bos (Nut, 2008) and Abzianidze (Langpro, 2015)
			
			\begin{center}
				\begin{tabular}{rlrrrrr}
					& Section                                                                               & \# examples                                                                                                & \begin{tabular}[c]{@{}l@{}}Ours\end{tabular}                                                        & \begin{tabular}[c]{@{}l@{}}MINE \end{tabular}                                             & \begin{tabular}[c]{@{}l@{}}Nut\end{tabular}   & \begin{tabular}[c]{@{}l@{}} Langpro \end{tabular}                                                     \\ \hline
					\begin{tabular}[c]{@{}l@{}}1\\ 2\\ 3\\ 4\\5\\6\end{tabular} & \begin{tabular}[c]{@{}l@{}}Quantifiers\\ Plurals\\ Adjectives\\Comparatives\\ Attitudes\\ Total\end{tabular} & \begin{tabular}[c]{@{}l@{}}75\\ 33\\22\\ 31\\13\\174 (181)\end{tabular} & \begin{tabular}[c]{@{}l@{}}.96\\ .76 \\ .95 \\ .56    \\ .85\\ 0.83 \end{tabular} & \begin{tabular}[c]{@{}l@{}}.77\\ .67\\ .68 \\   .48      \\.77\\0.69 \end{tabular} & \begin{tabular}[c]{@{}l@{}} .53\\ .52\\ .32\\ .45\\.46\\0.50\end{tabular} & \begin{tabular}[c]{@{}l@{}} .93 (44)
						\\ .73 (24)\\ .73 (12)\\ -\\.92 (9)\\0.85\end{tabular}
				\end{tabular}
			\end{center}
			
		


\item Our approach outerperforms Mineshema et al. by 13 percentage points. 

\item The approach by Abzianidze has an accuracy of 0.85 without involving the comparative section. If this section is taken out, our system's accuracy rises to 0.88

\end{itemize}







\end{frame}		
	
	
	\begin{frame}[fragile]
		\frametitle{Error Analysis}
		
		\begin{itemize}
			
			\item	Improvement over earlier approaches. Still, there were a couple of difficulties
			
				\begin{itemize}
					
					\item Comparatives: cases that needed one to provide
					adequate semantics for \textit{more} but also to take care of ellipsis
					
			\begin{exe}
				\ex				
	\hskip 0.05in ITEL won more orders than APCOM.
	
	\hskip 0.05in ITEL won some orders.
	
	
	\hskip 0.05in  	Did ITEL win some orders? [Yes, FraCaS 233]				
					
\end{exe}		
\item Definite Plurals: Universal reading was captured. Cases of existential readings were not

\begin{exe}
	\ex	


\hskip 0.05in The inhabitants of Cambridge voted for a Labour MP.

\hskip 0.05in very inhabitant of Cambridge voted for a Labour MP.


\hskip 0.05in  	Did every inhabitant of Cambridge vote for a Labour MP? [UNK, FraCaS 094]			
					
		\end{exe}	
	
\end{itemize}\end{itemize}

\end{frame}	




\begin{frame}[fragile]
	\frametitle{Automation}
	
	\begin{itemize}
		
		\item So far, our proofs are not automated
		
		\begin{itemize}
			
			\item A couple of steps (usually very few) to reach a proof
			
			\item Earlier approaches using Coq (e.g. Chatzikyriakidis 2014 and Mineshima et al. 2015) use Coq's tactical language LTac to define automated macros of actions
			
			
				\begin{itemize}
					
					\item This is not difficult to do in our case as well
					
					\item Just go through all the proof
					tactics or observe the tactics that are used in the proofs to create a
					macro that will automate the proofs
					
					\item The question remains: can that macro of tactics
					generalize outside the suite?
					
					\item Answer: only to a limited
					extent, i.e. when exactly the same set of tactics yields a proof
					
					\item For
					this reason, we have not automated proof search to obtain the results
					presented in this paper, even though this can be done easily


\end{itemize}\end{itemize}







\end{itemize}

\end{frame}	


\begin{frame}[fragile]
	\frametitle{Automation}
	
	\begin{itemize}
		
		\item Automating would also make an unprincipled use of
		higher-order logic (HOL)
		
			\begin{itemize}
				
				\item No algorithm which
				can decide if a proposition has a proof or not


\begin{itemize}
	
	\item We
	must use heuristics both to search for proofs and to decide when to
	give up searching


\end{itemize}\end{itemize}

\item  Most problems have either
obvious proofs or obviously lack a proof (fortunately)

\begin{itemize}
	
	\item Due to its heuristic nature the
	proof search necessarily contains a human component
	
	\begin{itemize}
		
		\item Problematic to make a statement about the suitability of FraCoq
		outside FraCas
		
		
		\item Small dataset and lack of separation between a development and a test set does not help the situation either
		
		\item Related shortcoming: specialized semantics for specific lexical entries
		
		
\end{itemize}\end{itemize}\end{itemize}

\end{frame}	




\begin{frame}[fragile]
	\frametitle{Future Work}
	
	\begin{itemize}
		
		\item Address the issue of
		automation
		
			\begin{itemize}
				
				\item Define a decidable fragment of
				the logic and only work within such fragment
		
	\begin{itemize}
		
		\item Possible to concisely characterize how the approach generalises

\end{itemize}


\item Train a neural network on a body of freely available proofs on the net and see whether it can generalize to automatically provide the proof tactics for the cases interested




\end{itemize}


\item Improvement at the GF level: make the abstract syntax more compatible with compositional semantics

	
	\begin{itemize}
		
		\item For example, do something about problematic syntactic categories like pre-determiners or cases where the syntax makes it impossible to recover elliptical fragments


\end{itemize}

\item Extend into the whole suite (first attempt to do anaphora using monads on the way!)


\end{itemize}

\end{frame}	




\begin{frame}[fragile]
	\frametitle{Conclusions}
	
	\begin{itemize}
		
		\item We have connected two well-defined systems based on
		type-theory
		
		\begin{itemize}
			
			\item GF and Coq
			
			\item Providing resource semantics for GF
		
		

\end{itemize}



\item The issue of generalization remains a shortcoming

	\begin{itemize}
		
		\item It is possible
		to achieve very precise semantics for specific domains

\begin{itemize}
	
	\item Our system outerperforms previous logical systems w.r.t accuracy
	
	

\end{itemize}\end{itemize}

\item Useful in performing inference tasks on controlled natural
language domains

\item Hybrid NLI systems



\end{itemize}

\end{frame}	


\begin{frame}[fragile]
	\frametitle{Conclusions}
	
	\begin{itemize}
		\item The system can be found here:  \href{https://github.com/GU-CLASP/FraCoq}{https://github.com/GU-CLASP/FraCoq}

\end{itemize}

\end{frame}	

	
\end{document}