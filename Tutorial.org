* Semantics for GF

Aim:

- Map GF abstract syntax to logical statements
- Reason about them in some way

* Why GF

- GF syntaxes generally follow Montague's principle: syntax is a
  prelude to semantics. (that is, syntax is not there only to give a
  language model --- a set of strings. It serves to reveal the
  structure which underlies the semantics)

* Why Coq
- Both a programming language and a logic
- The type system is a superset of GF's
- Higher order logic (very expressive logic, so "anything you can
  think of" can be done)
- Has good reasoning facilities ("tactics") (some can solve decidable subtheories)
- Can work on "open terms" (some definitions can remain abstract)

- The mapping is done using the programming bits of Coq
- The reasoning is done with the HOL bits of Coq

** Downsides:

- Not a decidable logic (cannot evaluate the truth value)
- Not a theorem prover (cannot in general prove true conjectures)
- From a pedagogical pov., maybe it could be better to clearly
  separate the programming bits and the reasoning bits.
- The programming bits are restricted to total programs (which can
  sometimes mean extra work)
- Not the same support for overloading

** Alternatives:

1. Other type-theoretical proof assistants: Agda, Idris, ...
2. Separate semantics and inference
   - Program in your favorite language with higher-order functions (a
     type-system helps). In particular, you can use the concrete syntax
     mechanism of GF for the simplest semantic mappings. (You may have
     difficulties with quantifiers; supporting anaphora is most certainly
     very difficult.)
   - Use your favorite reasoning tool

* General idea


In GF:
  - the abstract syntax is a type assignment (symbols are mapped to types)
  - the concrete syntax is a program assignment (symbols are mapped to
    definitions)
  - GF checks that the definitions in question are correct (type-wise)

Semantics are just another concrete syntax (mapping symbols to
definitions).


* "Montague semantics"


| Surface syntax | Abstract syntax       | Semantics           |
|----------------+-----------------------+---------------------|
| LinCat         | Cat                   | Type                |
| String         | Cl                    | Prop                |
| ...            | NP                    | object              |
| ...            | VP                    | object -> Prop      |
| ...            | mkCl : NP -> VP -> Cl | fun np vp => vp np. |

* Other possible semantics

Top-level categories can be mapped to other things than propositions:

- Commands (programs)
- Database queries/updates
- ...

In such a case "reasoning" does not take the usual mathematical form
of proving/testing conjectures

* Gathering the categories and types

- Get them from the GF shell ("ai" --abstract info-- can be used for this purpose)
- Get them from the file (probably the easiest)

#+BEGIN_SRC gf
abstract Grammar = {
  flags startcat = S ;

  cat
    S ; Cl ; NP ; VP ; AP ; CN ; PN ;
    Det ; N ; A ; V ; V2 ; AdA ; 
    Pol ;
    Conj ;
  data
    UseCl   : Pol -> Cl -> S ;
    PredVP  : NP -> VP -> Cl ;
    ComplV2 : V2 -> NP -> VP ;
    DetCN   : Det -> CN -> NP ;
    ModCN   : AP -> CN -> CN ;

    CompAP  : AP -> VP ;
    AdAP    : AdA -> AP -> AP ;

    ConjS   : Conj -> S  -> S  -> S ;
    ConjNP  : Conj -> NP -> NP -> NP ;

    UseV    : V -> VP ;
    UsePN   : PN -> NP ;
    UseN    : N -> CN ;
    UseA    : A -> AP ;

    some_Det, every_Det : Det ;
    i_NP, you_NP : NP ;
    very_AdA : AdA ;

    Pos, Neg : Pol ;

    and_Conj, or_Conj : Conj ;
}

abstract Test = Grammar ** {

fun
  man_N, woman_N, house_N, tree_N : N ;
  big_A, small_A, green_A : A ;
  walk_V, arrive_V : V ;
  love_V2, please_V2 : V2 ;
  john_PN, mary_PN : PN;

} ;
#+END_SRC

* Coqification

- Every category must have a definition.
- Every (data) constructor must have a definition (whose type is the same as
  its GF type). Some ()


When we do not know what definition to use, we can abstract over it
instead. In Coq this is conveniently done using the "Parameter"
command.

#+BEGIN_SRC coq
Parameter S    : Type.
Parameter Cl   : Type.
Parameter VP   : Type.
Parameter PN   : Type.
Parameter NP   : Type.
Parameter AP   : Type.
Parameter A    : Type.
Parameter CN   : Type.
Parameter Det  : Type.
Parameter N    : Type.
Parameter V    : Type.
Parameter V2   : Type.
Parameter AdA  : Type.
Parameter Pol  : Type.
Parameter Conj : Type.

Parameter UseCl   : Pol -> Cl -> S. 
Parameter PredVP  : NP -> VP -> Cl. 
Parameter ComplV2 : V2 -> NP -> VP. 
Parameter DetCN   : Det -> CN -> NP. 
Parameter ModCN   : AP -> CN -> CN. 
Parameter CompAP  : AP -> VP. 
Parameter AdAP    : AdA -> AP -> AP. 
Parameter ConjS   : Conj -> S  -> S  -> S. 
Parameter ConjNP  : Conj -> NP -> NP -> NP. 
Parameter UsePN   : PN -> NP.
Parameter UseV    : V -> VP. 
Parameter UseN    : N -> CN. 
Parameter UseA    : A -> AP. 
Parameter some_Det : Det.
Parameter every_Det : Det. 
Parameter we_NP   : NP.
Parameter you_NP : NP. 
Parameter very_AdA : AdA. 
Parameter Pos : Pol.
Parameter Neg : Pol.
Parameter and_Conj : Conj.
Parameter or_Conj : Conj.

Parameter man_N :  N.
Parameter woman_N : N .
Parameter house_N :  N.
Parameter tree_N : N .
Parameter   big_A : A .
Parameter small_A : A .
Parameter green_A : A .
Parameter  walk_V : V  .
Parameter arrive_V : V .
Parameter love_V2 : V2  .
Parameter please_V2 : V2 .
Parameter john_PN :PN .
Parameter mary_PN : PN.
#+END_SRC

Now, every correct GF abstract syntax expression is well-typed in Coq.
We can even do (trivial) reasoning.

#+BEGIN_SRC coq
Theorem thm0 : UseCl Pos (PredVP (UsePN john_PN) walk_V) ->
               UseCl Pos (PredVP (UsePN john_PN) walk_V).
intro H.
exact H.
Qed.
#+END_SRC

This may seem useless, but in fact, unless you have a very precise
idea of your semantic domain, much of the lexicon will remain abstract.

* Sentences/Clauses/Polarity

#+BEGIN_SRC coq
Definition S    : Type := Prop .
Definition Cl   : Type := Prop .
Definition Pol  : Type := Prop -> Prop .

Definition Pos : Pol := fun p => p.
Definition Neg : Pol := fun p => not p.
Definition UseCl : Pol -> Cl -> S :=
  fun pol c => pol c. 
#+END_SRC


#+BEGIN_SRC coq
Theorem thm1 : UseCl Pos (PredVP (UsePN john_PN) walk_V) ->
               UseCl Neg (PredVP (UsePN john_PN) walk_V) -> False.
cbv.
intros P N.
exact (N P).
Qed.
#+END_SRC


* Proper nouns/VP/PN

#+BEGIN_SRC coq
Definition NP   : Type := PN .
Definition UsePN :  PN -> NP := fun x => x.
Definition VP   : Type := PN -> Prop .
Definition V    : Type := VP.
Definition UseV  : V -> VP := fun v => v.
Parameter PredVP  : NP -> VP -> Cl. 

Eval cbv in UseCl Pos (PredVP (UsePN john_PN) walk_V).
#+END_SRC

#+BEGIN_EXAMPLE
= walk_V john_PN : S
#+END_EXAMPLE

* Quantifiers (1)
The previous definition of NP is too restrictive in the presence of
quantifiers. Indeed a PN is to restrictive to represent phrases such
as 'every man', 'some tree', etc.  Montague's solution is to
generalize NPs to transform the predicate of VPs:

#+BEGIN_SRC coq
Definition NP    : Type := VP -> Prop .
Definition UsePN : PN -> NP := fun pn vp => vp pn.
Definition PredVP  : NP -> VP -> Cl := fun np vp => np vp.
#+END_SRC

#+BEGIN_SRC 
Eval cbv in UseCl Pos (PredVP (UsePN john_PN) walk_V).
#+END_SRC

Then we can represent "everyone" as follows:

#+BEGIN_SRC coq
Definition everyoneNP : NP := fun vp => forall x, vp x.
#+END_SRC

Namely, we're applying the VP to every possible 'thing'.

* Quantifiers (2)
We may want to restrict the domain: "every man", "some tree", etc.
Thus we will represent common nouns as predicates (like VPs) and weaken the
propositions accordingly. A determiner transforms common nouns into NPs.
#+BEGIN_SRC coq
Definition CN   : Type := PN -> Prop .
Definition N   : Type := CN .
Definition Det   : Type := CN -> NP .
Definition DetCN : Det -> CN -> NP := fun det cn => det cn.
Definition every_Det : Det := fun cn vp => forall x, cn x -> vp x.
Definition some_Det : Det := fun cn vp => exists x, cn x /\ vp x.
#+END_SRC
Note the inversion of polarity in the connectives.

* Embedding nouns and reasoning

#+BEGIN_SRC coq
Definition N    : Type := CN .
Parameter UseN    : N -> CN. 
#+END_SRC


#+BEGIN_SRC coq
Theorem thm2 :
    UseCl Pos (PredVP (DetCN every_Det man_N) walk_V) ->
    (man_N john_PN) ->
    (walk_V john_PN).
cbv.
intros H1 H2.
exact (H1 john_PN H2).
Qed.
#+END_SRC

* Adjectives (Naive)
We can try the usual reciepe and represent adjectives as predicates:

#+BEGIN_SRC coq
Definition AP   : Type := PN -> Prop .
Definition A    : Type := AP .
Definition ModCN   : AP -> CN -> CN := fun ap cn x => ap x /\ cn x. 
Definition CompAP  : AP -> VP := fun ap x => ap x. 
#+END_SRC

"every green tree is green."

#+BEGIN_SRC coq
Theorem thm3 :
    UseCl Pos (PredVP (DetCN every_Det (ModCN (UseA green_A) (UseN tree_N))) (CompAP (UseA green_A))).
cbv.
intuition.
Qed.
#+END_SRC

* 2-place verb

#+BEGIN_SRC coq
Definition V2   : Type := PN -> VP .
Definition ComplV2 : V2 -> NP -> VP := fun v object subject => object (v subject).
#+END_SRC

* Conjunctions

#+BEGIN_SRC coq
Definition Conj : Type := Prop -> Prop -> Prop .
Definition ConjS   : Conj -> S  -> S  -> S := fun c => c.
Definition ConjNP  : Conj -> NP -> NP -> NP := fun c np1 np2 vp =>
  np1 (fun x => np2 (fun y => c (vp x) (vp y))). 
Definition and_Conj : Conj := fun x y => x /\ y.
Definition or_Conj : Conj := fun x y => x \/ y.
#+END_SRC

"John loves Mary and a tree."
Eval cbv in UseCl Pos (PredVP (UsePN john_PN) (ComplV2 love_V2 (ConjNP and_Conj (UsePN mary_PN) (DetCN some_Det (UseN tree_N))))).
exists x : PN, tree_N x /\ love_V2 john_PN mary_PN /\ love_V2 john_PN x

* Abstract Domain knowledge

Even in the presence of abstract parameters, one can add arbitrary assumptions.

example: green and black are disjoint properties:

#+BEGIN_SRC coq
Parameter green_black_disjoint: forall x, green_A x -> black_A x -> False.
#+END_SRC

Other types of domain knowledge:

- John saw x -> x is true
- John belive y /\ (x -> y) -> John believe y

* Refining and complexifying the interpretations
 Pause and reflect

The above is a basic approach only. 

* Adjectival phrases and adjectives

In general, the meaning of an ajective depends on the noun that it modifies.
Adjectives and adjectival phrases are represented as modifiers of common nouns.
#+BEGIN_SRC coq
Definition A := CN -> CN.
#+END_SRC

** Basic Clasisfication
- Intersective (fun cn x => a x /\ cn x).
- Subsective (fun cn x => a cn x /\ cn x). (Skillful doctor, Skillful
  archer). Skillful does not transfer across nouns. A skillful doctor
  who also practises archery is not necessary a skillful archer.
- Privative. (fun cn x => a x /\ not (cn x)). Heavily depends on the
  domain and the goals of the semantics. ("Fake gun", "Interrupted
  route", "Healthy patient")
- Non-commital (fun cn x => a cn x /\ cn x)

** Subtyping and coercions
  An intersective adjective (\texttt{IntersectiveA}) is fully defined by a
  predicate over objects. The adjectival meaning is the conjunction of
  such predicate and the bare noun (\texttt{wkIntersectiveA}). Additionally, to
  relieve the user from calling this semantic function in in many
  places, we declare it as an implicit coercion.

#+BEGIN_SRC coq
Definition IntersectiveA := object -> Prop.
Definition wkIntersectiveA : IntersectiveA -> A
            := fun a cn (x:object) => a x /\ cn x.
Coercion wkIntersectiveA : IntersectiveA >-> A.
#+END_SRC

Later on it suffices to define

#+BEGIN_SRC coq
Parameter green_A : IntersectiveA. 
#+END_SRC
To specify the class.

** More: extensional adjectives
Subsective adjectives may transfer across equivalent nouns.

#+BEGIN_SRC coq
Inductive ExtensionalSubsectiveA : Type :=
   mkExtensionalSubsective :
     forall (a : (object -> Prop) -> (object -> Prop)),
     forall (ext : forall (p q:object -> Prop),
                   (forall x, p x -> q x) -> (forall x, q x -> p x) -> forall x, a p x -> a q x),
     ExtensionalSubsectiveA.
Definition apExtensionalSubsectiveA
            : ExtensionalSubsectiveA -> A
            := fun a cn (x:object) => let (aa,_) := a in
                 aa cn x /\ cn x .
Coercion apExtensionalSubsectiveA : ExtensionalSubsectiveA >-> A.
#+END_SRC
In the same way we treated intersective adjectives, we add the
semantics as a coercion for subsectives as well. It should be stressed
that it suffices to declare an adjective as extensional subsective for
Coq to remember the extensional property, even though it does not
appear in the interpretation as a coerced general adjective.

* Adverbs
Adverbs are similar to adjectives, except that they modify verbal
predicates or propositions instead of nouns. In the FraCaS test
suite we only find VP adverbs (verbal predicates). Furthermore, the
test suite does not require the noun class to be passed to the
adverb semantics, and thus we omit it. \textit{A contrario}, the
test suite requires many adverbs to be veridical and
covariant. Thus, as for adjectives, we define a refined subclass to
capture these properties.
#+BEGIN_SRC coq
Definition ADV := (object -> Prop) -> (object -> Prop).
Definition Adv:= ADV.
Definition VeridicalAdv :=
  { adv : (object -> Prop) -> (object -> Prop)
    & (forall (x : object) (v : object -> Prop), (adv v) x -> v x) *
      (forall (v w : object -> Prop),
        (forall x, v x -> w x) -> forall (x : object), adv v x -> adv w x)
    }.
#+END_SRC
  The plain adverbial semantics are recovered by extracting the $adv$
  component. Similarly to extensional adjectives, veridical adverbs
  the additional properties are made available solely by declaring
  lexical entries as belonging to the correct class. A coercion
  between $VeridicalAdv$ and $Adv$ is further defined (in effect we
  define veridical adverbs to be subtypes of adverbs). To give an
  example, consider the veridical adverb $on\_time$. This will have
  the entry:

#+BEGIN_SRC coq
Parameter on_time_Adv : VeridicalAdv .
#+END_SRC

* Predeterminers
 The literature usually defines
  the semantics of noun-phrases as a predicate over verb phrases:
  \begin{coq}
    Definition NP0 := VP -> Prop.
  \end{coq}
  Unfortunately, such a clean definition cannot work with GF's
  abstract syntax.  The main issue is that predeterminers, which
  include ``most'', ``at least'', ``all'', etc. are parsed as
  modifiers of noun phrases: $PredetNP : Predet → NP → NP$. A moment
  of thought suffices to be convinced that predicates over
  verb-phrases are too rigid to be ``pre-determined'' in this way.
  Therefore the semantics that we use is a tuple of the components of
  noun-phrases: number, quantifier, and common noun:
  \begin{coq}
  Inductive NP : Type := mkNP : Num -> Quant -> CN -> NP.
  \end{coq}
  Predeterminers can then update the quantifier part of the NP. For
  example, the ``all'' and ``most'' predeterminers replace the quantifier part by the
  corresponding quantifier:
  \begin{coq}
  Definition Predet := NP -> NP.
  Definition all_Predet : Predet := fun np => let (num,qIGNORED,cn) := np
                                              in mkNP num all_Quant cn.
  Definition most_Predet : Predet := fun np => let (num,qIGNORED,cn) := np
                                               in mkNP num MOST_Quant cn.
  \end{coq}
  One may wonder if it is justified to simply ignore the quantifier in
  such a way. We answer positively, because in practice, a noun-phrase
  with a useful quantifier is never equipped with the ``all''
  predeterminer --- in fact, in this case GF introduces a dummy
  indefinite article which \emph{must} be overwritten in the semantics.
  
* Numerals, cardinals
  An important part of the NP is the
  number. Here we record as precisely as possible the information
  given by the syntax; which can be a singular, a plural, a precise
  cardinality or even the ``more than'' modifier.
  \begin{coq}
  Inductive Num : Type       :=
    singular : Num           |
    plural   : Num           |
    unknownNum : Num         |
    moreThan : Num -> Num    |
    cardinal : nat -> Num    .
  \end{coq}

* Generalised quantifiers

Generalised quantifiers turn a number
  and a common noun into a (usual) noun-phrase (which we call $NP0$).
  \begin{coq}
Definition Quant := Num -> CN -> NP0.
\end{coq}
Certain quantifiers ignore the number, and are thus given usual definitions:
\begin{coq}
Definition all_Quant : Quant :=fun (num:Num) (cn : CN) (vp : VP) => forall x, cn x->vp cn x.
\end{coq}
Some others, such as ``at most'' make essential use of the number:
\begin{coq}
Definition atMost_quant : Quant
  := fun num cn vp => interpAtMost num (CARD (fun x => cn x /\ vp cn x))
\end{coq}
In the above, \texttt{interpAtMost} checks that the given number is less than
the given cardinality. The function \texttt{CARD} is a context-dependent
abstract function which turns a predicate into a natural number. We
equip \texttt{CARD} with common-sense axioms of set cardinality, such as
monotonicity:
\begin{coq}
Parameter CARD : (object -> Prop) -> nat.
Variable CARD_monotonous : forall a b:CN, (forall x, a x -> b x) -> CARD a <= CARD b.
\end{coq}

The \texttt{CARD} variable is used to interpret several other quantifiers, including ``most'':
\begin{coq}
Definition MOST_Quant : Quant :=
    fun num (cn : CN) (vp : VP) => CARD (fun x => cn x /\ vp cn x) >= MOSTPART (CARD cn).
\end{coq}
where \texttt{MOSTPART} is another context-dependent abstract function
from natural to natural. To support FraCas examples, it is sufficient
to equip it with a monotonicity axiom:
\begin{coq}
Parameter MOSTPART: nat -> nat.
Variable MOST_mono : forall x, MOSTPART x <= x.
\end{coq}


As usual, articles are  special cases of quantifiers.  When a
useful number is provided by the NP, the indefinite article enforces
it. Otherwise it generates an existential quantification.
\begin{coq}
  Definition IndefArt:Quant:= fun (num : Num) (P:CN)=> fun Q:VP=> match num with
  cardinal n => CARD (fun x => P x /\ Q P x) = n                        |
  moreThan n => interpAtLeast n (CARD (fun x => P x /\ Q P x))          |
  _          => exists x, P x/\Q P x end                                .
\end{coq}
The definite article checks for plural noun phrases, in which case it
implements\textit{} definite plurals (universal quantification). Otherwise, it
looks up the object of discourse in an abstract $environment$, which
is a function which turns a common noun into an object:
$environment : CN → object$.
\begin{coq}
  Definition DefArt:Quant:= fun (num : Num) (P:CN)=> fun Q:VP=> match num with
  plural => (forall x, P x -> Q P x) /\ Q P (environment P) /\ P (environment P) |
  _ => Q P (environment P) /\ P (environment P) end.
\end{coq}

* Prepositions
Prepositions are interpreted as values transforming
  simplified noun phrases (1) to predicates. This transformation is
  veridical (2) and covariant (3).  These three aspects are captured
  in three fields of a record, as follows.
  \begin{coq}
Definition NP1 := (object -> Prop) ->Prop.
Inductive Prep : Type :=
   mkPrep : forall
   (prep : NP1 -> (object -> Prop) -> (object -> Prop)),                       (* 1 *)
   (forall (prepArg : NP1) (v : object -> Prop) (subject : object),            (* 2 *)
     prep prepArg v subject -> v subject) ->
     (forall (prepArg : NP1) (v w : object -> Prop),
     (forall x, v x -> w x) -> forall x, prep prepArg v x -> prep prepArg w x) (* 3 *)
      -> Prep.
  \end{coq}

* Comparatives
- Change the interpretation of adjective to be a measure:

  #+BEGIN_SRC coq
  Inductive A : Type  :=
    mkA : forall (measure : (object -> Prop) -> object -> Z)
                 (threshold : Z)
                 (property : (object -> Prop) -> (object -> Prop)), A.
  #+END_SRC

- Now we can precisely compare things!

#+BEGIN_SRC coq
Definition ComparA : A -> NP -> AP
 := fun a np cn x => let (measure,_,_) := a in
    apNP np (fun _class y => (measure cn y < measure cn x)).

 
Definition ComparAsAs : A -> NP -> AP
 := fun a np cn x => let (measure,_,_) := a in
    apNP np (fun _class y => measure cn x = measure cn y).
#+END_SRC

- Subsective adjectives have different comparison classes.
- Most of the time, the comparatives are used in a copula, and in that
  case the cn comes from the NP.

* Relative clauses
Relative clauses are interpreted as verb phrases and used
intersectively when building noun phrases:

#+BEGIN_SRC coq
    Definition RS := VP.
    Definition RelNPa : NP -> RS -> NP
      := fun np rs => let (num,q,cn) := np
      in mkNP num q (fun x => cn x /\ rs cn x).
#+END_SRC

* Anaphora
TODO.
* References

- Ranta, 2004. "Computational semantics in type theory". http://msh.revues.org/pdf/2925
- Bernardy and Chatzikyriakidis, 2017.

