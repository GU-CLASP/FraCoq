@article{algehed_simple_2019,
  title={Simple noninterference from parametricity},
  author={Algehed, Maximilian and Bernardy, Jean-Philippe},
  journal={Proceedings of the ACM on Programming Languages},
  volume={3},
  number={ICFP},
  pages={89},
  year={2019},
  publisher={ACM}
},

@inproceedings{bernardy_wide_2019,
  title={A Wide-Coverage Symbolic Natural Language Inference System},
  author={Jean-Philippe Bernardy and Stergios Chatzikyriakidis},
  year={2019},
  booktitle={Proceedings of the 22nd Nordic Conference on Computational Linguistics},
  publisher={???},
},

@inproceedings{bernardy_predicates_2019,
  title={Predicates as Boxes in Bayesian Semantics for Natural Language},
  author={Jean-Philippe Bernardy and Rasmus Blanck and Stergios Chatzikyriakidis and Shalom Lappin and Aleksandre Maskharashvili},
  year={2019},
  booktitle={Proceedings of the 22nd Nordic Conference on Computational Linguistics},
  publisher={???}
},

@inproceedings{ek_language_2019,
  title={Language Modeling with Syntactic and Semantic Representation for Sentence Acceptability Predictions},
  author={Adam Ek and Jean-Philippe Bernardy and Shalom Lappin},
  year={2019},
  booktitle={Proceedings of the 22nd Nordic Conference on Computational Linguistics},
  publisher={???}
},

@inproceedings{bernardy_two_2019,
  title={Two experiments for embedding Wordnet hierarchy into vector spaces},
  author={Jean-Philippe Bernardy and Aleksandre Maskharashvili},
  year={2019},
  booktitle={Proceedings of the 10th Global {WordNet} Conference},
  publisher={???}
},

@inproceedings{adouane_neural_2019,
  title={Neural Models for Detecting Binary Semantic Textual Similarity for Algerian and MSA},
  author={Wafia Adouane and Jean-Philippe Bernardy and Simon Dobnik},
  booktitle={Proceedings of The Fourth Arabic Natural Language Processing Workshop},
  year={2019}
},

@inproceedings{bernardy_bayesian_2019,
  title={Bayesian Inference Semantics: A Modelling System and  A Test Suite},
  author={Jean-Philippe Bernardy and Rasmus Blanck and Stergios Chatzikyriakidis and Aleksandre Maskarashvili and Shalom Lappin},
  booktitle={Proceedings of StarSem 2019},
  year={2019}
},

@inproceedings{maraev_predicting_2019,
   title={Predicting laughter relevance spaces in dialogue},
   author={Vladislav Maraev and Christine Howes and Jean-Philippe Bernardy},
   booktitle={???},
   year={2019},
   },

@inproceedings{bernardy_what_2019,
   title={What Kind of Natural Language Inference are NLP Systems Learning: Is this Enough?},
   author={Jean-Philippe Bernardy and Stergios Chatzikyriakidis},
   booktitle={13th International Conference on Agents and Artificial Intelligence},
   year={2019}
   },

@inproceedings{maraev_2018_kos,
   title={Towards KoS/TTR-based proof-theoretic dialogue management},
   author={Vladislav Maraev and Jonathan Ginzburg and Staffan Larsson and Ye Tian and Jean-Philippe Bernardy},
   booktitle={Proceedings of SemDial 2018 (AixDial): The 22nd Workshop on the Semantics and Pragmatics of Dialogue},
   year={2018}
   },

@inproceedings{mikolov2018advances,
  title={Advances in Pre-Training Distributed Word Representations},
  author={Mikolov, Tomas and Grave, Edouard and Bojanowski, Piotr and Puhrsch, Christian and Joulin, Armand},
  booktitle={Proceedings of the International Conference on Language Resources and Evaluation (LREC 2018)},
  year={2018}
},

@inproceedings{bernardy_compositional_2018,
  author={Jean-Philippe Bernardy and Rasmus Blanck and Stergios Chatzikyriakidis and Shalom Lappin},
  title={A Compositional Bayesian Semantics for Natural Language},
  booktitle={Proceedings of the 1st International Workshop on Language, Cognition and Computational Models},
  year={2018}
},

@article{weiss_practical_2018,
  title={On the practical computational power of finite precision RNNs for language recognition},
  author={Weiss, Gail and Goldberg, Yoav and Yahav, Eran},
  journal={arXiv preprint arXiv:1805.04908},
  year={2018}
},

@article{yogatama_memory_2018,
  title={Memory Architectures in Recurrent Neural Network Language Models},
  author={Yogatama, Dani and Miao, Yishu and Melis, Gabor and Ling, Wang and Kuncoro, Adhiguna and Dyer, Chris and Blunsom, Phil},
  journal={Proc. ICLR},
  year={2018}
},

@article{gulordava_colorless_2018,
  title={Colorless green recurrent networks dream hierarchically},
  author={Gulordava, Kristina and Bojanowski, Piotr and Grave, Edouard and Linzen, Tal and Baroni, Marco},
  journal={arXiv preprint arXiv:1803.11138},
  year={2018}
},

@inproceedings{collobert_torch7_2011,
  title={Torch7: A matlab-like environment for machine learning},
  author={Collobert, Ronan and Kavukcuoglu, Koray and Farabet, Cl{\'e}ment},
  booktitle={BigLearn, NIPS workshop},
  number={EPFL-CONF-192376},
  year={2011}
},

@article{bastien_theano_2012,
  title={Theano: new features and speed improvements},
  author={Bastien, Fr{\'e}d{\'e}ric and Lamblin, Pascal and Pascanu, Razvan and Bergstra, James and Goodfellow, Ian and Bergeron, Arnaud and Bouchard, Nicolas and Warde-Farley, David and Bengio, Yoshua},
  journal={arXiv preprint arXiv:1211.5590},
  year={2012}
},

@inproceedings{steuwer_lift_2017,
  title={Lift: a functional data-parallel IR for high-performance GPU code generation},
  author={Steuwer, Michel and Remmelg, Toomas and Dubach, Christophe},
  booktitle={Code Generation and Optimization (CGO), 2017 IEEE/ACM International Symposium on},
  pages={74--85},
  year={2017},
  organization={IEEE}
},

@article{mcdonell_optimising_2013,
  title={Optimising purely functional GPU programs},
  author={McDonell, Trevor L and Chakravarty, Manuel MT and Keller, Gabriele and Lippmeier, Ben},
  journal={ACM SIGPLAN Notices},
  volume={48},
  number={9},
  pages={49--60},
  year={2013},
  publisher={ACM}
},

@inproceedings{claessen_expressive_2012,
  title={Expressive array constructs in an embedded GPU kernel programming language},
  author={Claessen, Koen and Sheeran, Mary and Svensson, Bo Joel},
  booktitle={Proceedings of the 7th workshop on Declarative aspects and applications of multicore programming},
  pages={21--30},
  year={2012},
  organization={ACM}
},

@inproceedings{svensson_obsidian_2008,
  title={Obsidian: A domain specific embedded language for parallel programming of graphics processors},
  author={Svensson, Joel and Sheeran, Mary and Claessen, Koen},
  booktitle={Symposium on Implementation and Application of Functional Languages},
  pages={156--173},
  year={2008},
  organization={Springer}
},

@phdthesis{svensson_obsidian_2011,
  title={Obsidian: GPU Kernel Programming in Haskell},
  author={Svensson, Joel},
  school = {Chalmers Tekniska Högskola},
  type = {Licenciate Thesis},
},

@InProceedings{lau_topically_2017,
  author    = {Lau, Jey Han  and  Baldwin, Timothy  and  Cohn, Trevor},
  title     = {Topically Driven Neural Language Model},
  booktitle = {Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)},
  year      = {2017},
  address   = {Vancouver, Canada},
  pages     = {355--365},
},

@misc{chollet_keras_2015,
  title={Keras},
  author={Chollet, Fran\c{c}ois and others},
  year={2015},
  publisher={GitHub},
  howpublished={\url{https://github.com/keras-team/keras}},
},

@inproceedings{kumar_ask_2016,
  title={Ask me anything: Dynamic memory networks for natural language processing},
  author={Kumar, Ankit and Irsoy, Ozan and Ondruska, Peter and Iyyer, Mohit and Bradbury, James and Gulrajani, Ishaan and Zhong, Victor and Paulus, Romain and Socher, Richard},
  booktitle={International Conference on Machine Learning},
  pages={1378--1387},
  year={2016}
},

@inproceedings{abadi_tensorflow_2016,
  title={TensorFlow: A System for Large-Scale Machine Learning.},
  author={Martín Abadi and Paul Barham and Jianmin Chen and Zhifeng Chen and Andy
                  Davis and Jeffrey Dean and Matthieu Devin and Sanjay
                  Ghemawat and Geoffrey Irving and Michael Isard and Manjunath
                  Kudlur and Josh Levenberg and Rajat Monga and Sherry Moore and
                  Derek G. Murray and Benoit Steiner and Paul Tucker and Vijay
                  Vasudevan and Pete Warden and Martin Wicke and Yuan Yu and
                  Xiaoqiang Zheng},
  booktitle={OSDI},
  volume={16},
  pages={265--283},
  year={2016}
},

@inproceedings{adouane_comparison_2018,
  author={Wafia Adouane and Jean-Philippe Bernardy and Simon Dobnik and Nasredine Semmar},
  title={A Comparison of Character Neural Language Model and Bootstrapping for Language Identification in Multilingual Noisy Texts},
  booktitle={Second Workshop on Subword and Character LEvel Models in NLP},
  year={2018}
},

@inproceedings{adouane_improving_2018,
  author={Wafia Adouane and Jean-Philippe Bernardy and Simon Dobnik and Nasredine Semmar},
  title={Improving Neural Network Performance by Injecting Background Knowledge: Detecting Code-switching and Borrowing in Algerian texts},
  booktitle={Proceedings of the Third Workshop on Computational Approaches to Linguistic Code-switching},
  year={2018}
},

@misc{bernardy_influence_2018,
  author={Jean-Philippe Bernardy and Shalom Lappin},
  title={The Influence of Context on Sentence Acceptability Judgements},
  booktitle={Proceedings of the ACL},
  url={http://aclweb.org/anthology/P18-2073},
  year={2018}
},

@article{bernardy_can_2018,
	author = {Jean-Philippe Bernardy},
	title = {Can RNNs Learn Nested Recursion?},
	journal = {Linguistic Issues in Language Technology},
        volume={16},
        issue={1},
	year = {2018}
},

@misc{bernardy_computational_2018,
	author = {Jean-Philippe Bernardy and Stergios Chatzikyriakidis},
	title = {A Computational Treatment of Anaphora and its Algorithmic Implementation},
	note = {In submission},
	year = {2018}
},

@article{erwig_functional_2006,
  author    = {Martin Erwig and
               Steve Kollmansberger},
  title     = {Functional Pearls: Probabilistic functional programming in Haskell},
  journal   = {J. Funct. Program.},
  volume    = {16},
  number    = {1},
  pages     = {21--34},
  year      = {2006},
  url       = {https://doi.org/10.1017/S0956796805005721},
  doi       = {10.1017/S0956796805005721},
  timestamp = {Sat, 27 May 2017 14:24:34 +0200},
  biburl    = {http://dblp.org/rec/bib/journals/jfp/ErwigK06},
  bibsource = {dblp computer science bibliography, http://dblp.org}
},

@inproceedings{dyer_2015_transition,
  author    = {Chris Dyer and
               Miguel Ballesteros and
               Wang Ling and
               Austin Matthews and
               Noah A. Smith},
  title     = {Transition-Based Dependency Parsing with Stack Long Short-Term Memory},
  booktitle = {Proceedings of the 53rd Annual Meeting of the Association for Computational
               Linguistics and the 7th International Joint Conference on Natural
               Language Processing of the Asian Federation of Natural Language Processing,
               {ACL} 2015, July 26-31, 2015, Beijing, China, Volume 1: Long Papers},
  pages     = {334--343},
  year      = {2015},
  crossref  = {DBLP:conf/acl/2015-1},
  url       = {http://aclweb.org/anthology/P/P15/P15-1033.pdf},
  timestamp = {Sun, 02 Aug 2015 19:26:07 +0200},
  biburl    = {http://dblp.org/rec/bib/conf/acl/DyerBLMS15},
  bibsource = {dblp computer science bibliography, http://dblp.org}
},

@inproceedings{swayamdipta_greedy_2016,
  author    = {Swabha Swayamdipta and
               Miguel Ballesteros and
               Chris Dyer and
               Noah A. Smith},
  title     = {Greedy, Joint Syntactic-Semantic Parsing with Stack LSTMs},
  booktitle = {Proceedings of the 20th {SIGNLL} Conference on Computational Natural
               Language Learning, CoNLL 2016, Berlin, Germany, August 11-12, 2016},
  pages     = {187--197},
  year      = {2016},
  crossref  = {DBLP:conf/conll/2016},
  url       = {http://aclweb.org/anthology/K/K16/K16-1019.pdf},
  timestamp = {Fri, 02 Sep 2016 09:34:40 +0200},
  biburl    = {http://dblp.org/rec/bib/conf/conll/SwayamdiptaBDS16},
  bibsource = {dblp computer science bibliography, http://dblp.org}
},

@article{ballesteros_greedy_2017,
  author    = {Miguel Ballesteros and
               Chris Dyer and
               Yoav Goldberg and
               Noah A. Smith},
  title     = {Greedy Transition-Based Dependency Parsing with Stack LSTMs},
  journal   = {Computational Linguistics},
  volume    = {43},
  number    = {2},
  pages     = {311--347},
  year      = {2017},
  url       = {https://doi.org/10.1162/COLI_a_00285},
  doi       = {10.1162/COLI_a_00285},
  timestamp = {Tue, 26 Sep 2017 19:10:50 +0200},
  biburl    = {http://dblp.org/rec/bib/journals/coling/BallesterosDGS17},
  bibsource = {dblp computer science bibliography, http://dblp.org}
},

@inproceedings{ballesteros_training_2016,
  author    = {Miguel Ballesteros and
               Yoav Goldberg and
               Chris Dyer and
               Noah A. Smith},
  title     = {Training with Exploration Improves a Greedy Stack {LSTM} Parser},
  booktitle = {Proceedings of the 2016 Conference on Empirical Methods in Natural
               Language Processing, {EMNLP} 2016, Austin, Texas, USA, November 1-4,
               2016},
  pages     = {2005--2010},
  year      = {2016},
  crossref  = {DBLP:conf/emnlp/2016},
  url       = {http://aclweb.org/anthology/D/D16/D16-1211.pdf},
  timestamp = {Fri, 04 Nov 2016 14:45:31 +0100},
  biburl    = {http://dblp.org/rec/bib/conf/emnlp/BallesterosGDS16},
  bibsource = {dblp computer science bibliography, http://dblp.org}
},


@article{kingma_method_2014,
  author    = {Diederik P. Kingma and
               Jimmy Ba},
  title     = {Adam: {A} Method for Stochastic Optimization},
  journal   = {CoRR},
  volume    = {abs/1412.6980},
  year      = {2014},
  url       = {http://arxiv.org/abs/1412.6980},
  timestamp = {Thu, 01 Jan 2015 19:51:08 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/corr/KingmaB14},
  bibsource = {dblp computer science bibliography, http://dblp.org}
},

@article{hochreiter_long_1997,
  title={Long short-term memory},
  author={Hochreiter, Sepp and Schmidhuber, J{\"u}rgen},
  journal={Neural computation},
  volume={9},
  number={8},
  pages={1735--1780},
  year={1997},
  publisher={MIT Press}
},

@INPROCEEDINGS{cho_learning_2014,
     author = {Cho, Kyunghyun and van Merri{\"{e}}nboer, Bart and G{\"{u}}l{\c c}ehre, {\c C}aglar and Bahdanau, Dzmitry and Bougares, Fethi and Schwenk, Holger and Bengio, Yoshua},
      month = oct,
      title = {Learning Phrase Representations using {RNN} Encoder--Decoder for Statistical Machine Translation},
  booktitle = {Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)},
       year = {2014},
      pages = {1724--1734},
  publisher = {Association for Computational Linguistics},
    address = {Doha, Qatar},
        url = {http://www.aclweb.org/anthology/D14-1179}
},

@article{elman_distributed_1991,
  title={Distributed representations, simple recurrent networks, and grammatical structure},
  author={Elman, Jeffrey L},
  journal={Machine learning},
  volume={7},
  number={2-3},
  pages={195--225},
  year={1991},
  publisher={Springer}
},

@article{cartling_implicit_2008,
  title={On the implicit acquisition of a context-free grammar by a simple recurrent neural network},
  author={Cartling, Bo},
  journal={Neurocomputing},
  volume={71},
  number={7},
  pages={1527--1537},
  year={2008},
  publisher={Elsevier}
},

@article{gers_lstm_2001,
  title={LSTM recurrent networks learn simple context-free and context-sensitive languages},
  author={Gers, Felix A and Schmidhuber, E},
  journal={IEEE Transactions on Neural Networks},
  volume={12},
  number={6},
  pages={1333--1340},
  year={2001},
  publisher={IEEE}
},

@article{bernardy_using_2017,
  title={Using Deep Neural Networks to Learn Syntactic Agreement},
  author={Jean-Philippe Bernardy and Shalom Lappin},
  journal={Linguistic Issues In Language Technology},
  volume={15},
  number={2},
  pages={15},
  year={2017},
  issn = {1945-3604}
},

@article{karlsson_constraints_2007,
  title={Constraints on multiple center-embedding of clauses},
  author={Karlsson, Fred},
  journal={Journal of Linguistics},
  volume={43},
  number={2},
  pages={365--392},
  year={2007},
  publisher={Cambridge University Press}
},

@inproceedings{karlsson_working_2010,
  title={Working Memory Constraints on Multiple Center-Embedding},
  author={Karlsson, Fred},
  booktitle={Proceedings of the Cognitive Science Society},
  volume={32},
  number={32},
  year={2010}
},

@article{linzen_assessing_2016,
	author = {Tal Linzen and Emmanuel Dupoux and Yoav Golberg},
	title   = {Assessing the Ability of {LSTM}s to Learn Syntax-Sensitive Dependencies},
	journal = {Transactions of the Association of Computational Linguistics},
	volume = "4",
	year = "2016",
	pages = "521--535"
},

@inproceedings{karpathy_visualizing_2015,
  title={Visualizing and understanding recurrent networks},
  author={Karpathy, Andrej and Johnson, Justin and Fei-Fei, Li},
  booktitle={Proceedings of ICLR 2015},
  year={2015}
},

@article{karpathy_unreasonable_2016,
  title={The unreasonable effectiveness of recurrent neural networks},
  author={Karpathy, Andrej},
  note={http://karpathy.github.io/2015/05/21/rnn-effectiveness},
  year={2016}
},

@article{pollack_recursive_1990,
  title={Recursive distributed representations},
  author={Pollack, Jordan B},
  journal={Artificial Intelligence},
  volume={46},
  number={1},
  pages={77--105},
  year={1990},
  publisher={Elsevier}
},

@inproceedings{grefenstette_learning_2015,
 author = {Grefenstette, Edward and Hermann, Karl Moritz and Suleyman, Mustafa and Blunsom, Phil},
 title = {Learning to Transduce with Unbounded Memory},
 booktitle = {Proceedings of the 28th International Conference on Neural Information Processing Systems},
 series = {NIPS'15},
 year = {2015},
 location = {Montreal, Canada},
 pages = {1828--1836},
 numpages = {9},
 url = {http://dl.acm.org/citation.cfm?id=2969442.2969444},
 acmid = {2969444},
 publisher = {MIT Press},
 address = {Cambridge, MA, USA},
} 

@inproceedings{das_learning_1992,
  title={Learning context-free grammars: Capabilities and limitations of a recurrent neural network with an external stack memory},
  author={Das, Sreerupa and Giles, C Lee and Sun, Guo-Zheng},
  booktitle={Proceedings of The Fourteenth Annual Conference of Cognitive Science Society. Indiana University},
  pages={14},
  year={1992}
},

@inproceedings{joulin_inferring_2015,
  title={Inferring algorithmic patterns with stack-augmented recurrent nets},
  author={Joulin, Armand and Mikolov, Tomas},
  booktitle={Advances in neural information processing systems},
  pages={190--198},
  year={2015}
},

@article{moggi_notions_1991,
  title={Notions of computation and monads},
  author={Moggi, Eugenio},
  journal={Information and computation},
  volume={93},
  number={1},
  pages={55--92},
  year={1991},
  publisher={Elsevier}
},

@inproceedings{bernardy_type_2017,
  author    = {Jean-Philippe Bernardy and Stergios Chatzikyriakidis},
  title     = {A Type-Theoretical system for the FraCaS test suite: Grammatical Framework meets Coq},
  booktitle = {International Workshop on Computational Semantics},
  pages     = {tbd},
  year      = {2017},
},

@unpublished{azero_optimal_1998,
	author = {Pablo R. Azero and S. Doaitse Swierstra},
	type = {manuscript},
	title = {Optimal Pretty Printing Combinators},
	year = {1998},
	note = {Submitted to ICFP 1998}
},

@inproceedings{podkopaev_polynomial_2014,
  author    = {Anton Podkopaev and
               Dmitri Boulytchev},
  title     = {Polynomial-Time Optimal Pretty-Printing Combinators with Choice},
  booktitle = {Perspectives of System Informatics - 9th International Ershov Informatics
               Conference, {PSI} 2014, St. Petersburg, Russia, June 24-27, 2014.
               Revised Selected Papers},
  pages     = {257--265},
  year      = {2014},
  url       = {https://doi.org/10.1007/978-3-662-46823-4_21},
  doi       = {10.1007/978-3-662-46823-4_21},
  timestamp = {Sun, 21 May 2017 00:18:10 +0200},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/ershov/PodkopaevB14},
  bibsource = {dblp computer science bibliography, http://dblp.org}
},

@inproceedings{bernardy_modelling_2017,
        title="Modelling prosodic structure using Artificial Neural Networks",
        author={Jean-Philippe Bernardy and Charalambos Themistocleous},
        booktitle={ExLing 2017: 8th Tutorial and Research Workshop on Experimental Linguistics},
        year = 2017
},

@article{swierstra_linear_2009,
        Author = {Swierstra, S. Doaitse and Chitil, Olaf},
        Date-Added = {2009-02-13 10:17:23 +0100},
        Date-Modified = {2010-02-15 23:09:49 +0100},
        Doi = {10.1017/S0956796808006990},
        Journal = {Journal of Functional Programming},
        Number = {01},
        Pages = {1-16},
        Title = {Linear, bounded, functional pretty-printing},
        Volume = {19},
        Year = {2009},
        Abstract = { ABSTRACT We present two implementations of Oppen's pretty-printing algorithm in Haskell that meet the efficiency of Oppen's imperative solution but have a simpler and a clear structure. We start with an implementation that uses lazy evaluation to simulate two co-operating processes. Then we present an implementation that uses higher-order functions for delimited continuations to simulate co-routines with explicit scheduling. },
        },

@incollection{deb_multi_2016,
  title={Multi-objective optimization},
  author={Deb, Kalyanmoy and Sindhya, Karthik and Hakanen, Jussi},
  booktitle={Decision Sciences: Theory and Practice},
  pages={145--184},
  year={2016},
  publisher={CRC Press}
},

@article{bernardy_linear_2018,
	author = {Jean-Philippe Bernardy and Arnaud Spiwack and Mathieu Boespflug and Ryan Newton and Simon {Peyton Jones}},
	title = {Linear Haskell: practical linearity in a higher-order polymorphic language},
	year = {2018},
        journal = {Proceedings of the ACM on Programming Languages},
        volume = {2},
        issue = {POPL},
},

@inproceedings{krishnaswami_gui_2011,
 author = {Krishnaswami, Neelakantan R. and Benton, Nick},
 title = {A Semantic Model for Graphical User Interfaces},
 booktitle = {Proceedings of the 16th ACM SIGPLAN International Conference on Functional Programming},
 series = {ICFP '11},
 year = {2011},
 isbn = {978-1-4503-0865-6},
 location = {Tokyo, Japan},
 pages = {45--57},
 numpages = {13},
 url = {http://doi.acm.org/10.1145/2034773.2034782},
 doi = {10.1145/2034773.2034782},
 acmid = {2034782},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {denotational semantics, functional reactive programming, guarded recursion, linear logic, ultrametric spaces},
}

@inproceedings{chakravarty_accelerating_2011,
  title={Accelerating Haskell array codes with multicore GPUs},
  author={Chakravarty, Manuel MT and Keller, Gabriele and Lee, Sean and McDonell, Trevor L and Grover, Vinod},
  booktitle={Proceedings of the sixth workshop on Declarative aspects of multicore programming},
  pages={3--14},
  year={2011},
  organization={ACM}
},

@inproceedings{ghica_bounded_2014,
  author    = {Dan R. Ghica and
               Alex I. Smith},
  title     = {Bounded Linear Types in a Resource Semiring},
  booktitle = {Programming Languages and Systems - 23rd European Symposium on Programming,
               {ESOP} 2014, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2014, Grenoble, France, April 5-13,
               2014, Proceedings},
  pages     = {331--350},
  year      = {2014},
  url       = {http://dx.doi.org/10.1007/978-3-642-54833-8_18},
  doi       = {10.1007/978-3-642-54833-8_18},
  timestamp = {Sun, 23 Mar 2014 10:48:25 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/esop/GhicaS14},
  bibsource = {dblp computer science bibliography, http://dblp.org}
},

@article{matsakis_rust_2014,
 author = {Matsakis, Nicholas D. and Klock,II, Felix S.},
 title = {The Rust Language},
 journal = {Ada Lett.},
 issue_date = {December 2014},
 volume = {34},
 number = {3},
 month = oct,
 year = {2014},
 issn = {1094-3641},
 pages = {103--104},
 numpages = {2},
 url = {http://doi.acm.org/10.1145/2692956.2663188},
 doi = {10.1145/2692956.2663188},
 acmid = {2663188},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {affine type systems, memory management, rust, systems programming},
},

@Inbook{honda_session_1993,
  author="Honda, Kohei",
  editor="Best, Eike",
  title="Types for dyadic interaction",
  bookTitle="CONCUR'93: 4th Intrenational Conference on Concurrency
                  Theory Hildesheim, Germany, August 23--26, 1993
                  Proceedings",
  year="1993",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="509--523",
  isbn="978-3-540-47968-0",
  doi="10.1007/3-540-57208-2_35",
  url="http://dx.doi.org/10.1007/3-540-57208-2_35"
},

@inproceedings{lippmeier_parallel_2016,
  title={Polarized data parallel data flow},
  author={Lippmeier, Ben and Mackay, Fil and Robinson, Amos},
  booktitle={Proceedings of the 5th International Workshop on
                  Functional High-Performance Computing},
  pages={52--57},
  year={2016},
  organization={ACM}
},

@Inbook{mcbride_rig_2016,
  author="McBride, Conor",
  editor="Lindley, Sam and McBride, Conor and Trinder, Phil and
                  Sannella, Don",
  title="I Got Plenty o' Nuttin'",
  bookTitle="A List of Successes That Can Change the World: Essays
                  Dedicated to Philip Wadler on the Occasion of His
                  60th Birthday",
  year="2016",
  publisher="Springer International Publishing",
  address="Cham",
  pages="207--233",
  isbn="978-3-319-30936-1",
  doi="10.1007/978-3-319-30936-1_12",
  url="http://dx.doi.org/10.1007/978-3-319-30936-1_12"
},

@article{ahmed_l3_2007,
  title={L$^3$: A Linear Language with Locations},
  author={Ahmed, Amal and Fluet, Matthew and Morrisett, Greg},
  journal={Fundamenta Informaticae},
  volume={77},
  number={4},
  pages={397--449},
  year={2007},
  publisher={IOS Press}
},

@inproceedings{morris_best_2016,
  author    = {J. Garrett Morris},
  title     = {The best of both worlds: linear functional programming without compromise},
  booktitle = {Proceedings of the 21st {ACM} {SIGPLAN} International Conference on
               Functional Programming, {ICFP} 2016, Nara, Japan, September 18-22,
               2016},
  pages     = {448--461},
  year      = {2016},
  url       = {http://doi.acm.org/10.1145/2951913.2951925},
  doi       = {10.1145/2951913.2951925},
  timestamp = {Tue, 30 Aug 2016 13:53:57 +0200},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/icfp/Morris16},
  bibsource = {dblp computer science bibliography, http://dblp.org}
},

@article{bernardy_pretty_2017,
	author = {Jean-Philippe Bernardy},
	title = {Functional Pearl: a pretty but not greedy printer},
        journal = {Proceedings of the ACM on Programming Languages},
	note = {\HREF{Updated version available on the author's homepage}{http://jyp.github.io/pdf/Prettiest.pdf}},
        volume = {1},
        issue = {ICFP},
	year = {2017}
},

@inproceedings{ridge_simple_2014,
	author = {Tom Ridge},
	title = {Simple, Efficient, Sound and Complete Combinator Parsing for All Context-Free Grammars, Using an Oracle},
	booktitle = {Software Language Engineering - 7th International Conference, {SLE}
               2014, V{\"{a}}ster{\aa}s, Sweden, September 15-16, 2014. Proceedings},
	pages = {261--281},
	year = {2014},
	url = {http://dx.doi.org/10.1007/978-3-319-11245-9_15},
	doi = {10.1007/978-3-319-11245-9_15},
	timestamp = {Tue, 09 Sep 2014 10:57:11 +0200},
	biburl = {http://dblp.uni-trier.de/rec/bib/conf/sle/Ridge14},
	bibsource = {dblp computer science bibliography, http://dblp.org}
},

@inproceedings{jourdan_validating_2012,
	author = {Jacques{-}Henri Jourdan and Fran{\c{c}}ois Pottier and Xavier Leroy},
	title = {Validating {LR(1)} Parsers},
	booktitle = {{ESOP} 2012},
	pages = {397--416},
	year = {2012},
	url = {http://dx.doi.org/10.1007/978-3-642-28869-2_20},
	doi = {10.1007/978-3-642-28869-2_20},
	timestamp = {Fri, 23 Mar 2012 15:26:14 +0100},
	biburl = {http://dblp.uni-trier.de/rec/bib/conf/esop/JourdanPL12},
	bibsource = {dblp computer science bibliography, http://dblp.org}
},

@article{firsov_certified_2014,
	author = {Denis Firsov and Tarmo Uustalu},
	title = {Certified {CYK} parsing of context-free languages},
	journal = {J. Log. Algebr. Meth. Program.},
	volume = {83},
	number = {5-6},
	pages = {459--468},
	year = {2014},
	url = {http://dx.doi.org/10.1016/j.jlamp.2014.09.002},
	doi = {10.1016/j.jlamp.2014.09.002},
	timestamp = {Wed, 19 Nov 2014 15:03:06 +0100},
	biburl = {http://dblp.uni-trier.de/rec/bib/journals/jlp/FirsovU14},
	bibsource = {dblp computer science bibliography, http://dblp.org}
},

@inbook{wadler_prettier_2003,
	author = {Philip Wadler},
	title = {A prettier printer},
	Book = {The Fun of Programming, Cornerstones of Computing},
	pages = {223--243},
	editors = {Jeremy Gibbons and Oege {de Moor}},
	year = {2003},
	publisher = {Palgrave MacMillan}
},

@article{mellis_resource_2010,
	author = {Paul-André Melliès and Nicolas Tabareau},
	title = {Resource modalities in tensor logic},
	journal = {Ann. Pure Appl. Logic},
	volume = {161},
	number = {5},
	pages = {632--653},
	year = {2010},
	url = {http://dx.doi.org/10.1016/j.apal.2009.07.018},
	doi = {10.1016/j.apal.2009.07.018},
	timestamp = {Tue, 27 Apr 2010 07:37:14 +0200},
	biburl = {http://dblp.uni-trier.de/rec/bib/journals/apal/MelliesT10},
	bibsource = {dblp computer science bibliography, http://dblp.org}
},

@inproceedings{munch-maccagnoni_formulae-as-types_2014,
	author = {Guillaume Munch{-}Maccagnoni},
	title = {Formulae-as-types for an involutive negation},
	booktitle = {Joint Meeting of the Twenty-Third {EACSL} Annual Conference on Computer
               Science Logic {(CSL)} and the Twenty-Ninth Annual {ACM/IEEE} Symposium
               on Logic in Computer Science (LICS), {CSL-LICS} '14, Vienna, Austria,
               July 14 - 18, 2014},
	pages = {70:1--70:10},
	year = {2014},
	url = {http://doi.acm.org/10.1145/2603088.2603156},
	doi = {10.1145/2603088.2603156},
	timestamp = {Thu, 23 Apr 2015 17:57:17 +0200},
	biburl = {http://dblp.uni-trier.de/rec/bib/conf/csl/Munch-Maccagnoni14},
	bibsource = {dblp computer science bibliography, http://dblp.org}
},

@inproceedings{tov_theory_2011,
	author = {Jesse A. Tov and Riccardo Pucella},
	title = {A theory of substructural types and control},
	booktitle = {Proceedings of the 26th Annual {ACM} {SIGPLAN} Conference on Object-Oriented
               Programming, Systems, Languages, and Applications, {OOPSLA} 2011,
               part of {SPLASH} 2011, Portland, OR, USA, October 22 - 27, 2011},
	pages = {625--642},
	year = {2011},
	url = {http://doi.acm.org/10.1145/2048066.2048115},
	doi = {10.1145/2048066.2048115},
	timestamp = {Tue, 25 Oct 2011 20:48:58 +0200},
	biburl = {http://dblp.uni-trier.de/rec/bib/conf/oopsla/TovP11},
	bibsource = {dblp computer science bibliography, http://dblp.org}
},

@misc{bernardy_duality_2015,
	author = {Jean-Philippe Bernardy and Josef Svenningsson},
	title = {On the Duality of Streams},
	note = {\HREF{Latest version available online}{https://github.com/jyp/organ/blob/master/Organ.lhs}},
	year = {2015}
},

@misc{gonzalez_pipes_2015,
	author = {Gabriel Gonzalez},
	title = {The pipes package},
	url = {http://hackage.haskell.org/packages/pipes},
	year = {2015}
},

@misc{snoyman_conduit_2015,
	author = {Michael Snoyman},
	title = {The conduit package},
	url = {http://www.stackage.org/package/conduit},
	year = {2015}
},

@misc{kmett_machines_2015,
	author = {Edward A. Kmett and Rúnar Bjarnason and Josh Cough},
	title = {The machines package},
	url = {https://github.com/ekmett/machines/},
	year = {2015}
},

@inproceedings{gan_type_2015,
	author = {Edward Gan and Jesse A. Tov and Greg Morrisett},
	title = {Type Classes for Lightweight Substructural Types},
	booktitle = {Proceedings Third International Workshop on Linearity, {LINEARITY}
               2014, Vienna, Austria, 13th July, 2014.},
	pages = {34--48},
	year = {2015},
	url = {http://dx.doi.org/10.4204/EPTCS.176.4},
	doi = {10.4204/EPTCS.176.4},
	timestamp = {Fri, 10 Apr 2015 15:54:52 +0200},
	biburl = {http://dblp.uni-trier.de/rec/bib/journals/corr/GanTM15},
	bibsource = {dblp computer science bibliography, http://dblp.org}
},

@inproceedings{pucella_haskell_2008,
	author = {Riccardo Pucella and Jesse A. Tov},
	title = {Haskell session types with (almost) no class},
	booktitle = {Proceedings of the 1st {ACM} {SIGPLAN} Symposium on Haskell, Haskell
               2008, Victoria, BC, Canada, 25 September 2008},
	pages = {25--36},
	year = {2008},
	url = {http://doi.acm.org/10.1145/1411286.1411290},
	doi = {10.1145/1411286.1411290},
	timestamp = {Fri, 29 Jan 2010 14:44:59 +0100},
	biburl = {http://dblp.uni-trier.de/rec/bib/conf/haskell/PucellaT08},
	bibsource = {dblp computer science bibliography, http://dblp.org}
},

@inproceedings{kay_you_2008,
	author = {Michael Kay},
	title = {You Pull, {I}'ll Push: on the Polarity of Pipelines},
	booktitle = {Proceeding of Balisage: The Markup Conference},
	url = {http://www.balisage.net/Proceedings/vol3/html/Kay01/BalisageVol3-Kay01.html},
	year = {2008}
},

@book{jackson_principles_1975,
	author = {Michael A. Jackson},
	title = {Principles of Program Design},
	year = {1975},
	isbn = {0123790506},
	publisher = {Academic Press, Inc.},
	address = {Orlando, FL, USA}
},

@misc{kiselyov_lazy_2013,
	author = {Oleg Kiselyov},
	title = {Lazy IO breaks equational reasoning},
	year = {2013},
	note = {\HREF{Manuscript available on the author's web page}{http://okmij.org/ftp/Haskell/index.html}}
},

@inproceedings{kiselyov_lazy_2012,
	author = {Oleg Kiselyov and Simon L. {Peyton Jones} and Amr Sabry},
	title = {Lazy v. Yield: Incremental, Linear Pretty-Printing},
	booktitle = {Programming Languages and Systems - 10th Asian Symposium, {APLAS}
               2012, Kyoto, Japan, December 11-13, 2012. Proceedings},
	pages = {190--206},
	year = {2012},
	url = {http://dx.doi.org/10.1007/978-3-642-35182-2_14},
	doi = {10.1007/978-3-642-35182-2_14},
	timestamp = {Mon, 04 Feb 2013 12:47:37 +0100},
	biburl = {http://dblp.uni-trier.de/rec/bib/conf/aplas/KiselyovJS12},
	bibsource = {dblp computer science bibliography, http://dblp.org}
},

@inproceedings{kiselyov_iteratees_2012,
	author = {Oleg Kiselyov},
	title = {Iteratees},
	booktitle = {Functional and Logic Programming - 11th International Symposium, {FLOPS}
               2012, Kobe, Japan, May 23-25, 2012. Proceedings},
	pages = {166--181},
	year = {2012},
	url = {http://dx.doi.org/10.1007/978-3-642-29822-6_15},
	doi = {10.1007/978-3-642-29822-6_15},
	timestamp = {Mon, 21 May 2012 11:24:38 +0200},
	biburl = {http://dblp.uni-trier.de/rec/bib/conf/flops/Kiselyov12},
	bibsource = {dblp computer science bibliography, http://dblp.org}
},

@misc{voevodsky_equivalence_2010,
	author = {Vladimir Voevodsky},
	title = {The equivalence axiom and univalent models of type theory},
	year = {2010},
	note = {\HREF{available online}{http: //www.math.ias.edu/~vladimir/Site3/home_files/}}
},

@misc{chomsky_purpose_2012,
	author = {Noam Chomsky},
	title = {The purpose of education},
	year = {2012},
	note = {Talk at the Learning Without Frontiers Conference, Jan 25th 2012}
},

@misc{harper_foundations_2013,
	author = {Robert W. Harper},
	title = {Foundations and Applications of Higher-Dimensional Directed Type Theory},
	year = {2013},
	note = {Research programme \HREF{available online}{http://www.cs.cmu.edu/~rwh/papers/2dtt-nsf/description.pdf}}
},

@inproceedings{bernardy_presheaf_2015,
	author = {Jean-Philippe Bernardy and Thierry Coquand and Guilhem Moulin},
	title = {A presheaf model of parametric type theory},
	year = {2015},
	booktitle = {MFPS}
},

@phdthesis{moulin_pure_2013,
	author = {Guilhem Moulin},
	title = {Pure Type Systems with an Internalized Parametricity Theorem},
	school = {Chalmers Tekniska Högskola},
	type = {Licenciate Thesis},
	year = {2013}
},

@inproceedings{atkey_relationally_2014,
	author = {Robert Atkey and Neil Ghani and Patricia Johann},
	title = {A relationally parametric model of dependent type theory},
	booktitle = {The 41st Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of
               Programming Languages, {POPL} '14, San Diego, CA, USA, January 20-21,
               2014},
	pages = {503--516},
	year = {2014},
	crossref = {DBLP:conf/popl/2014},
	url = {http://doi.acm.org/10.1145/2535838.2535852},
	doi = {10.1145/2535838.2535852},
	timestamp = {Thu, 09 Jan 2014 08:32:32 +0100},
	biburl = {http://dblp.uni-trier.de/rec/bib/conf/popl/AtkeyGJ14},
	bibsource = {dblp computer science bibliography, http://dblp.org}
},

@inproceedings{krishnaswami_internalizing_2013,
	author = {Neelakantan R. Krishnaswami and Derek Dreyer},
	title = {Internalizing Relational Parametricity in the Extensional Calculus of Constructions},
	booktitle = {Computer Science Logic 2013 {(CSL} 2013), {CSL} 2013, September 2-5,
               2013, Torino, Italy},
	pages = {432--451},
	year = {2013},
	crossref = {DBLP:conf/csl/2013},
	url = {http://dx.doi.org/10.4230/LIPIcs.CSL.2013.432},
	doi = {10.4230/LIPIcs.CSL.2013.432},
	timestamp = {Wed, 04 Sep 2013 20:26:36 +0200},
	biburl = {http://dblp.uni-trier.de/rec/bib/conf/csl/KrishnaswamiD13},
	bibsource = {dblp computer science bibliography, http://dblp.org}
},

@misc{laurent_proof_2004,
	author = {Olivier Laurent},
	title = {A proof of the focalization property of Linear Logic},
	year = {2004},
	howpublished = {Note available on the author's web page.}
},

@misc{bernardy_prettiest_2014,
	author = {Jean-Philippe Bernardy},
	title = {The Prettiest Printer},
	year = {2014},
	howpublished = {\HREF{Blog Entry}{http://www.cse.chalmers.se/~bernardy/prettiest.html}}
},

@phdthesis{lpez_juan_design_2015,
	author = {Victor {López Juan}},
	type = {(Work towards a {MSc} Thesis)},
	title = {Design and implementation of an Array Language with Linear Types},
	school = {Chalmers University of Technology},
	year = {2015}
},

@article{dal_lago_linear_2011,
	author = {Ugo {Dal Lago} and Marco Gaboardi},
	title = {Linear Dependent Types and Relative Completeness},
	journal = {Logical Methods in Computer Science},
	volume = {8},
	number = {4},
	year = {2011},
	ee = {http://dx.doi.org/10.2168/LMCS-8(4:11)2012},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@book{chomsky_syntactic_1957,
	author = {Noam Chomsky},
	title = {Syntactic Structures},
	year = {1957},
	publisher = {Mouton de Gruyter}
},

@incollection{coquand_decision_2011,
	author = {Thierry Coquand and Vincent Siles},
	title = {A decision procedure for regular expression equivalence in type theory},
	booktitle = {Certified Programs and Proofs},
	pages = {119--134},
	year = {2011},
	publisher = {Springer}
},

@article{lee_fast_2002,
	author = {Lillian Lee},
	title = {Fast context-free grammar parsing requires fast boolean matrix multiplication},
	journal = {Journal of the ACM (JACM)},
	volume = {49},
	number = {1},
	pages = {1--15},
	year = {2002},
	publisher = {ACM}
},

@incollection{firsov_certified_2013,
	author = {Denis Firsov and Tarmo Uustalu},
	title = {Certified Parsing of Regular Languages},
	booktitle = {Certified Programs and Proofs},
	pages = {98--113},
	year = {2013},
	publisher = {Springer}
},

@article{wadler_deforestation_1990,
	author = {Philip Wadler},
	title = {Deforestation: Transforming programs to eliminate trees},
	journal = {Theoretical Computer Science},
	volume = {73},
	number = {2},
	pages = {231--248},
	year = {1990},
	publisher = {Elsevier}
},

@phdthesis{marlow_deforestation_1995,
	author = {Simon David Marlow},
	title = {Deforestation for Higher-Order Functional Programs},
	year = {1995},
	school = {University of Glasgow}
},

@inproceedings{pfenning_structural_1995,
	author = {Frank Pfenning},
	title = {Structural cut elimination},
	booktitle = {Logic in Computer Science, Symposium on},
	pages = {156},
	year = {1995},
	organization = {IEEE Computer Society}
},

@inproceedings{pottier_programming_2013,
	author = {François Pottier and Jonathan Protzenko},
	title = {Programming with permissions in {Mezzo}},
	booktitle = {Proceedings of the 2013 {ACM} {SIGPLAN} International
                 Conference on Functional Programming (ICFP'13)},
	month = {sep},
	year = {2013},
	pages = {173--184},
	pdf = {http://gallium.inria.fr/~fpottier/publis/pottier-protzenko-mezzo.pdf},
	longpdf = {http://gallium.inria.fr/~fpottier/publis/mezzo-icfp2013-long.pdf},
	off = {http://dx.doi.org/10.1145/2500365.2500598},
	abstract = {We present Mezzo, a typed programming language of ML
                 lineage. Mezzo is equipped with a novel static
                 discipline of duplicable and affine permissions, which
                 controls aliasing and ownership. This rules out certain
                 mistakes, including representation exposure and data
                 races, and enables new idioms, such as gradual
                 initialization, memory re-use, and (type)state changes.
                 Although the core static discipline disallows sharing a
                 mutable data structure, Mezzo offers several ways of
                 working around this restriction, including a novel
                 dynamic ownership control mechanism which we dub
                 ``adoption and abandon''.}
},

@inproceedings{leivant_foundational_1991,
	author = {Daniel Leivant},
	title = {A foundational delineation of computational feasibility},
	booktitle = {Logic in Computer Science, 1991. LICS'91., Proceedings of Sixth Annual IEEE Symposium on},
	pages = {2--11},
	year = {1991},
	organization = {IEEE}
},

@article{bellantoni_new_1992,
	author = {Spephen Bellantoni and Stephen Cook},
	title = {A new recursion-theoretic characterization of the polytime functions},
	journal = {Computational complexity},
	volume = {2},
	number = {2},
	pages = {97--110},
	year = {1992},
	publisher = {Springer}
},

@article{girard_bounded_1992,
	author = {Jean-Yves Girard and Andre Scedrov and Philip J. Scott},
	file = {:/home/bernardy/Papers/Bounded linear logic a modular approach to polynomial-time computability -1992.pdf:pdf},
	title = {Bounded linear logic: a modular approach to polynomial-time computability },
	journal = {Theoretical Computer Science},
	volume = {97},
	number = {1},
	pages = {1 - 66},
	year = {1992},
	note = {},
	issn = {0304-3975},
	doi = {http://dx.doi.org/10.1016/0304-3975(92)90386-T},
	url = {http://www.sciencedirect.com/science/article/pii/030439759290386T},
	abstract = {Usual typed lambda-calculi yield input/output specifications; in this paper the authors show how to extend this paradigm to complexity specifications. This is achieved by means of a restricted version of linear logic in which the use of exponential connectives is bounded in advance. This bounded linear logic naturally involves polynomials in its syntax and dynamics. It is then proved that any functional term of appropriate type actually encodes a polynomial-time algorithm and that conversely any polynomial-time function can be obtained in this way. }
},

@inproceedings{devito_liszt_2011,
	author = {Zachary DeVito and Niels Joubert and Francisco Palacios and Stephen Oakley and Montserrat Medina and Mike Barrientos and Erich Elsen and Frank Ham and Alex Aiken and Karthik Duraisamy and  others},
	title = {Liszt: a domain specific language for building portable mesh-based PDE solvers},
	booktitle = {Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis},
	pages = {9},
	year = {2011},
	organization = {ACM}
},

@misc{free_software_foundation_gnu_2007,
	author = { {Free Software Foundation}},
	title = {GNU General Public License},
	version = {3},
	shorthand = {GPL},
	url = {http://www.gnu.org/licenses/gpl.html},
	pagination = {section},
	language = {english},
	year = {2007},
	month = {June}
},

@misc{free_software_foundation_gnu_1991,
	author = { {Free Software Foundation}},
	title = {GNU General Public License},
	version = {2},
	shorthand = {GPL},
	url = {http://www.gnu.org/licenses/gpl-2.0.html},
	year = {1991},
	month = {June}
},

@PhDThesis{laurent_etude_2002,
	author = {Olivier Laurent},
	file = {:/home/bernardy/Papers/Etude de la polarisation en logique-2002.pdf:pdf},
	title = {Etude de la polarisation en logique},
	school = {{U}niversit\'e {A}ix-{M}arseille~{II}},
	type = {Th\`ese de Doctorat},
	month = {March},
	year = {2002}
},

@article{girard_light_1998,
	author = {Jean-Yves Girard},
	title = {Light linear logic},
	journal = {Information and Computation},
	volume = {143},
	number = {2},
	pages = {175--204},
	year = {1998},
	publisher = {Elsevier}
},

@inproceedings{marlow_seq_2010,
	author = {Simon Marlow and Patrick Maier and Hans-Wolfgang Loidl and Mustafa K Aswad and Philip W Trinder},
	title = {Seq no more: better strategies for parallel Haskell},
	booktitle = {Haskell},
	pages = {91--102},
	year = {2010},
	organization = {ACM}
},

@inproceedings{lippmeier_guiding_2012,
	author = {Ben Lippmeier and Manuel Chakravarty and Gabriele Keller and Simon {Peyton Jones}},
	title = {Guiding parallel array fusion with indexed types},
	booktitle = {Haskell},
	pages = {25-36},
	year = {2012},
	organization = {ACM}
},

@incollection{dal_lago_bounded_2009,
	author = {Ugo {Dal Lago} and Martin Hofmann},
	title = {Bounded linear logic, revisited},
	booktitle = {Typed Lambda Calculi and Applications},
	pages = {80--94},
	year = {2009},
	publisher = {Springer}
},

@inproceedings{coutts_stream_2007,
	author = {Duncan Coutts and Roman Leshchinskiy and Don Stewart},
	title = {Stream fusion: From lists to streams to nothing at all},
	booktitle = {Haskell},
	pages = {315--326},
	year = {2007},
	organization = {ACM}
},

@misc{bernardy_compiling_2014,
	author = {Jean-Philippe Bernardy and Dan Rosén and Nick Smallbone},
	title = {Compiling Linear Logic Using Continuations},
	note = {\HREF{Draft Available online}{http://www.cse.chalmers.se/~danr/compiling_linear_logic_using_continuations.pdf}},
	year = {2014}
},

@misc{bernardy_linear_2014,
	author = {Jean-Philippe Bernardy and Josef Svenningsson},
	title = {Linear Logic: I See What It Means!},
	note = {\HREF{Draft available online}{http://www.cse.chalmers.se/~bernardy/LL-ISWIM.pdf}},
	year = {2014}
},

@misc{bernardy_controlled_2015,
	author = {Jean-Philippe Bernardy and Josef Svenningsson},
	title = {Controlled Array Fusion using Linear Types},
	note = {Submitted to ESOP 2015. \HREF{Draft available online}{http://www.cse.chalmers.se/~bernardy/LL-Fusion.pdf}},
	year = {2015}
},

@misc{bernardy_composable_2015,
	author = {Jean-Philippe Bernardy and Víctor {López Juan} and Josef Svenningsson},
	title = {Composable Efficient Array Computations Using Linear Types},
	note = {Submitted to ICFP 2015. \HREF{Draft available online}{http://www.cse.chalmers.se/~josefs/publications/vectorcomp.pdf}},
	year = {2015}
},

@inproceedings{lippmeier_efficient_2011,
	author = {Ben Lippmeier and Gabriele Keller},
	title = {Efficient parallel stencil convolution in Haskell},
	booktitle = {Haskell},
	year = {2011},
	pages = {59-70},
	ee = {http://doi.acm.org/10.1145/2034675.2034684},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@incollection{zhu_safe_2005,
	author = {Dengping Zhu and Hongwei Xi},
	title = {Safe programming with pointers through stateful views},
	booktitle = {Practical Aspects of Declarative Languages},
	pages = {83--97},
	year = {2005},
	publisher = {Springer}
},

@article{barendsen_uniqueness_1996,
	author = {Erik Barendsen and Sjaak Smetsers and  others},
	title = {Uniqueness typing for functional languages with graph rewriting semantics},
	journal = {Mathematical Structures in Computer Science},
	volume = {6},
	number = {6},
	pages = {579--612},
	year = {1996}
},

@inproceedings{barendsen_conventional_1993,
	author = {Erik Barendsen and Sjaak Smetsers},
	title = {Conventional and uniqueness typing in graph rewrite systems},
	booktitle = {Foundations of Software Technology and Theoretical Computer Science},
	pages = {41--51},
	year = {1993},
	organization = {Springer}
},

@inproceedings{wadler_linear_1990,
	author = {Philip Wadler},
	editor = {Broy, M and Jones, C B},
	title = {Linear types can change the world},
	booktitle = {Programming Concepts and Methods},
	year = {1990},
	publisher = {North-Holland}
},

@inproceedings{guo_hierarchically_2006,
	author = {Jia Guo and Ganesh Bikshandi and Daniel Hoeflinger and Gheorghe Almasi and Basilio Fraguela and Mar{\'\i}a Jes{\'u}s Garzar{\'a}n and David Padua and Christoph Von Praun},
	title = {Hierarchically tiled arrays for parallelism and locality},
	booktitle = {Parallel and Distributed Processing Symposium, 2006. IPDPS 2006. 20th International},
	pages = {8--pp},
	year = {2006},
	organization = {IEEE}
},

@inproceedings{keller_regular_2010,
	author = {Ben Lippmeier Gabriele Keller and Manuel M. T. Chakravarty and Roman Leshchinskiy and Simon L Peyton Jones},
	title = {Regular, shape-polymorphic, parallel arrays in Haskell},
	booktitle = {ICFP},
	year = {2010},
	pages = {261-272},
	ee = {http://doi.acm.org/10.1145/1863543.1863582},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@phdthesis{tov_practical_2012,
	author = {Jesse A. Tov},
	title = {Practical Programming with Substructural Types},
	year = {2012},
	school = {Northeastern University}
},

@inproceedings{tov_practical_2011,
	author = {Jesse A Tov and Riccardo Pucella},
	title = {Practical affine types},
	booktitle = {POPL},
	pages = {447--458},
	year = {2011},
	organization = {ACM}
},

@inproceedings{girard_geometry_1990,
	author = {Jean-Yves Girard},
	title = {Geometry of interaction 2: deadlock-free algorithms},
	booktitle = {COLOG-88},
	pages = {76--93},
	year = {1990},
	organization = {Springer}
},

@techreport{lafont_continuation_1993,
	author = {Yves Lafont and Bernhard Reus and Thomas Streicher},
	title = {Continuation semantics or expressing implication by negation},
	year = {1993},
	publisher = {Univ. M{\"u}nchen, Inst. f{\"u}r Informatik}
},

@article{glivenko_sur_1929,
	author = {Valery Glivenko},
	title = {Sur quelques points de la logique de {M. Brouwer}},
	journal = {Bulletins de la classe des sciences},
	volume = {15},
	number = {5},
	pages = {183--188},
	year = {1929}
},

@phdthesis{zeilberger_logical_2009,
	author = {Noam Zeilberger},
	file = {:/home/bernardy/Papers/The logical basis of evaluation order and pattern-matching-2009.pdf:pdf},
	title = {The logical basis of evaluation order and pattern-matching},
	year = {2009},
	school = {Carnegie Mellon University}
},

@article{girard_new_1991,
	author = {Jean-Yves Girard},
	title = {A new constructive logic: classical logic},
	journal = {Mathematical Structures in Computer Science},
	volume = {1},
	number = {3},
	pages = {255--296},
	year = {1991},
	publisher = {Cambridge Univ Press}
},

@inproceedings{wand_continuation-based_1980,
	author = {Mitchell Wand},
	title = {Continuation-based Multiprocessing},
	booktitle = {Proceedings of the 1980 ACM Conference on LISP and Functional Programming},
	series = {LFP '80},
	year = {1980},
	location = {Stanford University, California, USA},
	pages = {19--28},
	numpages = {10},
	url = {http://doi.acm.org/10.1145/800087.802786},
	doi = {10.1145/800087.802786},
	acmid = {802786},
	publisher = {ACM},
	address = {New York, NY, USA}
},

@inproceedings{miller_proofs_2007,
	author = {Dale Miller and Alexis Saurin},
	title = {From proofs to focused proofs: a modular proof of focalization in linear logic},
	booktitle = {Computer Science Logic},
	pages = {405--419},
	year = {2007},
	organization = {Springer}
},

@inproceedings{chaudhuri_classical_2010,
	author = {Kaustuv Chaudhuri},
	title = {Classical and intuitionistic subexponential logics are equally expressive},
	booktitle = {Computer Science Logic},
	pages = {185--199},
	year = {2010},
	organization = {Springer}
},

@misc{the_ghc_team_unique_2013,
	author = { {{The} GHC Team}},
	title = {The  Unique supply implementation of the Glasgow Haskell Compiler},
	url = {https://github.com/ghc/ghc/blob/master/compiler/basicTypes/UniqSupply.lhs},
	note = {retrieved Nov. 2013},
	year = {2013}
},

@article{okhotin_parsing_2014,
	author = {Alexander Okhotin},
	title = {Parsing by matrix multiplication generalized to Boolean grammars},
	journal = {Theoretical Computer Science },
	volume = {516},
	number = {0},
	pages = {101 - 120},
	year = {2014},
	note = {},
	issn = {0304-3975},
	doi = {http://dx.doi.org/10.1016/j.tcs.2013.09.011},
	url = {http://www.sciencedirect.com/science/article/pii/S0304397513006919},
	keywords = {Boolean grammars},
	keywords = {Conjunctive grammars},
	keywords = {Context-free grammars},
	keywords = {Matrix multiplication},
	keywords = {Parsing }
},

@inproceedings{ankner_edsl_2013,
	author = {Johan Ankner and Josef David Svenningsson},
	title = {An EDSL approach to high performance Haskell programming},
	booktitle = {Proceedings of the 2013 ACM SIGPLAN symposium on Haskell},
	pages = {1--12},
	year = {2013},
	organization = {ACM}
},

@inproceedings{claessen_splittable_2013,
	author = {Koen Claessen and Micha{\l} H Pa{\l}ka},
	title = {Splittable pseudorandom number generators using cryptographic hashing},
	booktitle = {Proceedings of the 2013 ACM SIGPLAN symposium on Haskell},
	pages = {47--58},
	year = {2013},
	organization = {ACM}
},

@inproceedings{puech_proofs_2013,
	author = {Matthias Puech},
	title = {Proofs, Upside Down - A Functional Correspondence between
               Natural Deduction and the Sequent Calculus},
	booktitle = {APLAS},
	year = {2013},
	pages = {365-380}
},

@article{polakow_relating_1999,
	author = {Jeff Polakow and Frank Pfenning},
	title = {Relating Natural Deduction and Sequent Calculus for Intuitionistic Non-Commutative Linear Logic },
	journal = {Electronic Notes in Theoretical Computer Science },
	volume = {20},
	number = {0},
	pages = {449 - 466},
	year = {1999},
	note = {<ce:title>MFPS XV, Mathematical Foundations of Progamming Semantics, Fifteenth Conference</ce:title> },
	issn = {1571-0661},
	doi = {http://dx.doi.org/10.1016/S1571-0661(04)80088-4},
	url = {http://www.sciencedirect.com/science/article/pii/S1571066104800884}
},

@inproceedings{mazurak_lightweight_2010,
	author = {Karl Mazurak and Jianzhou Zhao and Steve Zdancewic},
	title = {Lightweight linear types in system f},
	booktitle = {Proceedings of the 5th ACM SIGPLAN workshop on Types in language design and implementation},
	pages = {77--88},
	year = {2010},
	organization = {ACM}
},

@article{kuper_freeze_????,
	author = {Lindsey Kuper and Aaron Turon and R Neelakantan and Ryan R Newton},
	title = {Freeze After Writing}
},

@article{andreoli_logic_1992,
	author = {Jean-Marc Andreoli},
	title = {Logic programming with focusing proofs in linear logic},
	journal = {Journal of Logic and Computation},
	volume = {2},
	number = {3},
	pages = {297--347},
	year = {1992},
	publisher = {Oxford Univ Press}
},

@article{nishizaki_programs_1993,
	author = {Shin-ya Nishizaki},
	title = {Programs with continuations and linear logic },
	journal = {Science of Computer Programming },
	volume = {21},
	number = {2},
	pages = {165 - 190},
	year = {1993},
	note = {},
	issn = {0167-6423},
	doi = {http://dx.doi.org/10.1016/0167-6423(93)90005-A},
	url = {http://www.sciencedirect.com/science/article/pii/016764239390005A}
},

@article{mellies_asynchronous_2005,
	author = {Paul-Andr{\'e} Melli{\`e}s},
	title = {Asynchronous Games 3 An Innocent Model of Linear Logic},
	journal = {Electronic Notes in Theoretical Computer Science},
	volume = {122},
	pages = {171--192},
	year = {2005},
	publisher = {Elsevier}
},

@article{krishnamurthi_teaching_2008,
	author = {Shriram Krishnamurthi},
	title = {Teaching programming languages in a post-linnaean age},
	journal = {ACM Sigplan Notices},
	volume = {43},
	number = {11},
	pages = {81},
	year = {2008}
},

@book{krishnamurthi_programming_2007,
	author = {Shriram Krishnamurthi},
	title = {Programming languages: Application and interpretation},
	year = {2007},
	publisher = {Brown Univ.}
},

@book{abelson_structure_1996,
	author = {Harold Abelson and Gerald Jay Sussman},
	title = {Structure and Interpretation of Computer Programs, second edition},
	isbn = {0-262-51087-1},
	year = {1996},
	publisher = {MIT Press}
},

@article{wadler_critique_1987,
	author = {Philip Wadler},
	title = {A critique of Abelson and Sussman or why calculating is better than scheming},
	journal = {ACM SIGPLAN Notices},
	volume = {22},
	number = {3},
	pages = {83--94},
	year = {1987},
	publisher = {ACM}
},

@inproceedings{abramsky_interaction_1996,
	author = {Samson Abramsky and Simon Gay and Rajagopal Nagarajan},
	title = {Interaction categories and the foundations of typed concurrent programming},
	booktitle = {NATO ASI DPD},
	pages = {35--113},
	year = {1996}
},

@article{abramsky_proofs_1994,
	author = {Samson Abramsky},
	title = {Proofs as processes},
	journal = {Theoretical Computer Science},
	volume = {135},
	number = {1},
	pages = {5--9},
	year = {1994},
	publisher = {Elsevier}
},

@article{dean_mapreduce_2008,
	author = {Jeffrey Dean and Sanjay Ghemawat},
	title = {MapReduce: simplified data processing on large clusters},
	journal = {Communications of the ACM},
	volume = {51},
	number = {1},
	pages = {107--113},
	year = {2008},
	publisher = {ACM}
},

@article{gallier_girards_1989,
	author = {Jean H Gallier},
	title = {On {Girard}'s ``{Candidats de Reductibilité}''},
	year = {1989}
},

@article{berry_chemical_1992,
	author = {G{\'e}rard Berry and G{\'e}rard Boudol},
	title = {The chemical abstract machine},
	journal = {Theoretical computer science},
	volume = {96},
	number = {1},
	pages = {217--248},
	year = {1992},
	publisher = {Elsevier}
},

@article{landin_mechanical_1964,
	author = {Peter J Landin},
	title = {The mechanical evaluation of expressions},
	journal = {The Computer Journal},
	volume = {6},
	number = {4},
	pages = {308--320},
	year = {1964},
	publisher = {Br Computer Soc}
},

@article{krivine_call-by-name_2007,
	author = {Jean-Louis Krivine},
	file = {:/home/bernardy/Papers/A call-by-name lambda-calculus machine-2007.:},
	title = {A call-by-name lambda-calculus machine},
	journal = {Higher-Order and Symbolic Computation},
	volume = {20},
	number = {3},
	pages = {199--207},
	year = {2007},
	publisher = {Springer}
},

@article{cockett_proof_1997,
	author = {J Robin B Cockett and Robert AG Seely},
	file = {:/home/bernardy/Papers/Proof theory for full intuitionistic linear logic, bilinear logic, and mix categories-1997.pdf:pdf},
	title = {Proof theory for full intuitionistic linear logic, bilinear logic, and mix categories},
	journal = {Theory and Applications of categories},
	volume = {3},
	number = {5},
	pages = {85--131},
	year = {1997}
},

@misc{caires_linear_????,
	author = {Luís Caires and Frank Pfenning and Bernardo Toninho},
	file = {:/home/bernardy/Papers/Linear logic propositions as session types-????.pdf:pdf},
	title = {Linear logic propositions as session types},
	journal = {Mathematical Structures in Computer Science},
	note = {Submitted}
},

@inproceedings{caires_concurrent_2012,
	author = {Luís Caires and Frank Pfenning and Bernardo Toninho},
	title = {Towards concurrent type theory},
	booktitle = {Proceedings of the 8th ACM SIGPLAN workshop on Types in language design and implementation},
	pages = {1--12},
	year = {2012},
	organization = {ACM}
},

@article{hyland_full_1993,
	author = {Martin Hyland and Valeria de Paiva},
	title = {Full intuitionistic linear logic},
	journal = {Annals of Pure and Applied Logic},
	volume = {64},
	number = {3},
	pages = {273--291},
	year = {1993},
	publisher = {Elsevier}
},

@article{barber_dual_1996,
	author = {Andrew Barber and Gordon Plotkin},
	title = {Dual intuitionistic linear logic},
	journal = {LFCS Report Series-Laboratory for Foundations of Computer Science ECS LFCS},
	year = {1996},
	publisher = {University of Edinburgh, Department of Computer Science, Laboratory for Foundations of Computer Science}
},

@incollection{benton_term_1993,
	author = {Nick Benton and Gavin Bierman and Valeria De Paiva and Martin Hyland},
	title = {A term calculus for intuitionistic linear logic},
	booktitle = {Typed Lambda Calculi and Applications},
	pages = {75--90},
	year = {1993},
	publisher = {Springer}
},

@book{tomita_efficient_1986,
	author = {Masaru Tomita},
	title = {Efficient Parsing for Natural Language},
	year = {1986},
	publisher = {Kluwer Adademic Publishers}
},

@book{cormen_introduction_2001,
	author = {Thomas H Cormen and Charles E Leiserson and Ronald L Rivest and Clifford Stein},
	title = {Introduction to algorithms, second ed.},
	year = {2001},
	publisher = {MIT press}
},

@inproceedings{bernardy_names_2013,
	author = {Jean-Philippe Bernardy and Nicolas Pouillard},
	title = {Names For Free --- Polymorphic Views of Names and Binders},
	year = {2013},
	booktitle = {Proceedings of the 6th {ACM} {SIGPLAN} symposium on {Haskell}},
	publisher = {ACM},
	pages = {13--24}
},

@inproceedings{weirich_binders_2011,
	author = {Stephanie Weirich and Brent A Yorgey and Tim Sheard},
	file = {:/home/bernardy/Papers/Binders unbound-2011.pdf:pdf;:/home/bernardy/Papers/Binders unbound-2011.Yms:Yms},
	title = {Binders unbound},
	booktitle = {ACM SIGPLAN Notices},
	volume = {46},
	number = {9},
	pages = {333--345},
	year = {2011},
	organization = {ACM}
},

@inproceedings{keller_parametricity_2012,
	author = {Chantal Keller and Marc Lasson},
	title = {Parametricity in an Impredicative Sort},
	booktitle = {CSL},
	year = {2012},
	pages = {381-395},
	ee = {http://dx.doi.org/10.4230/LIPIcs.CSL.2012.381},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@inproceedings{altenkirch_monadic_1999,
	author = {Thorsten Altenkirch and Bernhard Reus},
	file = {:/home/bernardy/Papers/Monadic presentations of lambda terms using generalized inductive types-1999.pdf:pdf},
	title = {Monadic presentations of lambda terms using generalized inductive types},
	booktitle = {Computer Science Logic},
	pages = {453--468},
	year = {1999},
	organization = {Springer}
},

@inproceedings{shinwell_freshml_2003,
	author = {Mark R Shinwell and Andrew M Pitts and Murdoch J Gabbay},
	title = {FreshML: Programming with binders made simple},
	booktitle = {Proceedings of the eighth {ACM} {SIGPLAN} international conference on Functional Programming},
	pages = {263--274},
	year = {2003},
	organization = {ACM}
},

@inproceedings{de_bruijn_lambda_1972,
	author = {Nicolaas Govert {de Bruijn}},
	title = {Lambda calculus notation with nameless dummies},
	booktitle = {Indagationes Mathematicae},
	volume = {34},
	year = {1972},
	organization = {Elsevier}
},

@incollection{berger_normalization_1998,
	author = {Ulrich Berger and Matthias Eberl and Helmut Schwichtenberg},
	title = {Normalization by evaluation},
	booktitle = {Prospects for Hardware Foundations},
	pages = {117--137},
	year = {1998},
	publisher = {Springer}
},

@article{bird_bruijn_1999,
	author = {Richard Bird and Ross Paterson},
	file = {:/home/bernardy/Papers/de Bruijn Notation as a Nested Datatype-1999.pdf:pdf},
	title = {{de Bruijn} Notation as a Nested Datatype},
	journal = {Journal of Functional Programming},
	volume = {9},
	number = {1},
	pages = {77--91},
	year = {1999},
	URL = {http://dx.doi.org/10.1017/S0956796899003366},
	publisher = {Cambridge Univ Press}
},

@inproceedings{guillemette_type-preserving_2007,
	author = {Louis-Julien Guillemette and Stefan Monnier},
	title = {A type-preserving closure conversion in haskell},
	booktitle = {Proceedings of the ACM SIGPLAN workshop on Haskell},
	pages = {83--92},
	year = {2007},
	organization = {ACM}
},

@inproceedings{guillemette_type-preserving_2008,
	author = {Louis-Julien Guillemette and Stefan Monnier},
	file = {:/home/bernardy/Papers/A type-preserving compiler in Haskell-2008.pdf:pdf;:/home/bernardy/Papers/A type-preserving compiler in Haskell-2008.Yms:Yms},
	title = {A type-preserving compiler in Haskell},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} international conference on Functional Programming},
	pages = {75--86},
	year = {2008},
	organization = {ACM}
},

@misc{mcbride_not_2010,
	author = {Conor {McBride}},
	title = {I am not a number, I am a classy Hack},
	year = {2010},
	note = {Weblog entry},
	url = {http://www.e-pig.org/epilogue/?p=773}
},

@article{pouillard_unified_2012,
	author = {Nicolas Pouillard and François Pottier},
	file = {:/home/bernardy/Papers/A unified treatment of syntax with binders-2012.pdf:pdf},
	title = {A unified treatment of syntax with binders},
	journal = {Journal of Functional Programming},
	volume = {22},
	number = {4--5},
	pages = {614--704},
	year = {2012}
},

@article{landin_next_1966,
	author = {Peter J Landin},
	file = {:/home/bernardy/Papers/The next 700 programming languages-1966.pdf:pdf},
	title = {The next 700 programming languages},
	journal = {Communications of the ACM},
	volume = {9},
	number = {3},
	pages = {157--166},
	year = {1966},
	publisher = {ACM}
},

@article{bernardy_certified_2015,
	author = {Jean-Philippe Bernardy and Patrik Jansson},
	title = {Certified Context-Free Parsing},
	year = {2015},
        journal = {Logical Methods in Computer Science},
	note = {\HREF{Accepted 2015-12-22, available online}{http://arxiv.org/abs/1601.07724}}
},

@article{bernardy_efficient_2015,
	author = {Jean-Philippe Bernardy and Koen Claessen},
	title = {Efficient Parallel and Incremental Parsing of Practical Context-Free Languages},
        volume = {25},
	year = {2015},
	journal = {Journal of Functional Programming},
        issn = {1469-7653},
        doi = {10.1017/S0956796815000131},
        COMMENTURL = {http://journals.cambridge.org/article_S0956796815000131},
	COMMENTnote = {\HREF{preprint available online}{http://www.cse.chalmers.se/~bernardy/PP.pdf} }
},

@inproceedings{bernardy_efficient_2013,
	author = {Jean-Philippe Bernardy and Koen Claessen},
	title = {Efficient Divide-and-Conquer Parsing of Practical Context-Free Languages},
	year = {2013},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on Functional Programming},
	pages = {111--122}
},

@incollection{brady_resource-safe_2012,
	author = {Edwin Brady and Kevin Hammond},
	title = {Resource-Safe systems programming with embedded domain specific languages},
	booktitle = {Practical Aspects of Declarative Languages},
	pages = {242--257},
	year = {2012},
	publisher = {Springer}
},

@inproceedings{swamy_secure_2011,
	author = {Nikhil Swamy and Juan Chen and C{\'e}dric Fournet and Pierre-Yves Strub and Karthikeyan Bhargavan and Jean Yang},
	title = {Secure distributed programming with value-dependent types},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} international conference on Functional Programming},
	month = {September},
	year = {2011},
	location = {Tokyo, Japan},
	pages = {266--278},
	ee = {http://doi.acm.org/10.1145/2034773.2034811}
},

@article{hirschowitz_topological_2008,
	author = {André Hirschowitz and Michel Hirschowitz and Tom Hirschowitz},
	title = {Topological observations on multiplicative additive linear logic},
	journal = {arXiv preprint arXiv:0807.2636},
	year = {2008}
},

@article{hirschowitz_topological_????,
	author = {Andr{\'e} Hirschowitz and Michel Hirschowitz and Tom Hirschowitz},
	title = {Towards Topological Games}
},

@article{hirschowitz_contraction-free_2009,
	author = {Andr{\'e} Hirschowitz and Michel Hirschowitz and Tom Hirschowitz},
	title = {Contraction-free proofs and finitary games for Linear Logic},
	journal = {Electronic Notes in Theoretical Computer Science},
	volume = {249},
	pages = {287--305},
	year = {2009},
	publisher = {Elsevier}
},

@incollection{girard_parallelism_1987,
	author = {Jean-Yves Girard},
	file = {:/home/bernardy/Papers/Linear logic and parallelism-1987.pdf:pdf},
	forcedkey = {girard_parallelism_1987},
	title = {Linear logic and parallelism},
	booktitle = {Mathematical models for the semantics of parallelism},
	pages = {166--182},
	year = {1987},
	publisher = {Springer}
},

@article{girard_linear_1987,
	author = {Jean-Yves Girard},
	file = {:/home/bernardy/Papers/Linear logic-1987.pdf:pdf},
	title = {Linear logic},
	journal = {Theoretical Computer Science},
	volume = {50},
	number = {1},
	pages = {1--101},
	year = {1987},
	publisher = {Elsevier}
},

@phdthesis{siles_investigation_2010,
	author = {Vincent Siles},
	title = {Investigation on the typing of equality in type systems},
	year = {2010},
	type = {PhD Thesis},
	school = {École Polytechnique}
},

@article{siles_pure_2012,
	author = {Vincent Siles and Hugo Herbelin},
	title = {Pure Type System conversion is always typable},
	journal = {Journal of Functional Programmming},
	volume = {22},
	number = {2},
	year = {2012},
	pages = {153-180},
	ee = {http://journals.cambridge.org/action/displayAbstract?aid=8573390},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@article{hinze_finger_2006,
	author = {Ralf Hinze and Ross Paterson},
	file = {:/home/bernardy/Papers/Finger trees a simple general-purpose data structure-2006.bGQ:bGQ},
	title = {Finger trees: a simple general-purpose data structure},
	journal = {Journal of Functional Programming},
	volume = {16},
	number = {2},
	pages = {197--218},
	year = {2006},
	publisher = {Cambridge Univ Press}
},

@misc{osullivan_criterion_2013,
	author = {Bryan O'Sullivan},
	title = {The {{Criterion}} benchmarking library},
	url = {http://github.com/bos/criterion},
	year = {2013}
},

@article{strassen_gaussian_1969,
	author = {Volker Strassen},
	title = {Gaussian elimination is not optimal},
	journal = {Numerische Mathematik},
	publisher = {Springer Berlin / Heidelberg},
	issn = {0029-599X},
	keyword = {Mathematics and Statistics},
	pages = {354-356},
	volume = {13},
	issue = {4},
	url = {http://dx.doi.org/10.1007/BF02165411},
	note = {10.1007/BF02165411},
	year = {1969}
},

@article{chytil_parallel_1991,
	author = {Michal Chytil and Maxime Crochemore and Burkhard Monien and Wojciech Rytter},
	title = {On the parallel recognition of unambiguous context-free languages},
	journal = {Theoretical Computer Science},
	volume = {81},
	number = {2},
	pages = {311--316},
	year = {1991},
	publisher = {Elsevier}
},

@article{rytter_optimal_1987,
	author = {Wojciech Rytter and Raffaele Giancarlo},
	title = {Optimal parallel parsing of bracket languages},
	journal = {Theoretical computer science},
	volume = {53},
	number = {2},
	pages = {295--306},
	year = {1987},
	publisher = {Elsevier}
},

@inbook{sikkel_parsing_1997,
	author = {Klaas Sikkel and Anton Nijholt},
	title = {Parsing of context-free languages},
	booktitle = {The Handbook of Formal Languages, volume II},
	pages = {61--100},
	year = {1997},
	editor = {G. Rozenberg and A. Salomaa},
	publisher = {Springer-Verlag}
},

@inbook{forsberg_bnfc_2012,
	author = {Markus Forsberg and Aarne Ranta},
	chapter = {Appendix A},
	pages = {175--192},
	title = {BNFC Quick reference},
	booktitle = {Implementing Programming Languages},
	publisher = {College Publications},
	year = {2012}
},


@article{baker_lively_1992,
  author    = {Henry G. Baker},
  title     = {Lively linear Lisp: "look ma, no garbage!"},
  journal   = {{SIGPLAN} Notices},
  volume    = {27},
  number    = {8},
  pages     = {89--98},
  year      = {1992},
  url       = {http://doi.acm.org/10.1145/142137.142162},
  doi       = {10.1145/142137.142162},
  timestamp = {Thu, 06 Feb 2003 12:29:48 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/sigplan/Baker92d},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@inproceedings{wakeling_linearity_1991,
	author = {David Wakeling and Colin Runciman},
	title = {Linearity and laziness},
	booktitle = {Functional Programming Languages and Computer Architecture},
	pages = {215--240},
	year = {1991},
	organization = {Springer},
        url = {https://www.cs.york.ac.uk/plasma/publications/pdf/WakelingRuncimanFPCA91.pdf}
},

@article{mackie_lilac_1994,
	author = {I. Mackie},
	title = {Lilac: A functional programming language based on linear logic},
	journal = {Journal of Functional Programming},
	volume = {4},
	number = {4},
	pages = {395--433},
	year = {1994},
	publisher = {Cambridge Univ Press}
},

@phdthesis{alberti_abstract_1997,
	author = {Francisco J. Alberti},
	file = {:/home/bernardy/Papers/An abstract machine based on linear logic and explicit substitutions-1997.Yms:Yms},
	title = {An abstract machine based on linear logic and explicit substitutions},
	year = {1997},
	type = {Master Thesis},
	school = {The University of Birmingham}
},

@article{lafont_linear_1988,
	author = {Yves Lafont},
	file = {:/home/bernardy/Papers/The linear abstract machine-1988.pdf:pdf},
	title = {The linear abstract machine},
	journal = {Theoretical Computer Science},
	volume = {59},
	number = {1},
	pages = {157--180},
	year = {1988},
	publisher = {Elsevier}
},

@incollection{hofmann_type_2000,
	author = {Martin Hofmann},
	affiliation = {LFCS Edinburgh Mayfield Rd Edinburgh EH9 3JZ UK},
	title = {A Type System for Bounded Space and Functional In-Place Update—Extended Abstract},
	booktitle = {Programming Languages and Systems},
	series = {Lecture Notes in Computer Science},
	editor = {Smolka, Gert},
	publisher = {Springer Berlin / Heidelberg},
	isbn = {978-3-540-67262-3},
	keyword = {Computer Science},
	pages = {165-179},
	volume = {1782},
	doi = {10.1007/3-540-46425-5_11},
	abstract = {We show how linear typing can be used to obtain functional programs which modify heap-allocated data structures in place. We present this both as a “design pattern” for writing C-code in a functional style and as a compilation process from linearly typed first-order functional programs into malloc()-free C code. The main technical result is the correctness of this compilation. The crucial innovation over previous linear typing schemes consists of the introduction of a resource type ◊ which controls the number of constructor symbols such as cons in recursive definitions and ensures linear space while restricting expressive power surprisingly little. While the space efficiency brought about by the new typing scheme and the compilation into C can also be realised by with state-of-the-art optimising compilers for functional languages such as Ocaml [ 15 ], the present method provides guaranteed bounds on heap space which will be of use for applications such as languages for embedded systems or ‘proof carrying code’ [ 18 ].},
	year = {2000}
},

@MISC{hofmann_in-place_2000,
	author = {Martin Hofmann},
	title = {In-place update with linear types or How to compile functional programs into malloc()-free C},
        note = {Preprint},
	year = {2000}
},

@book{bird_introduction_1986,
	author = {Richard Bird},
	title = {An introduction to the theory of lists},
	year = {1986},
	publisher = {Programming Research Group, Oxford University Computing Laboratory}
},

@inproceedings{takeichi_third_2009,
	author = {Akimasa Morihata and
 Kiminori Matsuzaki and
 Zhenjiang Hu and
 Masato Takeichi},
	title = {The third homomorphism theorem on trees: downward {\&}
               upward lead to divide-and-conquer},
	booktitle = {POPL},
	year = {2009},
	pages = {177-185},
	ee = {http://doi.acm.org/10.1145/1480881.1480905},
	crossref = {DBLP:conf/popl/2009},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@article{gibbons_third_1996,
	author = {Jeremy Gibbons},
	title = {The third homomorphism theorem},
	journal = {Journal of Functional Programming},
	volume = {6},
	number = {4},
	pages = {657--665},
	year = {1996}
},

@article{abramsky_computational_1993,
	author = {Samson Abramsky},
	file = {:/home/bernardy/Papers/Computational interpretations of linear logic-1993.pdf:pdf},
	title = {Computational interpretations of linear logic},
	journal = {Theoretical Computer Science},
	volume = {111},
	number = {1},
	pages = {3--57},
	year = {1993},
	publisher = {Elsevier}
},

@book{girard_advances_1995,
	author = {J.Y. Girard and Y. Lafont and L. Regnier},
	title = {Advances in linear logic},
	volume = {222},
	year = {1995},
	publisher = {Cambridge University Press}
},

@inproceedings{cervesato_linear_1996,
	author = {I. Cervesato and F. Pfenning},
	title = {A linear logical framework},
	booktitle = {Logic in Computer Science, 1996. LICS'96. Proceedings., Eleventh Annual IEEE Symposium on},
	pages = {264--275},
	year = {1996},
	organization = {IEEE}
},

@article{gaboardi_linear_2013,
	author = {M. Gaboardi and A. Haeberlen and J. Hsu and A. Narayan and B.C. Pierce},
	title = {Linear Dependent Types for Differential Privacy},
	booktitle = {{POPL} '13: Proceedings of the 40nd {ACM} {SIGPLAN-SIGACT} sysposium on Principles of programming languages},
	year = {2013},
	organization = {{ACM}}
},

@inproceedings{shi_linear_2009,
	author = {R. Shi and H. Xi},
	title = {A linear type system for multicore programming},
	booktitle = {Proceedings of Simposio Brasileiro de Linguagens de Programacao, Gramado, Brazil (August 2009)},
	year = {2009}
},

@inproceedings{burckhardt_two_2011,
	author = {Sebastian Burckhardt and Daan Leijen and Caitlin Sadowski and Jaeheon Yi and Thomas Ball},
	title = {Two for the price of one: A model for parallel and incremental computation},
	booktitle = {Proceedings of the 2011 {ACM} international conference on Object oriented programming systems languages and applications},
	pages = {427--444},
	year = {2011},
	organization = {{ACM}}
},

@article{morita_automatic_2007,
	author = {Kazutaka Morita and Akimasa Morihata and Kiminori Matsuzaki and Zhenjiang Hu and Masato Takeichi},
	file = {:/home/bernardy/Papers/Automatic inversion generates divide-and-conquer parallel programs-2007.pdf:pdf;:/home/bernardy/Papers/Automatic inversion generates divide-and-conquer parallel programs-2007.bGE:bGE},
	title = {Automatic inversion generates divide-and-conquer parallel programs},
	journal = {ACM SIGPLAN Notices},
	volume = {42},
	number = {6},
	pages = {146--155},
	year = {2007}
},

@article{earley_efficient_1970,
	author = {J. Earley},
	title = {An efficient context-free parsing algorithm},
	journal = {Communications of the ACM},
	volume = {13},
	number = {2},
	pages = {94--102},
	year = {1970},
	publisher = {ACM}
},

@techreport{kasami_efficient_1965,
	author = {T. Kasami},
	title = {AN EFFICIENT RECOGNITION AND SYNTAX ANALYSIS ALGORITHM FOR CONTEXT-FREE LANGUAGES.},
	year = {1965},
	institution = {DTIC Document}
},

@book{cocke_programming_1969,
	author = {J. Cocke},
	title = {Programming languages and their compilers: Preliminary notes},
	year = {1969},
	publisher = {Courant Institute of Mathematical Sciences, New York University}
},

@article{younger_recognition_1967,
	author = {D.H. Younger},
	title = {Recognition and parsing of context-free languages in time $n^3$},
	journal = {Information and control},
	volume = {10},
	number = {2},
	pages = {189--208},
	year = {1967},
	publisher = {Elsevier}
},

@inproceedings{wadler_call-by-value_2003,
	author = {Philip Wadler},
	file = {:/home/bernardy/Papers/Call-by-value is dual to call-by-name-2003.pdf:pdf},
	title = {Call-by-value is dual to call-by-name},
	booktitle = {Proceedings of the eighth {ACM} {SIGPLAN} international conference on Functional Programming},
	series = {ICFP '03},
	year = {2003},
	isbn = {1-58113-756-7},
	location = {Uppsala, Sweden},
	pages = {189--201},
	numpages = {13},
	url = {http://doi.acm.org/10.1145/944705.944723},
	doi = {10.1145/944705.944723},
	acmid = {944723},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {Curry-Howard correspondence, De Morgan dual, lambda calculus, lambda mu calculus, logic, natural deduction, sequent calculus}
},

@misc{ko_modularising_2013,
	author = {Hsiang-Shang Ko and Jeremy Gibbons},
	title = {Modularising inductive families},
	year = {2013},
	month = {March},
	note = {To appear in Progress in Informatics.},
	url = {http://www.cs.ox.ac.uk/people/hsiang-shang.ko/pcOrn/pcOrn.pdf}
},

@InProceedings{bove_dependent_2009,
	author = {A. Bove and P. Dybjer},
	title = {Dependent Types at Work},
	booktitle = {Language Engineering and Rigorous Software Development
                  International LerNet ALFA Summer School},
	pages = {57--99},
	year = {2009},
	editor = {A. Bove and L. Barbosa and A. Pardo and J. Sousa Pinto},
	volume = {5520},
	series = {LNCS},
	publisher = {Springer}
},

@inproceedings{dagand_transporting_2012,
	author = {Pierre-Evariste Dagand and Conor McBride},
	title = {Transporting Functions across Ornaments},
	booktitle = {Proceedings of the 17th {ACM} {SIGPLAN} international conference on Functional Programming},
	series = {ICFP '12},
	year = {2012},
	publisher = {ACM},
	address = {New York, NY, USA}
},

@inproceedings{wadler_propositions_2012,
	author = {Philip Wadler},
	title = {Propositions as Sessions},
	booktitle = {Proceedings of the 17th {ACM} {SIGPLAN} international conference on Functional Programming},
	series = {ICFP '12},
	year = {2012},
	pages = {273--286},
	publisher = {ACM},
	address = {New York, NY, USA}
},

@article{abel_irrelevance_2012,
	author = {Andreas Abel and Gabriel Scherer},
	file = {:/home/bernardy/Papers/On Irrelevance and Algorithmic Equality in Predicative Type Theory-2012.pdf:pdf},
	title = {On Irrelevance and Algorithmic Equality in Predicative Type Theory},
	journal = {Logical Methods in Computer Science},
	volume = {8},
	number = {1},
	year = {2012},
	pages = {1--36},
	note = {TYPES'10 special issue.},
	ee = {http://dx.doi.org/10.2168/LMCS-8(1:29)2012},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@inproceedings{abadi_core_1999,
	author = {M. Abadi and A. Banerjee and N. Heintze and J.G. Riecke},
	file = {:/home/bernardy/Papers/A core calculus of dependency-1999.pdf:pdf},
	title = {A core calculus of dependency},
	booktitle = {Proceedings of the 26th {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	pages = {147--160},
	year = {1999},
	organization = {ACM}
},

@article{chomsky_certain_1959,
	author = {N. Chomsky},
	title = {On certain formal properties of grammars},
	journal = {Information and control},
	volume = {2},
	number = {2},
	pages = {137--167},
	year = {1959},
	publisher = {Elsevier}
},

@article{lange_cnf_2009,
	author = {M. Lange and H. Lei{\ss}},
	file = {:/home/bernardy/Papers/To CNF or not to CNF? an efficient yet presentable version of the CYK algorithm-2009.pdf:pdf},
	title = {To {CNF} or not to {CNF}? an efficient yet presentable version of the {CYK} algorithm},
	journal = {Informatica Didactica (8)(2008--2010)},
	year = {2009}
},

@article{valiant_general_1975,
	author = {L.G. Valiant},
	file = {:/home/bernardy/Papers/General context-free recognition in less than cubic time-1975.pdf:pdf},
	title = {General context-free recognition in less than cubic time},
	journal = {Journal of computer and system sciences},
	volume = {10},
	number = {2},
	pages = {308--314},
	year = {1975},
	publisher = {Elsevier}
},

@article{blelloch_programming_1996,
	author = {Guy E. Blelloch},
	title = {Programming parallel algorithms},
	journal = {Communications of the {ACM}},
	issue_date = {March 1996},
	volume = {39},
	number = {3},
	month = {mar},
	year = {1996},
	issn = {0001-0782},
	pages = {85--97},
	numpages = {13},
	url = {http://doi.acm.org/10.1145/227234.227246},
	doi = {10.1145/227234.227246},
	acmid = {227246},
	publisher = {ACM},
	address = {New York, NY, USA}
},

@article{trinder_algorithm+_1998,
	author = {P.W. Trinder and Kevin Hammond and H.W. Loidl and Simon {Peyton Jones}},
	title = {Algorithm+ strategy= parallelism},
	journal = {Journal of functional programming},
	volume = {8},
	number = {1},
	pages = {23--60},
	year = {1998},
	publisher = {Cambridge University Press}
},

@article{smith_derivation_1993,
	author = {D. Smith},
	title = {Derivation of parallel sorting algorithms},
	journal = {Parallel algorithm derivation and program transformation},
	pages = {55--69},
	year = {1993},
	publisher = {Springer}
},

@InProceedings{emoto_generate_2012,
	author = {Kento Emoto and Sebastian Fischer and Zhenjiang Hu},
	title = {Generate, Test, and Aggregate --- A Calculation-based Framework for Systematic Parallel Programming with MapReduce},
	booktitle = {Proceedings of the 22nd European Symposium on Programming (ESOP 2012)},
	publisher = {Springer Verlag},
	year = {2012},
	note = {available at: \url{http://sebfisch.github.com/research/pub/Emoto+ESOP12.pdf}}
},

@article{mu_algebra_2009,
	author = {Shin-Cheng Mu and Hsiang-Shang Ko and Patrik Jansson},
	title = {Algebra of programming in {Agda}: dependent types for relational program derivation},
	publisher = {Cambridge University Press},
	journal = {Journal of Functional Programming},
	volume = {19},
	issue = {5},
	pages = {545--579},
	year = {2009},
	doi = {10.1017/S0956796809007345}
},

@inproceedings{licata_canonicity_2012,
	author = {Daniel Licata and Robert Harper},
	title = {Canonicity for 2-Dimensional Type Theory},
	booktitle = {Proceedings of the 39th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	year = {2012}
},

@inproceedings{axelsson_feldspar_2010,
	author = {Emil Axelsson and Koen Claessen and Gergely D{\'e}vai and Zolt{\'a}n Horv{\'a}th and Karin Keijzer and Bo Lyckeg{\aa}rd and Anders Persson and Mary Sheeran and Josef Svenningsson and Andr{\'a}s Vajda},
	title = {Feldspar: A domain specific language for digital signal processing algorithms},
	booktitle = {Formal Methods and Models for Codesign (MEMOCODE)},
	pages = {169--178},
	year = {2010},
	organization = {IEEE}
},

@inproceedings{chakravarty_data_2007,
	author = {Manuel Chakravarty and Roman Leshchinskiy and Simon {Peyton Jones} and Gabriele Keller and Simon Marlow},
	title = {Data Parallel Haskell: a status report},
	booktitle = {Proceedings of the 2007 workshop on Declarative aspects of multicore programming},
	pages = {10--18},
	year = {2007},
	organization = {ACM}
},

@inproceedings{peyton_jones_harnessing_2008,
	author = {Simon {Peyton Jones} and Roman Leshchinskiy and Gabriele Keller and Manuel Chakravarty},
	file = {:/home/bernardy/Papers/Harnessing the multicores Nested data parallelism in Haskell-2008.pdf:pdf},
	title = {Harnessing the multicores: Nested data parallelism in Haskell},
	booktitle = {IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science (FSTTCS 2008), Dagstuhl, Germany},
	year = {2008},
	organization = {Citeseer}
},

@inproceedings{bernardy_computational_2012,
	author = {Jean-Philippe Bernardy and Guilhem Moulin},
	title = {A Computational Interpretation of Parametricity},
	year = {2012},
	booktitle = {LICS},
	publisher = {IEEE Computer Society}
},

@inproceedings{bernardy_type-theory_2013,
	author = {Jean-Philippe Bernardy and Guilhem Moulin},
	title = {Type-Theory in Color},
	year = {2013},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on Functional Programming},
	pages = {61--72}
},

@misc{bernardy_computational_extended_2012,
	author = {Jean-Philippe Bernardy and Guilhem Moulin},
	forcedkey = {bernardy_computational_extended_2012},
	title = {A Computational Interpretation of Parametricity: Extended Version},
	year = {2012},
	howpublished = {Available at \url{http://publications.lib.chalmers.se/cpl/record/index.xsql?pubid=153094}}
},

@misc{bernardy_computational_2011,
	author = {Jean-Philippe Bernardy and Guilhem Moulin},
	title = {Towards a computational interpretation of parametricity},
	year = {2011},
	howpublished = {Submitted to PoPL 2011}
},

@phdthesis{bernardy_theory_2011,
	author = {Jean-Philippe Bernardy},
	title = {A theory of parametric polymorphism and an application},
	school = {Chalmers Tekniska Högskola},
	type = {PhD Thesis},
	year = {2011}
},

@phdthesis{bernardy_software_2009,
	author = {Jean-Philippe Bernardy},
	title = {Software engineering using functional programming},
	school = {Chalmers Tekniska Högskola},
	type = {Licenciate Thesis},
	year = {2009}
},

@phdthesis{bernardy_integrating_2000,
	author = {Jean-Philippe Bernardy},
	title = {Integrating Genericity into {Java}},
	school = {Unversité Libre de Bruxelles},
	type = {Master Thesis},
	year = {2000}
},

@article{breazu-tannen_extensional_1988,
	author = {V. Breazu-Tannen and T. Coquand},
	title = {Extensional models for polymorphism},
	journal = {Theoretical Computer Science},
	volume = {59},
	number = {1-2},
	pages = {85--114},
	year = {1988},
	publisher = {Elsevier}
},

@article{hasegawa_categorical_1994,
	author = {R. Hasegawa},
	file = {:/home/bernardy/Papers/Categorical data types in parametric polymorphism-1994.ps:ps;:/home/bernardy/Papers/Categorical data types in parametric polymorphism-1994.ps&rct=j&q=categorical%20data%20types%20in%20parametric%20polymorphism&ei=A-4aTpm3GcnCtAbz5ZXPDw&usg=AFQjCNHHXNxPCWNF64Ih-tUq7MFAu-Wffw&sig2=vklhOvMQMZ6uKChXhYTCJw:ps&rct=j&q=categorical%20data%20types%20in%20parametric%20polymorphism&ei=A-4aTpm3GcnCtAbz5ZXPDw&usg=AFQjCNHHXNxPCWNF64Ih-tUq7MFAu-Wffw&sig2=vklhOvMQMZ6uKChXhYTCJw},
	title = {Categorical data types in parametric polymorphism},
	journal = {Mathematical Structures in Computer Science},
	volume = {4},
	number = {01},
	pages = {71--109},
	year = {1994},
	publisher = {Cambridge Univ Press}
},

@inproceedings{pitts_polymorphism_1987,
	author = {A. Pitts},
	file = {:/home/bernardy/Papers/Polymorphism is set theoretic, constructively-1987.pdf:pdf;:/home/bernardy/Papers/Polymorphism is set theoretic, constructively-1987.pdf&rct=j&q=polymorphism%20is%20set%20theoretic%20constructively&ei=p-4aTrjIC8_2sgbnv_S4Dw&usg=AFQjCNGpEhX6AIW8oB2ucrL3wA8UpLMsmg&sig2=BwcbqqfvCIwB_JHH_TPeDA:pdf&rct=j&q=polymorphism%20is%20set%20theoretic%20constructively&ei=p-4aTrjIC8_2sgbnv_S4Dw&usg=AFQjCNGpEhX6AIW8oB2ucrL3wA8UpLMsmg&sig2=BwcbqqfvCIwB_JHH_TPeDA;:/home/bernardy/Papers/Polymorphism is set theoretic, constructively-1987.pdf&rct=j&q=polymorphism%20is%20set%20theoretic%20constructively&ei=p-4aTrjIC8_2sgbnv_S4Dw&usg=AFQjCNGpEhX6AIW8oB2ucrL3wA8UpLMsmg&sig2=BwcbqqfvCIwB_JHH_TPeDA:pdf&rct=j&q=polymorphism%20is%20set%20theoretic%20constructively&ei=p-4aTrjIC8_2sgbnv_S4Dw&usg=AFQjCNGpEhX6AIW8oB2ucrL3wA8UpLMsmg&sig2=BwcbqqfvCIwB_JHH_TPeDA},
	title = {Polymorphism is set theoretic, constructively},
	booktitle = {Category Theory and Computer Science},
	pages = {12--39},
	year = {1987},
	organization = {Springer}
},

@inproceedings{altenkirch_observational_2007,
	author = {T. Altenkirch and C. McBride and W. Swierstra},
	file = {:/home/bernardy/Papers/Observational equality, now!-2007.pdf:pdf},
	title = {Observational equality, now!},
	booktitle = {the 2nd {ACM} {SIGPLAN} workshop on Programming languages meets program verification},
	pages = {57--68},
	year = {2007},
	organization = {ACM}
},

@inproceedings{miller_proof_2003,
	author = {Dale A. Miller and Alwen F. Tiu},
	file = {:/home/bernardy/Papers/A Proof Theory for Generic Judgments An extended abstract-2003.pdf:pdf},
	title = {A Proof Theory for Generic Judgments: An extended abstract},
	booktitle = {Proceedings of the 18th Annual IEEE Symposium on Logic in Computer Science},
	year = {2003},
	month = {June},
	pages = {118--127},
	location = {Ottawa, Canada},
	publisher = {IEEE Computer Society}
},

@inproceedings{pouillard_nameless_2011,
	author = {Nicolas Pouillard},
	file = {:/home/bernardy/Papers/Nameless, Painless-2011.pdf:pdf},
	title = {Nameless, Painless},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} international conference on Functional Programming},
	series = {ICFP '11},
	year = {2011},
	pages = {320--332},
	publisher = {ACM},
	address = {New York, NY, USA},
	note = {to appear}
},

@book{metcalf_fortran_1990,
	author = {Michael Metcalf and John Reid},
	title = {Fortran 90 explained},
	isbn = {0198537727},
	year = {1990},
	publisher = {Oxford University Press}
},

@book{milner_definition_1990,
	author = {Robert Milner and Mads Tofte and Robert Harper},
	title = {The definition of {Standard ML}},
	isbn = {0262631296},
	year = {1990},
	publisher = {MIT press}
},

@inproceedings{danielsson_total_2010,
	author = {Nils Anders Danielsson},
	title = {Total parser combinators},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN} international conference on Functional Programming},
	series = {ICFP '10},
	year = {2010},
	isbn = {978-1-60558-794-3},
	location = {Baltimore, Maryland, USA},
	pages = {285--296},
	numpages = {12},
	url = {http://doi.acm.org/10.1145/1863543.1863585},
	doi = {http://doi.acm.org/10.1145/1863543.1863585},
	acmid = {1863585},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {dependent types, mixed induction and coinduction, parser combinators, productivity, termination}
},

@inproceedings{danielsson_formalisation_2007,
	author = {Nils Anders Danielsson},
	title = {A formalisation of a dependently typed language as an inductive-recursive family},
	booktitle = {Proceedings of the 2006 international conference on Types for proofs and programs},
	series = {TYPES'06},
	year = {2007},
	isbn = {3-540-74463-0, 978-3-540-74463-4},
	location = {Nottingham, UK},
	pages = {93--109},
	numpages = {17},
	url = {http://portal.acm.org/citation.cfm?id=1789277.1789284},
	acmid = {1789284},
	publisher = {Springer-Verlag},
	address = {Berlin, Heidelberg}
},

@book{sun_tzu_art_2003,
	author = { {Sun Tzu}},
	authorChinese = {孫武},
	title = {{The Art of War}},
	isbn = {0140439196},
	year = {2003},
	publisher = {Penguin Classics}
},

@book{jensen_pascal_1991,
	author = {Kathleen Jensen and Niklaus Wirth and Andrew B. Mickel and James F. Miner},
	title = {{PASCAL} user manual and report: {ISO PASCAL} standard},
	isbn = {0387976493},
	year = {1991},
	publisher = {Springer}
},

@incollection{ganzinger_system_1999,
	author = {Harald Ganzinger and Frank Pfenning and Carsten Schürmann},
	file = {:/home/bernardy/Papers/System Description Twelf  A Meta-Logical Framework for Deductive Systems-1999.pdf:pdf},
	affiliation = {Carnegie Mellon University Department of Computer Science USA},
	title = {System Description: Twelf — A Meta-Logical Framework for Deductive Systems},
	booktitle = {Automated Deduction — CADE-16},
	series = {Lecture Notes in Computer Science},
	publisher = {Springer},
	isbn = {},
	pages = {679-679},
	volume = {1632},
	url = {http://dx.doi.org/10.1007/3-540-48660-7_14},
	note = {10.1007/3-540-48660-7_14},
	abstract = {Twelf is a meta-logical framework for the specification, implementation, and meta-theory of deductive systems from the theory of programming languages and logics. It relies on the LF type theory and the judgments-as-types methodology for specification [HHP93], a constraint logic programming interpreter for implementation [Pfe91], and the meta-logic M2 for reasoning about object languages encoded in LF [SP98]. It is a significant extension and complete reimplementation of the Elf system [Pfe94].  Twelf is written in Standard ML and runs under SML of New Jersey and MLWorks on Unix and Window platforms. The current version (1.2) is distributed with a complete manual, example suites, a tutorial in the form of on-line lecture notes [Pfe], and an Emacs interface. Source and binary distributions are accessible via the Twelf home page http://www.cs.cmu.edu/~twelf.},
	year = {1999}
},

@phdthesis{svenningsson_scalable_2007,
	author = {Josef Svenningsson},
	title = {Scalable Program Analysis},
	school = {Chalmers Tekniska Högskola},
	type = {PhD Thesis},
	year = {2007}
},

@inproceedings{chlipala_effective_2009,
	author = {Adam Chlipala and Gregory Malecha and Greg Morrisett and Avraham Shinnar and Ryan Wisnesky},
	file = {:/home/bernardy/Papers/Effective interactive proofs for higher-order imperative programs-2009.pdf:pdf},
	title = {Effective interactive proofs for higher-order imperative programs},
	booktitle = {Proceedings of the 14th {ACM} {SIGPLAN} international conference on Functional Programming},
	series = {ICFP '09},
	year = {2009},
	isbn = {978-1-60558-332-7},
	location = {Edinburgh, Scotland},
	pages = {79--90},
	numpages = {12},
	url = {http://doi.acm.org/10.1145/1596550.1596565},
	doi = {http://doi.acm.org/10.1145/1596550.1596565},
	acmid = {1596565},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {dependent types, functional programming, interactive proof assistants, separation logic}
},

@article{leroy_formal_2009,
	author = {Xavier Leroy},
	title = {Formal verification of a realistic compiler},
	journal = {Communications of the ACM},
	year = {2009},
	volume = {52},
	number = {7},
	pages = {107--115},
	xtopic = {compcert},
	urllocal = {http://gallium.inria.fr/~xleroy/publi/compcert-CACM.pdf},
	urlpublisher = {http://doi.acm.org/10.1145/1538788.1538814},
	abstract = {This paper reports on the development and formal verification (proof
of semantic preservation) of CompCert, a compiler from Clight (a
large subset of the C programming language) to PowerPC assembly code,
using the Coq proof assistant both for programming the compiler and
for proving its correctness.  Such a verified compiler is useful in
the context of critical software and its formal verification: the
verification of the compiler guarantees that the safety properties
proved on the source code hold for the executable compiled code as
well.}
},

@book{martin-lf_intuitionistic_1984,
	author = {Per Martin-Löf},
	file = {:/home/bernardy/Papers/Intuitionistic type theory-1984.pdf:pdf},
	title = {Intuitionistic type theory},
	year = {1984},
	publisher = {Bibliopolis}
},

@conference{reynolds_theory_1974,
	author = {John C. Reynolds},
	file = {:/home/bernardy/Papers/Towards a theory of type structure-1974.pdf:pdf},
	title = {Towards a theory of type structure},
	booktitle = {Colloque sur la Programmation},
	pages = {408--425},
	year = {1974},
	organization = {Springer}
},

@book{admek_abstract_1990,
	author = {J. Adámek and H. Herrlich and G.E. Strecker},
	file = {:/home/bernardy/Papers/Abstract and concrete categories The joy of cats-1990.pdf:pdf},
	title = {{Abstract and concrete categories: The joy of cats}},
	isbn = {0471609226},
	year = {1990},
	publisher = {Wiley}
},

@article{berger_refined_2002,
	author = {U. Berger and W. Buchholz and H. Schwichtenberg},
	title = {Refined program extraction from classical proofs},
	journal = {Annals of Pure and Applied Logic},
	volume = {114},
	number = {1-3},
	pages = {3--25},
	issn = {0168-0072},
	year = {2002},
	publisher = {Elsevier}
},

@book{awodey_category_2010,
	author = {Steve Awodey},
	title = {Category theory},
	isbn = {0199587361},
	year = {2010},
	publisher = {Oxford Univ Press}
},

@phdthesis{bernardy_introducing_2000,
	author = {Jean-Philippe Bernardy},
	title = {Introducing genericity into {Java}},
	school = {Université Libre de Bruxelles},
	type = {Master's Thesis},
	year = {2000}
},

@inproceedings{atkey_unembedding_2009,
	author = {Robert Atkey and Sam Lindley and Jeremy Yallop},
	file = {:/home/bernardy/Papers/Unembedding domain-specific languages-2009.pdf:pdf},
	title = {Unembedding domain-specific languages},
	booktitle = {Proceedings of the 2nd ACM SIGPLAN symposium on Haskell},
	year = {2009},
	isbn = {978-1-60558-508-6},
	location = {Edinburgh, Scotland},
	pages = {37--48},
	numpages = {12},
	url = {http://doi.acm.org/10.1145/1596638.1596644},
	doi = {http://doi.acm.org/10.1145/1596638.1596644},
	acmid = {1596644},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {domain-specific languages, higher-order abstract syntax, type classes, unembedding}
},

@inproceedings{chlipala_parametric_2008,
	author = {Adam Chlipala},
	file = {:/home/bernardy/Papers/Parametric higher-order abstract syntax for mechanized semantics-2008.pdf:pdf},
	title = {Parametric higher-order abstract syntax for mechanized semantics},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} international conference on Functional Programming},
	year = {2008},
	isbn = {978-1-59593-919-7},
	location = {Victoria, BC, Canada},
	pages = {143--156},
	numpages = {14},
	doi = {10.1145/1411204.1411226},
	acmid = {1411226},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {compiler verification, dependent types, interactive proof assistants, type-theoretic semantics}
},

@Article{bernardy_proofs_2012,
	author = {Jean-Philippe Bernardy and Patrik Jansson and Ross
 Paterson},
	title = {Proofs for Free --- Parametricity for Dependent
                  Types},
	journal = {Journal of Functional Programming},
	doi = {10.1017/S0956796812000056},
	year = {2012},
	volume = {22},
	number = {02},
	pages = {107--152},
	COMMENTurl = {https://publications.lib.chalmers.se/cpl/record/index.xsql?pubid=135303},
	authoraccess = {http://journals.cambridge.org/repo_A85iFiOy}
},

@article{kamareddine_canonical_1996,
	author = {F. Kamareddine and R. Nederpelt},
	file = {:/home/bernardy/Papers/Canonical typing and-conversion in the Barendregt Cube-1996.ps:ps},
	title = {{Canonical typing and∏-conversion in the Barendregt Cube}},
	journal = {Journal of Functional Programming},
	volume = {6},
	number = {02},
	pages = {245--267},
	issn = {0956-7968},
	year = {1996},
	publisher = {Cambridge Univ Press}
},

@inproceedings{atkey_when_2010,
	author = {Robert Atkey and Patricia Johann and Neil Ghani},
	title = {When is a Type Refinement an Inductive Type?},
	year = {2010},
	series = {Lecture Notes in Computer Science},
	editor = {Martin Hofmann},
	volume = {6604},
	pages = {72--87},
	booktitle = {Foundations Of Software Science And Computational Structures},
	publisher = {Springer}
},

@article{church_formulation_1940,
	author = {Alonzo Church},
	file = {:/home/bernardy/Papers/A formulation of the simple theory of types-1940.pdf:pdf},
	title = {{A formulation of the simple theory of types}},
	journal = {Journal of symbolic logic},
	volume = {5},
	number = {2},
	pages = {56--68},
	issn = {0022-4812},
	year = {1940},
	publisher = {JSTOR}
},

@inproceedings{bernardy_realizability_2011,
	author = {Jean-Philippe Bernardy and Marc Lasson},
	title = {Realizability and Parametricity in {P}ure {T}ype {S}ystems},
	year = {2011},
	series = {Lecture Notes in Computer Science},
	editor = {Martin Hofmann},
	volume = {6604},
	pages = {108--122},
	booktitle = {Foundations Of Software Science And Computational Structures},
	publisher = {Springer}
},

@inproceedings{abel_irrelevance_2011,
	author = {Andreas Abel},
	file = {:/home/bernardy/Papers/Irrelevance in Type Theory with a Heterogeneous Equality Judgement-2011.pdf:pdf},
	title = {Irrelevance in Type Theory with a Heterogeneous Equality Judgement},
	year = {2011},
	series = {Lecture Notes in Computer Science},
	editor = {Martin Hofmann},
	volume = {6604},
	pages = {57--71},
	booktitle = {Foundations Of Software Science And Computational Structures},
	publisher = {Springer}
},

@inproceedings{hofmann_groupoid_1996,
	author = {Martin Hofmann and Thomas Streicher},
	file = {:/home/bernardy/Papers/The Groupoid Interpretation of Type Theory-1996.pdf:pdf},
	title = {The Groupoid Interpretation of Type Theory},
	booktitle = {Venice Festschrift},
	year = {1996},
	pages = {83--111},
	publisher = {Oxford University Press}
},

@phdthesis{bhme_free_2007,
	author = {Sascha Böhme},
	title = {Free theorems for sublanguages of {Haskell}},
	school = {Technische Universität Dresden},
	type = {Master's Thesis},
	year = {2007},
	note = {Tool currently available (2010) at \url{http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi}}
},

@inproceedings{pouillard_fresh_2010,
	author = {Nicolas Pouillard and François Pottier},
	file = {:/home/bernardy/Papers/A fresh look at programming with names and binders-2010.pdf:pdf},
	title = {A fresh look at programming with names and binders},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN} international conference on Functional Programming},
	year = {2010},
	isbn = {978-1-60558-794-3},
	pages = {217--228},
	location = {Baltimore, Maryland, USA},
	doi = {http://doi.acm.org/10.1145/1863543.1863575},
	publisher = {ACM},
	address = {New York, NY, USA}
},

@article{bernardy_generic_2010,
	author = {Jean-Philippe Bernardy and Patrik Jansson and Marcin
 Zalewski and Sibylle Schupp},
	title = {Generic programming with {C++} concepts and {Haskell}
                  type classes --- a comparison},
	journal = {Journal of Functional Programming},
	volume = {20},
	number = {3--4},
	pages = {271--302},
	year = {2010},
	doi = {10.1017/S095679681000016X},
	COMMENTURL = {http://dx.doi.org/10.1017/S095679681000016X},
	abstract = {Earlier studies have introduced a list of high-level
                  evaluation criteria to assess how well a language
                  supports generic programming. Languages that meet
                  all criteria include Haskell because of its type
                  classes and C++ with the concept feature. We refine
                  these criteria into a taxonomy that captures
                  commonalities and differences between type classes
                  in Haskell and concepts in C++ and discuss which
                  differences are incidental and which ones are due to
                  other language features. The taxonomy allows for an
                  improved understanding of language support for
                  generic programming, and the comparison is useful
                  for the ongoing discussions among language designers
                  and users of both languages.}
},

@conference{abel_algebraic_2008,
	author = {A. Abel and T. Coquand and P. Dybjer},
	file = {:/home/bernardy/Papers/On the algebraic foundation of proof assistants for intuitionistic type theory-2008.pdf:pdf},
	title = {{On the algebraic foundation of proof assistants for intuitionistic type theory}},
	booktitle = {Proceedings of the 9th international conference on Functional and logic programming},
	pages = {3--13},
	year = {2008},
	organization = {Springer-Verlag}
},

@article{lh_tutorial_2001,
	author = {A. Löh and C. McBride and W. Swierstra},
	file = {:/home/bernardy/Papers/A tutorial implementation of a dependently typed lambda calculus-2001.pdf:pdf},
	title = {{A tutorial implementation of a dependently typed lambda calculus}},
	journal = {Fundamenta Informaticae},
	volume = {21},
	pages = {1001--1031},
	year = {2001},
	publisher = {Citeseer}
},

@article{geuvers_pure_2010,
	author = {Herman Geuvers and Robbert Krebbers and James McKinna and Freek Wiedijk},
	file = {:/home/bernardy/Papers/Pure Type Systems without Explicit Contexts-2010.pdf:pdf},
	title = {Pure Type Systems without Explicit Contexts},
	year = {2010}
},

@article{strachey_fundamental_1967,
	author = {C. Strachey},
	file = {:/home/bernardy/Papers/Fundamental concepts in programming languages-2000.pdf:pdf},
	title = {{Fundamental concepts in programming languages}},
	journal = {Higher-Order and Symbolic Computation},
	volume = {13},
	number = {1},
	pages = {11--49},
	year = {1967},
	publisher = {Springer}
},

@phdthesis{geuvers_interpretation_1988,
	author = {Herman Geuvers},
	title = {The interpretation of Logics in Type Systems},
	school = {Catholic University of Nijmegen},
	type = {Master's Thesis},
	year = {1988}
},

@phdthesis{geuvers_logics_1993,
	author = {Herman Geuvers},
	title = {Logics and type systems},
	school = {Catholic University of Nijmegen},
	year = {1993}
},

@phdthesis{berardi_type_1989,
	author = {Stepfano Berardi},
	title = {Type Dependence and Constructive Mathematics},
	school = {Dipartimento di Informatica, Torino},
	year = {1989}
},

@incollection{brady_inductive_2004,
	author = {Edwin Brady and Conor McBride and James McKinna},
	file = {:/home/bernardy/Papers/Inductive Families Need Not Store Their Indices-2004.pdf:pdf},
	affiliation = {Department of Computer Science, University of Durham},
	title = {Inductive Families Need Not Store Their Indices},
	booktitle = {Types for Proofs and Programs},
	series = {Lecture Notes in Computer Science},
	editor = {Berardi, Stefano and Coppo, Mario and Damiani, Ferruccio},
	publisher = {Springer},
	isbn = {},
	pages = {115--129},
	volume = {3085},
	doi = {10.1007/978-3-540-24849-1_8},
	year = {2004}
},

@conference{turbak_cycle_2001,
	author = {F. Turbak and JB Wells},
	file = {:/home/bernardy/Papers/Cycle therapy A prescription for fold and unfold on regular trees-2001.pdf:pdf},
	title = {{Cycle therapy: A prescription for fold and unfold on regular trees}},
	booktitle = {Proceedings of the 3rd ACM SIGPLAN international conference on Principles and practice of declarative programming},
	pages = {149},
	year = {2001},
	organization = {ACM}
},

@inproceedings{augustsson_cayenne_1998,
	author = {Lennart Augustsson},
	file = {:/home/bernardy/Papers/Cayenne---a language with dependent types-1998.pdf:pdf},
	title = {Cayenne --- a language with dependent types},
	booktitle = {ICFP '98: Proceedings of the third ACM SIGPLAN international conference on Functional Programming},
	year = {1998},
	isbn = {1-58113-024-4},
	pages = {239--250},
	location = {Baltimore, Maryland, United States},
	doi = {http://doi.acm.org/10.1145/289423.289451},
	publisher = {ACM},
	address = {New York, NY, USA}
},

@conference{mishra-linger_erasure_2008,
	author = {N. Mishra-Linger and Tim Sheard},
	file = {:/home/bernardy/Papers/Erasure and polymorphism in pure type systems-2008.pdf:pdf},
	title = {{Erasure and polymorphism in pure type systems}},
	booktitle = {Proceedings of the Theory and practice of software, 11th international conference on Foundations of software science and computational structures},
	pages = {350--364},
	year = {2008},
	organization = {Springer-Verlag}
},

@phdthesis{mishra-linger_irrelevance_2008,
	author = {Nathan Mishra-Linger},
	file = {:/home/bernardy/Papers/Irrelevance, Polymorphism, and Erasure in Type Theory-2008.pdf:pdf},
	school = {Portland State University},
	title = {Irrelevance, Polymorphism, and Erasure in Type Theory},
	year = {2008}
},

@conference{kennedy_relational_1997,
	author = {Andrew J Kennedy},
	file = {:/home/bernardy/Papers/Relational parametricity and units of measure-1997.pdf:pdf},
	title = {{Relational parametricity and units of measure}},
	booktitle = {Proceedings of the 24th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	pages = {442--455},
	year = {1997},
	organization = {ACM}
},

@article{mcbride_applicative_2007,
	author = {Conor {McBride} and Ross Paterson},
	file = {:/home/bernardy/Papers/Applicative programming with effects-2007.pdf:pdf},
	title = {Applicative programming with effects},
	volume = {18},
	doi = {10.1017/S0956796807006326},
	url = {http://www.journals.cambridge.org/abstract\_S0956796807006326},
	abstract = {In this article, we introduce Applicative functors â an abstract characterisation of an applicative style of effectful programming, weaker than Monads and hence more widespread. Indeed, it is the ubiquity of this programming pattern that drew us to the abstraction. We retrace our steps in this article, introducing the applicative pattern by diverse examples, then abstracting it to define the Applicative type class and introducing a bracket notation that interprets the normal application syntax in the idiom of an Applicative functor. Furthermore, we develop the properties of applicative functors and the generic operations they support. We close by identifying the categorical structure of applicative functors and examining their relationship both with Monads and with Arrow.},
	number = {01},
	journal = {Journal of Functional Programming},
	year = {2007},
	pages = {1--13}
},

@article{vytiniotis_parametricity_2010,
	author = {Dimitrios Vytiniotis and Stephanie Weirich},
	file = {:/home/bernardy/Papers/Parametricity, Type Equality, and Higher-Order Polymorphism-2010.pdf:pdf},
	doi = {10.1017/S0956796810000079},
	journal = {Journal of Functional Programming},
	number = {02},
	pages = {175--210},
	title = {Parametricity, Type Equality, and Higher-Order Polymorphism},
	volume = {20},
	year = {2010}
},

@inproceedings{villavicencio_reverse_2001,
	author = {G. Villavicencio and J.N. Oliveira},
	file = {:/home/bernardy/Papers/Reverse program calculation supported by code slicing-2001.pdf:pdf},
	title = {Reverse program calculation supported by code slicing},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=957808},
	abstract = {This paper sketches a discipline for reverse engineering which combines formal and semi-formal methods. Among the former is the "algebra of programming", which we apply in "reverse order" so as to reconstruct formal specifications of legacy code. The latter includes code slicing, used as a means of trimming down the complexity of handling the formal semantics of all program variables at the same time. A strong point of the approach is its constructive style. Reverse calculations go as far as imploding auxiliary variables, introducing mutual recursion (if applicable) and transforming semantic functions into standard generic programming schemata such as cata/paramorphisms. We illustrate the approach by reversing a piece of code (from C to Haskell) already studied in the code-slicing literature: the word-count (wc) program},
	booktitle = {Reverse Engineering, 2001. Proceedings. Eighth Working Conference on},
	year = {2001},
	keywords = {aop},
	doi = {10.1109/WCRE.2001.957808},
	publisher = {IEEE Computer Society},
	pages = {35--45}
},

@article{barendregt_introduction_1991,
	author = {Hendrik Pieter Barendregt},
	file = {:/home/bernardy/Papers/Introduction to generalized type systems-1991.pdf:pdf},
	title = {{Introduction to generalized type systems}},
	url = {http://cs.anu.edu.au/student/comp3610/lectures/12-SystemF/intro-to-generalised-type-systems.pdf},
	journal = {Journal of Functional Programming},
	volume = {1},
	number = {2},
	pages = {125--154},
	year = {1991}
},

@article{barendregt_lambda_1992,
	author = {Hendrik Pieter Barendregt},
	file = {:/home/bernardy/Papers/Lambda calculi with types-1992.pdf:pdf},
	title = {Lambda calculi with types},
	doi = {10.1.1.26.4391},
	volume = {2},
	journal = {Handbook of logic in computer science},
	year = {1992},
	pages = {117–309}
},

@article{gibbons_essence_2009,
	author = {Jeremy Gibbons and Bruno C. D. S. Oliveira},
	file = {:/home/bernardy/Papers/The essence of the Iterator pattern-2009.pdf:pdf},
	doi = {10.1017/S0956796809007291},
	issn = {0956-7968},
	journal = {Journal of Functional Programming},
	keywords = {design pattern,fold,idiom,iterator,map,monad,traversal},
	month = {jun},
	number = {3-4},
	pages = {377},
	title = {{The essence of the Iterator pattern}},
	url = {http://www.journals.cambridge.org/abstract\_S0956796809007291},
	volume = {19},
	year = {2009},
	see = {version:gibbons_essence_2006}
},

@inproceedings{gibbons_essence_2006,
	author = {Jeremy Gibbons and Bruno Oliveira and Conor Mcbride and Tarmo Uustalu},
	title = {The Essence of the Iterator Pattern},
	url = {http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/iterator-msfp.pdf},
	abstract = {The Iterator pattern gives a clean interface for element-by-element access to a collection. Imperative iterations using the pattern have two simultaneous aspects: mapping and accumulating. Various functional iterations model one or other of these, but not both simultaneously. We argue that {McBride} and Paterson's idioms, and in particular the corresponding traverse operator, do exactly this, and therefore capture the essence of the Iterator pattern. We present some axioms for traversal, and illustrate with a simple example, the repmin problem.},
	booktitle = {{Mathematically-Structured} Functional Programming, Kuressaare, Estonia},
	month = {jul},
	year = {2006},
	keywords = {aop}
},

@article{ager_functional_2004,
	author = {Mads Ager and Olivier Danvy and Jan Midtgaard},
	file = {:/home/bernardy/Papers/A functional correspondence between call-by-need evaluators and lazy abstract machines-2004.pdf:pdf},
	title = {A functional correspondence between call-by-need evaluators and lazy abstract machines},
	doi = {10.1016/j.ipl.2004.02.012},
	volume = {90},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S0020019004000638},
	abstract = {We bridge the gap between compositional evaluators and abstract machines for the lambda-calculus, using closure conversion, transformation into continuation-passing style, and defunctionalization of continuations. This article is a followup of our article at {PPDP} 2003, where we consider call by name and call by value. Here, however, we consider call by need. We derive a lazy abstract machine from an ordinary call-by-need evaluator that threads a heap of updatable cells. In this resulting abstract machine, the continuation fragment for updating a heap cell naturally appears as an [`]update marker', an implementation technique that was invented for the Three Instruction Machine and subsequently used to construct lazy variants of Krivine's abstract machine. Tuning the evaluator leads to other implementation techniques such as unboxed values. The correctness of the resulting abstract machines is a corollary of the correctness of the original evaluators and of the program transformations used in the derivation.},
	number = {5},
	journal = {Information Processing Letters},
	month = {jun},
	year = {2004},
	keywords = {abstract machines,closure conversion,cps transformation,functional programming,interpreters,program derivation},
	keywords = {cps, defunc},
	pages = {223--232},
	see = {:ager_functional_2003}
},

@inproceedings{ager_functional_2003,
	author = {Mads Ager and Dariusz Biernacki and Olivier Danvy and Jan Midtgaard},
	title = {A functional correspondence between evaluators and abstract machines},
	isbn = {1581137052},
	url = {http://dx.doi.org/10.1145/888251.888254},
	booktitle = {{PPDP} '03: Proceedings of the 5th {ACM} {SIGPLAN} international conference on Principles and practice of declaritive programming},
	publisher = {{ACM} Press},
	year = {2003},
	keywords = {cps},
	pages = {8--19}
},

@incollection{jones_type_2000,
	author = {Mark P. Jones},
	file = {:/home/bernardy/Papers/Type Classes with Functional Dependencies-2000.pdf:pdf},
	title = {Type Classes with Functional Dependencies},
	url = {http://dx.doi.org/10.1007/3-540-46425-5_15},
	abstract = {Type classes in Haskell allow programmers to define functions that can be used on a set of different types, with a potentially different implementation in each case. For example, type classes are used to support equality and numeric types, and for monadic programming. A commonly requested extension to support âmultiple parametersâ allows a more general interpretation of classes as relations on types, and has many potentially useful applications. Unfortunately, many of these examples do not work well in practice, leading to ambiguities and inaccuracies in inferred types and delaying the detection of type errors. This paper illustrates the kind of problems that can occur with multiple parameter type classes, and explains how they can be resolved by allowing programmers to specify explicit dependencies between the parameters. A particular novelty of this paper is the application of ideas from the theory of relational databases to the design of type systems.},
	booktitle = {ESOP},
	year = {2000},
	keywords = {typeclass},
	pages = {230--244}
},

@article{sulzmann_understanding_2007,
	author = {Martin Sulzmann and Gregory J. Duck and Simon {Peyton-Jones} and Peter Stuckey},
	file = {:/home/bernardy/Papers/Understanding functional dependencies via constraint handling rules-2007.pdf:pdf},
	title = {Understanding functional dependencies via constraint handling rules},
	volume = {17},
	doi = {10.1017/S0956796806006137},
	issn = {0956-7968},
	url = {http://dx.doi.org/10.1017/S0956796806006137},
	number = {1},
	issn = {0956-7968},
	journal = {Journal of Functional Programming},
	year = {2007},
	keywords = {typeclass},
	pages = {83--129}
},

@incollection{malik_generating_2007,
	author = {Muhammad Malik and Aman Pervaiz and Sarfraz Khurshid},
	file = {:/home/bernardy/Papers/Generating Representation Invariants of Structurally Complex Data-2007.pdf:pdf},
	title = {Generating Representation Invariants of Structurally Complex Data},
	url = {http://www.springerlink.com/index/u35h787512q2j106.pdf},
	doi = {10.1007/978-3-540-71209-1_5},
	abstract = {Generating likely invariants using dynamic analyses is becoming an increasingly effective technique in software checking methodologies. This paper presents Deryaft, a novel algorithm for generating likely representation invariants of structurally complex data. Given a small set of concrete structures, Deryaft analyzes their key characteristics to formulate local and global properties that the structures exhibit. For effective formulation of structural invariants, Deryaft focuses on graph properties, including reachability, and views the program heap as an edge-labeled graph. Deryaft outputs a Java predicate that represents the invariants; the predicate takes an input structure and returns true if and only if it satisfies the invariants. The invariants generated by Deryaft directly enable automation of various existing frameworks, such as the Korat test generation framework and the Juzi data structure repair framework, which otherwise require the user to provide the invariants. Experimental results with the Deryaft prototype show that it feasibly generates invariants for a range of subject structures, including libraries as well as a stand-alone application.},
	booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
	year = {2007},
	keywords = {invariant, recovery},
	pages = {34--49},
	annote = {{\textless}p{\textgreater}* works on a snapshot of dynamic data * graph-like representation of heap * popular contender: Daikon (can be better for some inputs){\textless}/p{\textgreater}}
},

@inproceedings{ramsey_algebraic_2001,
	author = {Norman Ramsey and Elöd Csirmaz},
	file = {:/home/bernardy/Papers/An algebraic approach to file synchronization-2001.pdf:pdf},
	title = {An algebraic approach to file synchronization},
	isbn = {0163-5948},
	doi = {10.1145/503271.503233},
	booktitle = {{ESEC/FSE-9:} Proceedings of the 8th European software engineering conference held jointly with 9th {ACM} {SIGSOFT} international symposium on Foundations of software engineering},
	publisher = {{ACM} Press},
	year = {2001},
	keywords = {synch, vc},
	pages = {175--185}
},

@article{robbes_change-based_2007,
	author = {Romain Robbes and Michele Lanza},
	file = {:/home/bernardy/Papers/A Change-based Approach to Software Evolution-2007.pdf:pdf},
	title = {A Change-based Approach to Software Evolution},
	volume = {166},
	url = {http://dx.doi.org/10.1016/j.entcs.2006.06.015},
	abstract = {Software evolution research is limited by the amount of information available to researchers: Current version control tools do not store all the information generated by developers. They do not record every intermediate version of the system issued, but only snapshots taken when a developer commits source code into the repository. Additionally, most software evolution analysis tools are not a part of the day-to-day programming activities, because analysis tools are resource intensive and not integrated in development environments. We propose to model development information as change operations that we retrieve directly from the programming environment the developers are using, while they are effecting changes to the system. This accurate and incremental information opens new ways for both developers and researchers to explore and evolve complex systems.},
	journal = {Electronic Notes in Theoretical Computer Science},
	month = {jan},
	year = {2007},
	keywords = {evolution},
	pages = {93--109}
},

@misc{czerwinski_polynominal_2008,
	author = {Reiner Czerwinski},
	file = {:/home/bernardy/Papers/A Polynominal Time Algorithm for Graph Isomorphism-2008.pdf:pdf},
	title = {A Polynominal Time Algorithm for Graph Isomorphism},
	url = {http://arxiv.org/abs/0711.2010},
	arxivId = {0711.2010},
	abstract = {Algorithms testing two graphs for isomorphism known as yet have exponential worst case complexity. In this paper we propose a new algorithm that has polynomial complexity and constructively supplies the evidence that the graph isomorphism lies in P.},
	year = {2008},
	keywords = {algorithm, graph, isomorphism, polynomial},
	howpublished = {\url{http://arxiv.org/abs/0711.2010}}
},

@article{bird_generalised_1999,
	author = {Richard Bird and Ross Paterson},
	file = {:/home/bernardy/Papers/Generalised folds for nested datatypes-1999.pdf:pdf},
	title = {Generalised folds for nested datatypes},
	volume = {11},
	url = {http://dx.doi.org/10.1007/s001650050047},
	abstract = {Nested datatypes generalise regular datatypes in much the same way that context-free languages generalise regular ones. Although the categorical semantics of nested types turns out to be similar to the regular case, the fold functions are more limited because they can only describe natural transformations. Practical considerations therefore dictate the introduction of a generalised fold function in which this limitation can be overcome. In the paper we show how to construct generalised folds systematically for each nested datatype, and show that they possess a uniqueness property analogous to that of ordinary folds. As a consequence, generalised folds satisfy fusion properties similar to those developed for regular datatypes. Such properties form the core of an effective calculational theory of inductive datatypes.},
	number = {2},
	journal = {Formal Aspects of Computing},
	year = {1999},
	keywords = {aop},
	pages = {200--222}
},

@article{garcia_extended_2007,
	author = {Ronald Garcia and Jaakko Jarvi and Andrew Lumsdaine and Jeremy Siek and Jeremiah Willcock},
	file = {:/home/bernardy/Papers/An extended comparative study of language support for generic programming-2007.pdf:pdf},
	title = {An extended comparative study of language support for generic programming},
	volume = {17},
	issn = {0956-7968},
	doi = {10.1017/S0956796806006198},
	url = {http://www.journals.cambridge.org/abstract\_S0956796806006198},
	number = {2},
	journal = {Journal of Functional Programming},
	month = {mar},
	year = {2007},
	keywords = {concept, typeclass},
	pages = {145--205}
},

@inproceedings{garcia_comparative_2003,
	author = {Ronald Garcia and Jaakko Jarvi and Andrew Lumsdaine and Jeremy Siek and Jeremiah Willcock},
	title = {A comparative study of language support for generic programming},
	url = {http://dx.doi.org/http://doi.acm.org/10.1145/949305.949317},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} conference on Object-oriented programing, systems, languages, and applications},
	publisher = {{ACM} Press},
	year = {2003},
	keywords = {sibylle, wgp08},
	pages = {115--134},
	see = {version:garcia_extended_2007}
},

@inproceedings{swierstra_combinator_2009,
	author = {S. Doaitse Swierstra},
	file = {:/home/bernardy/Papers/Combinator Parsing A Short Tutorial-2009.pdf:pdf},
	address = {Piriapolis},
	series = {Lecture Notes in Computer Science},
	title = {Combinator Parsing: A Short Tutorial},
	volume = {5520},
	url = {http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf},
	booktitle = {Language Engineering and Rigorous Software Development},
	publisher = {Springer},
	year = {2009},
	pages = {252--300}
},

@article{mens_detecting_2005,
	author = {Tom Mens and Gabriele Taentzer and Olga Runge},
	file = {:/home/bernardy/Papers/Detecting Structural Refactoring Conflicts Using Critical Pair Analysis-2005.pdf:pdf},
	doi = {10.1016/j.entcs.2004.08.038},
	title = {Detecting Structural Refactoring Conflicts Using Critical Pair Analysis},
	volume = {127},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S157106610500143X},
	abstract = {Refactorings are program transformations that improve the software structure while preserving the external behaviour. In spite of this very useful property, refactorings can still give rise to structural conflicts when parallel evolutions to the same software are made by different developers. This paper explores this problem of structural evolution conflicts in a formal way by using graph transformation and critical pair analysis. Based on experiments carried out in the graph transformation tool {AGG,} we show how this formalism can be exploited to detect and resolve refactoring conflicts.},
	number = {3},
	journal = {Electronic Notes in Theoretical Computer Science},
	month = {apr},
	year = {2005},
	keywords = {conflicts,critical pair analysis,evolution,graph transformation,parallel changes,refactoring,restructuring},
	pages = {113--128}
},

@article{apiwattanapong_jdiff_2007,
	author = {Taweesup Apiwattanapong and Alessandro Orso and Mary Jean Harrold},
	file = {:/home/bernardy/Papers/JDiff A differencing technique and tool for object-oriented programs-2007.pdf:pdf},
	doi = {10.1007/s10515-006-0002-0},
	issn = {0928-8910},
	journal = {Automated Software Engineering},
	month = {dec},
	number = {1},
	pages = {3--36},
	title = {{JDiff: A differencing technique and tool for object-oriented programs}},
	url = {http://www.springerlink.com/index/10.1007/s10515-006-0002-0},
	volume = {14},
	year = {2007}
},

@book{jones_partial_1993,
	author = {Neil D. Jones and Carsten K. Gomard and Peter Sestoft},
	file = {:/home/bernardy/Papers/Partial Evaluation and Automatic Program Generation-1993.pdf:pdf},
	booktitle = {Transformation},
	publisher = {Prentice Hall},
	title = {Partial Evaluation and Automatic Program Generation},
	url = {http://www.dina.dk/~sestoft/pebook/pebook.html},
	year = {1993}
},

@incollection{barras_implicit_2008,
	author = {Bruno Barras and Bruno Bernardo},
	file = {:/home/bernardy/Papers/The Implicit Calculus of Constructions as a Programming Language with Dependent Types-2008.pdf:pdf},
	title = {The Implicit Calculus of Constructions as a Programming Language with Dependent Types},
	url = {http://www.springerlink.com/index/M84H82904546L265.pdf},
	doi = {10.1007/978-3-540-78499-9_26},
	abstract = {In this paper, we show how Miquel’s Implicit Calculus of Constructions {(ICC)} can be used as a programming language featuring
dependent types. Since this system has an undecidable type-checking, we introduce a more verbose variant, called {ICC*} which fixes this issue. Datatypes and program specifications are enriched with logical assertions (such as preconditions,
postconditions, invariants) and programs are decorated with proofs of those assertions. The point of using {ICC*} rather than the Calculus of Constructions (the core formalism of the Coq proof assistant) is that all of the static information
(types and proof objects) is transparent, in the sense that it does not affect the computational behavior. This is concretized
by a built-in extraction procedure that removes this static information. We also illustrate the main features of {ICC*} on classical examples of dependently typed programs.},
	booktitle = {Foundations of Software Science and Computational Structures},
	publisher = {Springer},
	year = {2008},
	pages = {365--379}
},

@inproceedings{paulin-mohring_extracting_1989,
	author = {Christine Paulin-Mohring},
	file = {:/home/bernardy/Papers/Extracting F's programs from proofs in the calculus of constructions-1989.pdf:pdf},
	title = {Extracting {Fω}'s programs from proofs in the calculus of constructions},
	booktitle = {POPL '89: Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	year = {1989},
	isbn = {0-89791-294-2},
	pages = {89--104},
	location = {Austin, Texas, United States},
	doi = {http://doi.acm.org/10.1145/75277.75285},
	publisher = {ACM},
	COMMENTaddress = {New York, NY, USA}
},

@incollection{batory_program_2007,
	author = {Don Batory},
	file = {:/home/bernardy/Papers/Program Refactoring, Program Synthesis, and Model-Driven Development-2007.pdf:pdf},
	title = {Program Refactoring, Program Synthesis, and {Model-Driven} Development},
	url = {http://www.springerlink.com/index/c0916633k2q4911x.pdf},
	doi = {10.1007/978-3-540-71229-9_11},
	abstract = {Program refactoring, feature-based and aspect-oriented software synthesis, and model-driven development are disjoint research areas. However, they are all architectural metaprogramming technologies as they treat programs as values and use functions (a.k.a. transformations) to map programs to other programs. In this paper, I explore their underlying connections by reviewing recent advances in each area from an architectural metaprogramming perspective. I conjecture how these areas can converge and outline a theory that may unify them.},
	booktitle = {Compiler Construction},
	year = {2007},
	keywords = {calculus, program},
	pages = {156--171},
	annote = {{\textless}p{\textgreater}* Conjectures that refactoring, synthesis and model-driven development will converge (but {NOT} \&quot;how\&quot; as the abstract says) * Review of these areas in the light of the conjecture{\textless}/p{\textgreater}}
},

@incollection{meertens_calculate_1996,
	author = {Lambert Meertens},
	file = {:/home/bernardy/Papers/Calculate polytypically!-1996.pdf:pdf},
	title = {Calculate polytypically!},
	url = {http://www.springerlink.com/index/f021401k11vj268p.pdf},
	doi = {10.1007/3-540-61756-6_73},
	abstract = {A polytypic function definition is a function definition that is parametrised with a datatype. It embraces a class of algorithms. As an example we define a simple polytypic crush combinator that can be used to calculate polytypically. The ability to define functions polytypically adds another level of flexibility in the reusability of programming idioms and in the design of libraries of interoperable components.},
	booktitle = {Programming Languages: Implementations, Logics, and Programs},
	year = {1996},
	keywords = {aop},
	pages = {1--16}
},

@inproceedings{launchbury_natural_1993,
	author = {John Launchbury},
	title = {A Natural Semantics for Lazy Evaluation},
	booktitle = {POPL},
	year = {1993},
	pages = {144-154}
},

@article{day_logical_1999,
	author = {Nancy A. Day and John Launchbury and Jeff Lewis},
	file = {:/home/bernardy/Papers/Logical abstractions in Haskell-1999.pdf:pdf},
	title = {Logical abstractions in {Haskell}},
	url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.2140},
	doi = {10.1.1.37.2140},
	journal = {In Proceedings of the 1999 Haskell Workshop},
	year = {1999}
},

@inproceedings{weirich_arity-generic_2010,
	author = {Stephanie Weirich and Chris Casinghino},
	file = {:/home/bernardy/Papers/Arity-generic datatype-generic programming-2010.pdf:pdf},
	booktitle = {PLPV},
	doi = {10.1145/1816027.1816036},
	issn = {03621340},
	keywords = {agda,arity-generic programming,dependent types},
	month = {jun},
	number = {11},
	pages = {7},
	title = {{Arity-generic datatype-generic programming}},
	url = {http://portal.acm.org/citation.cfm?doid=1816027.1816036},
	volume = {44},
	year = {2010},
	see = {:gibbons_datatype-generic_2007}
},

@incollection{gibbons_datatype-generic_2007,
	author = {Jeremy Gibbons},
	file = {:/home/bernardy/Papers/Datatype-Generic Programming-2007.pdf:pdf},
	title = {{Datatype-Generic} Programming},
	url = {http://dx.doi.org/10.1007/978-3-540-76786-2_1},
	abstract = {Generic programming aims to increase the flexibility of programming languages, by expanding the possibilities for parametrization â ideally, without also expanding the possibilities for uncaught errors. The term means different things to different people: parametric polymorphism, data abstraction, meta-programming, and so on. We use it to mean polytypism, that is, parametrization by the shape of data structures rather than their contents. To avoid confusion with other uses, we have coined the qualified term datatype-generic programming for this purpose. In these lecture notes, we expand on the definition of datatype-generic programming, and present some examples of datatype-generic programs. We also explore the connection with design patterns in object-oriented programming; in particular, we argue that certain design patterns are just higher-order datatype-generic programs.},
	booktitle = {{Datatype-Generic} Programming},
	year = {2007},
	keywords = {concept, typeclass},
	pages = {1--71}
},

@misc{asperti_modified_2006,
	author = {Andrea Asperti and Enrico Tassi},
	file = {:/home/bernardy/Papers/Modified Realizability and Inductive Types-2006.pdf:pdf},
	title = {{Modified Realizability and Inductive Types}},
	institution = {Department of Computer Science, University of Bologna},
	year = {2006}
},

@unpublished{vytiniotis_type-safe_2009,
	author = {D. Vytiniotis and S. Weirich},
	file = {:/home/bernardy/Papers/Type-safe cast does no harm Syntactic parametricity for F and beyond-2009.pdf:pdf},
	title = {Type-safe cast does no harm: Syntactic parametricity for {Fω} and beyond},
	shorttitle = {Type-safe cast does no harm},
	year = {2009},
	note = {Preliminary version of ``Parametricity, Type Equality, and Higher-order Polymorphism''}
},

@unpublished{marlow_haskell_2010,
	author = {Simon Marlow},
	file = {:/home/bernardy/Papers/Haskell 2010 Language Report-2010.pdf:pdf},
	title = {Haskell 2010 Language Report},
	howpublished = {\url{http://haskell.org/definition/haskell2010.pdf}},
	year = {2010}
},

@phdthesis{okasaki_purely_1996,
	author = {Chris Okasaki},
	file = {:/home/bernardy/Papers/Purely Functional Data Structure-1996.pdf:pdf},
	school = {Carnegie Mellon University},
	title = {Purely Functional Data Structure},
	year = {1996}
},

@book{okasaki_purely_1999,
	author = {Chris Okasaki},
	title = {Purely Functional Data Structures},
	isbn = {0521663504},
	publisher = {Cambridge University Press},
	month = {jul},
	year = {1999},
	pages = {220},
	see = {version:okasaki_purely_1996}
},

@techreport{coquand_calculus_1986,
	author = {Thierry Coquand and Gérard Huet},
	file = {:/home/bernardy/Papers/The calculus of constructions-1986.pdf:pdf},
	publisher = {Institut National de Recherche en, Informatique et en Automatique},
	institution = {INRIA},
	title = {The calculus of constructions},
	year = {1986},
	see = {used:barras_implicit_2008;used:paulin-mohring_extracting_1989;used:pfenning_inductively_1990;used:harper_type_1989}
},

@incollection{pfenning_inductively_1990,
	author = {Frank Pfenning and Christine {Paulin-Mohring}},
	title = {Inductively defined types in the Calculus of Constructions},
	url = {http://dx.doi.org/10.1007/BFb0040259},
	abstract = {We define the notion of an inductively defined type in the Calculus of Constructions and show how inductively defined types can be represented by closed types. We show that
all primitive recursive functionals over these inductively defined types are also representable. This generalizes work by
Bhm \& Berarducci on synthesis of functions on term algebras in the second-order polymorphic λ-calculus {(F}
2). We give several applications of this generalization, including a representation of F
2-programs in F
3, along with a definition of functions reify, reflect, and eval for F
2 in F
3. We also show how to define induction over inductively defined types and sketch some results that show that the extension
of the Calculus of Construction by induction principles does not alter the set of functions in its computational fragment,
F
ω. This is because a proof by induction can be realized by primitive recursion, which is already definable in F
ω.},
	booktitle = {Mathematical Foundations of Programming Semantics},
	year = {1990},
	pages = {209--228},
	volume = {442},
	series = {Lecture Notes in Computer Science},
	publisher = {Springer}
},

@incollection{harper_type_1989,
	author = {Robert Harper and Robert Pollack},
	title = {Type checking, universe polymorphism, and typical ambiguity in the calculus of constructions draft},
	url = {http://dx.doi.org/10.1007/3-540-50940-2_39},
	abstract = {The Generalized Calculus of Constructions {(CC)} of Coquand and Huet is a system for formalizing constructive mathematics. {CC} includes a cumulative hierarchy of universes, with each universe closed under the type forming operations. Universe hierarchies are tedious to use in practice. Russell and Whitehead introduced a convention for dealing with stratification, called typical ambiguity, in which universe levels are not explicitly mentioned, but it is tactily asserted that some correctly stratified level assignment exists. Using an operational semantics for type synthesis, we study type checking and typical ambiguity for {CC.} We show type synthesis is effective in {CC.} Even if explicit universe levels are erased from a term it is possible to compute a schematic type for that term, and a set of constraints, that characterize all types of all well-typed instances of the term. We also consider the extension with -reductions, which introduces a form of universe polymorphism induced by the failure of type unicity in {CC.}},
	booktitle = {{TAPSOFT} '89},
	year = {1989},
	pages = {241--256}
},

@misc{khanna_formal_2006,
	author = {Sanjeev Khanna and Keshav Kunal and Benjamin Pierce},
	file = {:/home/bernardy/Papers/A Formal Investigation of Diff3-2006.pdf:pdf},
	title = {A Formal Investigation of Diff3},
	url = {http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf},
	year = {2006},
	keywords = {bibtex-import, diff3, vc, vc-project},
	howpublished = {\url{http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf}},
	annote = {{{\textless}p{\textgreater}(private-note)Manuscript{\textless}/p{\textgreater}}}
},

@article{milner_logic_1972,
	author = {Robin Milner},
	file = {:/home/bernardy/Papers/Logic for Computable Functions description of a machine implementation.-1972.pdf:pdf},
	journal = {Artificial Intelligence},
	title = {{Logic for Computable Functions: description of a machine implementation.}},
	url = {http://portal.acm.org/citation.cfm?id=891954},
	year = {1972}
},

@article{giegerich_efficient_2003,
	author = {R Giegerich and S Kurtz and J Stoye},
	file = {:/home/bernardy/Papers/Efficient implementation of lazy suffix trees-2003.pdf:pdf},
	doi = {10.1002/spe.535},
	issn = {0038-0644},
	journal = {Software: Practice and Experience},
	keywords = {lazy evaluation,space-efficient implementation,string matching,suffix tree},
	month = {sep},
	number = {11},
	pages = {1035--1049},
	title = {{Efficient implementation of lazy suffix trees}},
	url = {http://doi.wiley.com/10.1002/spe.535},
	volume = {33},
	year = {2003}
},

@article{abramsky_domain_1988,
	author = {Samson Abramsky},
	file = {:/home/bernardy/Papers/Domain Theory In Logical Form-1988.pdf:pdf},
	journal = {Annals of Pure and Applied Logic},
	pages = {1--77},
	title = {{Domain Theory In Logical Form}},
	volume = {51},
	year = {1988}
},

@misc{lehman_biblatex_2010,
	author = {Philipp Lehman},
	file = {:/home/bernardy/Papers/The biblatex package-2010.pdf:pdf},
	pages = {1--200},
	title = {{The biblatex package}},
	year = {2010}
},

@misc{hinze_lhs2tex_2009,
	author = {Ralf Hinze},
	file = {:/home/bernardy/Papers/Lhs2TeX manual-2009.pdf:pdf},
	booktitle = {Sciences-New York},
	pages = {1--37},
	title = {{Lhs2TeX manual}},
	year = {2009}
},

@misc{heinz_listings_2007,
	author = {Carsten Heinz and Brooks Moses},
	file = {:/home/bernardy/Papers/The Listings Package-2007.pdf:pdf},
	pages = {1--58},
	title = {{The Listings Package}},
	year = {2007}
},

@inproceedings{scott_relating_1980,
	author = {Dana Scott},
	file = {:/home/bernardy/Papers/Relating theories of the lambda calculus-1980.pdf:pdf},
	booktitle = {Curry Festschreift: Essays in Combinatory Logic, Lambda Calculus},
	title = {{Relating theories of the lambda calculus}},
	url = {http://scholar.google.com/scholar?hl=en\&btnG=Search\&q=intitle:Relating+Theories+of+the+lambda+calculus\#0},
	year = {1980}
},

@misc{knuth_mathematical_1997,
	author = {Donald E. Knuth and Tracy Larrabee and Paul M. Roberts},
	file = {:/home/bernardy/Papers/Mathematical writing-1997.pdf:pdf},
	doi = {10.1017/S026988899722309X},
	issn = {02698889},
	month = {sep},
	number = {3},
	pages = {331--334},
	title = {{Mathematical writing}},
	url = {http://www.journals.cambridge.org/abstract\_S026988899722309X},
	volume = {12},
	year = {1997}
},

@book{tantau_beamer_2007,
	author = {Till Tantau},
	file = {:/home/bernardy/Papers/The beamer class 3.07-2007.pdf:pdf},
	pages = {1--224},
	title = {{The beamer class 3.07}},
	year = {2007}
},

@book{bertot_coqart_2010,
	author = {Yves Bertot and Pierre Cast\'{e}ran},
	file = {:/home/bernardy/Papers/Coq'Art-2010.pdf:pdf},
	title = {{Coq'Art}},
	year = {2010}
},

@book{tantau_tikz_2006,
	author = {Till Tantau},
	file = {:/home/bernardy/Papers/TikZ and pgf-2006.pdf:pdf},
	booktitle = {October},
	title = {{TikZ and pgf}},
	year = {2006}
},

@misc{abel_parametric_????,
	author = {Andreas Abel},
	file = {:/home/bernardy/Papers/On Parametric Polymorphism and Irrelevance in Martin-L"of Type Theory-????.pdf:pdf},
	title = {{On Parametric Polymorphism and Irrelevance in Martin-L\"{o}f Type Theory}},
	url = {http://www2.tcs.ifi.lmu.de/\~{}abel/implicit.pdf}
},

@inproceedings{voigtlnder_combining_2010,
	author = {Janis Voigtländer and Z Hu and K Matsuda and Meng Wang},
	file = {:/home/bernardy/Papers/Combining Syntactic and Semantic Bidirectionalization-2010.pdf:pdf},
	booktitle = {ICFP},
	keywords = {program transformation,view-update problem},
	pages = {1--12},
	title = {{Combining Syntactic and Semantic Bidirectionalization}},
	url = {http://www.iai.uni-bonn.de/\~{}jv/icfp10.pdf},
	year = {2010}
},

@article{hoste_introduction_2005,
	author = {Kenneth Hoste},
	file = {:/home/bernardy/Papers/An Introduction to Gtk2Hs, a Haskell GUI Library-2005.pdf:pdf},
	journal = {The Monad Reader},
	number = {1},
	pages = {1--15},
	title = {{An Introduction to Gtk2Hs, a Haskell GUI Library}},
	year = {2005}
},

@misc{atkey_relational_2010,
	author = {Robert Atkey},
	file = {:/home/bernardy/Papers/Relational Parametricity for Higher Kinds-2010.pdf:pdf},
	booktitle = {Identities},
	title = {{Relational Parametricity for Higher Kinds}},
	year = {2010}
},

@unpublished{seidel_proving_2010,
	author = {Daniel Seidel and Janis Voigtl\"{a}nder},
	file = {:/home/bernardy/Papers/Proving Properties About Functions on Lists Involving Element Tests-2010.pdf:pdf},
	title = {{Proving Properties About Functions on Lists Involving Element Tests}},
	year = {2010}
},

@misc{peterson_yale_2001,
	author = {John Peterson and Zhanyong Wan and Paul Hudak and Henrik Nilsson},
	file = {:/home/bernardy/Papers/The Yale FRP User's Manual-2001.pdf:pdf},
	institution = {Yale University},
	title = {{The Yale FRP User's Manual}},
	year = {2001}
},

@unpublished{abel_miniagda_2010,
	author = {Andreas Abel},
	file = {:/home/bernardy/Papers/MiniAgda Integrating Sized and Dependent Types-2010.pdf:pdf},
	booktitle = {tcs.ifi.lmu.de},
	pages = {1--15},
	title = {{MiniAgda: Integrating Sized and Dependent Types}},
	url = {http://www2.tcs.ifi.lmu.de/\~{}abel/par10.pdf},
	year = {2010}
},

@inproceedings{pfenning_intensionality_2001,
	author = {Frank Pfenning},
	file = {:/home/bernardy/Papers/Intensionality, extensionality, and proof irrelevance in modal type theory-????.pdf:pdf},
	booktitle = {Proceedings 16th Annual IEEE Symposium on Logic in Computer Science},
	doi = {10.1109/LICS.2001.932499},
	isbn = {0-7695-1281-X},
	pages = {221--230},
	publisher = {IEEE Computer Society},
	title = {Intensionality, extensionality, and proof irrelevance in modal type theory},
	year = {2001},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=932499}
},

@misc{hinze_guide2lhs2tex_2007,
	author = {Ralf Hinze and Andres L\"{o}h},
	file = {:/home/bernardy/Papers/Guide2lhs2TeX-2007.pdf:pdf},
	pages = {1--37},
	title = {{Guide2lhs2TeX}},
	year = {2007}
},

@inproceedings{fischer_play_2010,
	author = {Sebastian Fischer and Frank Huch and Thomas Wilke},
	file = {:/home/bernardy/Papers/A Play on Regular Expressions-2010.pdf:pdf},
	booktitle = {ICFP},
	publisher = {ACM},
	title = {{A Play on Regular Expressions}},
	year = {2010}
},

@misc{robertson_fontspec_2010,
	author = {Will Robertson and Khaled Hosny},
	file = {:/home/bernardy/Papers/The fontspec package-2010.pdf:pdf},
	title = {{The fontspec package}},
	year = {2010}
},

@misc{goossens_xetex_2010,
	author = {Michel Goossens},
	file = {:/home/bernardy/Papers/The XETEX Companion-2010.pdf:pdf},
	booktitle = {Writing},
	title = {{The XETEX Companion}},
	year = {2010}
},

@inproceedings{orchard_haskell_2010,
	author = {Dominic Orchard and Tom Schrijvers},
	file = {:/home/bernardy/Papers/Haskell Type Constraints Unleashed-2010.pdf:pdf},
	booktitle = {Functional and Logic Programming},
	pages = {1--19},
	title = {{Haskell Type Constraints Unleashed}},
	url = {http://www.springerlink.com/index/R87810UN65965001.pdf},
	year = {2010}
},

@book{asperti_categories_1991,
	author = {Andrea Asperti and  {Giuseppe Longo}},
	file = {:/home/bernardy/Papers/Categories, types and structure-1991.pdf:pdf},
	booktitle = {Computing},
	publisher = {MIT Press},
	title = {{Categories, types and structure}},
	year = {1991}
},

@article{plotkin_call-by-name_1975,
	author = {Gordon D. Plotkin},
	file = {:/home/bernardy/Papers/Call-by-name, call-by-value and the lamdba calculus-1975.pdf:pdf},
	journal = {Theoretical Computer Science},
	number = {2},
	pages = {125--129},
	title = {Call-by-name, call-by-value and the λ-calculus},
	volume = {1},
	year = {1975}
},

@article{altenkirch_generic_????,
	author = {Thorsten Altenkirch and Conor Mcbride and Peter Morris},
	file = {:/home/bernardy/Papers/Generic Programming with Dependent Types-????.pdf:pdf},
	title = {{Generic Programming with Dependent Types}}
},

@article{abel_modular_2009,
	author = {Andreas Abel and Thierry Coquand and Miguel Pagano},
	file = {:/home/bernardy/Papers/A modular type-checking algorithm for type theory with singleton types and proof irrelevance-2009.pdf:pdf},
	doi = {10.1007/978-3-642-02273-9_3},
	journal = {Logical Methods in Computer Science},
	keywords = {normalisation-by-evaluation,proof,singleton types,type theory,type-checking},
	pages = {1--51},
	title = {{A modular type-checking algorithm for type theory with singleton types and proof irrelevance}},
	year = {2009}
},

@book{greenberg_simplified_2006,
	author = {Harvey J. Greenberg},
	file = {:/home/bernardy/Papers/A Simplified Introduction to LaTeX-2006.pdf:pdf},
	title = {{A Simplified Introduction to LaTeX}},
	year = {2006}
},

@inproceedings{hurkens_simplification_1995,
	author = {Antonius J. C. Hurkens},
	file = {:/home/bernardy/Papers/A simplification of Girard's paradox-1995.pdf:pdf},
	booktitle = {Typed Lambda Calculi and Applications},
	pages = {266--278},
	publisher = {Springer},
	title = {{A simplification of Girard's paradox}},
	url = {http://www.springerlink.com/index/w718604jn467672h.pdf},
	year = {1995}
},

@misc{peyton_jones_write_2004,
	author = {Simon {Peyton Jones}},
	file = {:/home/bernardy/Papers/How to Write a Great Research Paper-2004.pdf:pdf},
	number = {2},
	pages = {844--138},
	title = {{How to Write a Great Research Paper}},
	volume = {8},
	year = {2004}
},

@inbook{girard_blind_2004,
	author = {Jean-Yves Girard},
	file = {:/home/bernardy/Papers/The blind spot-2004.pdf:pdf},
	chapter = {Part III -},
	pages = {182--272},
	title = {{The blind spot}},
	url = {http://iml.univ-mrs.fr/\~{}girard/coursang/coursang0.pdf.gz},
	year = {2004}
},

@inbook{girard_point_2004,
	author = {Jean-Yves Girard},
	file = {:/home/bernardy/Papers/Le point aveugle-2004.pdf:pdf},
	chapter = {1-2},
	doi = {10.3917/top.084.0201},
	issn = {0040-9375},
	number = {3},
	pages = {201},
	title = {{Le point aveugle}},
	url = {http://www.cairn.info/revue-topique-2003-3-page-201.htm},
	volume = {84},
	year = {2004}
},

@inproceedings{kreisel_interpretation_1959,
	author = {Georg Kreisel},
	title = {Interpretation of analysis by means of constructive functionals of finite types},
	booktitle = {Constructivity in mathematics},
	editor = {A. Heyting},
	pages = {101--128},
	year = {1959},
	address = {North-Holland, Amsterdam}
},

@phdthesis{paulin-mohring_extraction_1989,
	author = {Christine Paulin-Mohring},
	file = {:/home/bernardy/Papers/Extraction de programmes dans le Calcul des Constructions-1989.ps:ps},
	title = {{Extraction de programmes dans le Calcul des Constructions}},
	year = {1989},
	school = {Université Paris 7}
},

@article{krivine_programming_1990,
	author = {Jean-Louis Krivine and Michel Parigot},
	title = {Programming with proofs},
	journal = {Journal of Information Processing and Cybernetics},
	volume = {26},
	number = {3},
	year = {1990},
	issn = {0863-0593},
	pages = {149--167},
	publisher = {Akademie-Verlag GmbH},
	address = {Berlin, Germany, Germany}
},

@conference{leivant_contracting_1990,
	author = {Daniel Leivant},
	title = {{Contracting proofs to programs}},
	booktitle = {Logic and Computer Science},
	pages = {279--327},
	year = {1990}
},

@article{staples_combinator_1973,
	author = {John Staples},
	title = {Combinator realizability of constructive finite type analysis},
	journal = {Cambridge Summer School in Mathematical Logic},
	pages = {253--273},
	year = {1973},
	publisher = {Springer}
},

@article{van_oosten_realizability_2002,
	author = {Jaap {Van Oosten}},
	title = {{Realizability: a historical essay}},
	journal = {Mathematical Structures in Computer Science},
	volume = {12},
	number = {03},
	pages = {239--263},
	year = {2002},
	publisher = {Cambridge Univ Press}
},

@InBook{troelstra_handbook_1998,
	author = {Anne Sjerp Troelstra},
	editor = {Samuel R. Buss},
	title = {Handbook of proof theory},
	chapter = {Realizability},
	publisher = {Elsevier},
	year = {1998}
},

@book{buss_handbook_1998,
	author = {Samuel R. Buss},
	title = {Handbook of proof theory},
	year = {1998},
	publisher = {Elsevier},
	see = {chapter:troelstra_handbook_1998}
},

@article{harrop_disjunctions_1956,
	author = {Ronald Harrop},
	title = {{On disjunctions and existential statements in intuitionistic systems of logic}},
	journal = {Mathematische Annalen},
	volume = {132},
	number = {4},
	pages = {347--361},
	year = {1956},
	publisher = {Springer}
},

@book{kleene_introduction_1971,
	author = {Stephen Cole Kleene},
	title = {{Introduction to metamathematics}},
	year = {1971},
	publisher = {Wolters-Noordhoff}
},

@article{kleene_interpretation_1945,
	author = {Stephen Cole Kleene},
	title = {On the interpretation of intuitionistic number theory},
	journal = {Journal of Symbolic Logic},
	volume = {10},
	number = {4},
	pages = {109--124},
	year = {1945},
	publisher = {Association for Symbolic Logic}
},

@article{abel_normalization_2007,
	author = {Andreas Abel and Klaus Aehlig and Peter Dybjer},
	file = {:/home/bernardy/Papers/Normalization by Evaluation for Martin-Löf Type Theory with One Universe-2007.pdf:pdf},
	title = {Normalization by Evaluation for {Martin-Löf} Type Theory with One Universe},
	journal = {Electronic Notes Theoretical Computer Science},
	volume = {173},
	year = {2007},
	issn = {1571-0661},
	pages = {17--39},
	doi = {http://dx.doi.org/10.1016/j.entcs.2007.02.025},
	publisher = {Elsevier Science Publishers B. V.},
	address = {Amsterdam, The Netherlands, The Netherlands}
},

@article{cohen_views_2010,
	author = {Julien Cohen and Rémi Douence},
	file = {:/home/bernardy/Papers/Views, Program Transformations, and the Evolutivity Problem-2010.pdf:pdf},
	title = {Views, Program Transformations, and the Evolutivity Problem},
	journal = {CoRR},
	volume = {abs/1005.1213},
	year = {2010},
	ee = {http://arxiv.org/abs/1005.1213},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@inproceedings{honsell_pre-logical_2009,
	author = {F. Honsell and D. Sannella},
	file = {:/home/bernardy/Papers/Pre-logical relations-2009.pdf:pdf},
	title = {Pre-logical relations},
	booktitle = {Computer Science Logic},
	pages = {826--826},
	year = {2009},
	series = {Lecture Notes in Computer Science},
	volume = {1683},
	doi = {10.1007/3-540-48168-0},
	publisher = {Springer}
},

@inproceedings{mitchell_deriving_2007,
	author = {Neil Mitchell},
	title = {Deriving Generic Functions by Example},
	year = {2007},
	month = {October},
	day = {26},
	pages = {55--62},
	publisher = {Tech. Report {YCS-2007-421}, Dept. of Computer Science, University of {York}, {UK}},
	editor = {Jan Tobias Mühlberg and Juan Ignacio Perna},
	booktitle = {Proceedings of the First York Doctoral Syposium 2007},
	url = {http://community.haskell.org/~ndm/downloads/paper-deriving_generic_functions_by_example-26_oct_2007.pdf}
},

@article{birkedal_realizability_2009,
	author = {Lars Birkedal and K. Støvring and J. Thamsborg},
	title = {Realizability semantics of parametric polymorphism, general references, and recursive types},
	journal = {Foundations of Software Science and Computational Structures},
	pages = {456--470},
	year = {2009},
	publisher = {Springer}
},

@conference{coquand_pattern_1992,
	author = {Thierry Coquand},
	title = {Pattern Matching with Dependent Types},
	booktitle = {Proceedings of the Workshop on Types for Proofs and Programs},
	pages = {66--79},
	year = {1992}
},

@article{hughes_functional_1989,
	author = {J Hughes},
	file = {:/home/bernardy/Papers/Why Functional Programming Matters-1989.pdf:pdf},
	title = {Why Functional Programming Matters},
	volume = {32},
	url = {http://citeseer.ist.psu.edu/hughes84why.html},
	abstract = {As software becomes more and more complex, it is more and more important to structure it well. Well-structured software is easy to write, easy to debug, and provides a collection of modules that can be re-used to reduce future programming costs. Conventional languages place conceptual limits on the way problems can be modularised. Functional languages push those limits back. In this paper we show that two features of functional languages in particular, higher-order functions and lazy...},
	number = {2},
	journal = {Computer Journal},
	year = {1989},
	keywords = {haskell},
	pages = {98--107}
},

@inproceedings{sulzmann_modular_2006,
	author = {Martin Sulzmann and Meng Wang},
	title = {Modular generic programming with extensible superclasses},
	isbn = {1595934926},
	url = {http://dx.doi.org/10.1145/1159861.1159869},
	booktitle = {{WGP} '06: Proceedings of the 2006 {ACM} {SIGPLAN} workshop on Generic programming},
	publisher = {{ACM}},
	year = {2006},
	keywords = {open, typeclass},
	pages = {55--65}
},

@article{hudson_incremental_1991,
	author = {Scott Hudson},
	file = {:/home/bernardy/Papers/Incremental attribute evaluation a flexible algorithm for lazy update-1991.pdf:pdf},
	title = {Incremental attribute evaluation: a flexible algorithm for lazy update},
	volume = {13},
	issn = {0164-0925},
	url = {http://dx.doi.org/10.1145/117009.117012},
	number = {3},
	journal = {{ACM} Trans. Program. Lang. Syst.},
	month = {jul},
	year = {1991},
	keywords = {lazy},
	pages = {315--341}
},

@article{claessen_parallel_2004,
	author = {Koen Claessen},
	file = {:/home/bernardy/Papers/Parallel Parsing Processes-2004.ps:ps},
	title = {Parallel Parsing Processes},
	volume = {14},
	number = {6},
	journal = {Journal of Functional Programming},
	year = {2004},
	pages = {741--757}
},

@misc{gregor_conceptgcc_2008,
	author = {Douglas Gregor},
	title = {{Concept{GCC}} --- a prototype compiler for {{\textbackslash}{\textbackslash}Cpp{}} concepts},
	year = {2008},
	keywords = {sibylle, wgp08}
},

@book{barr_category_1999,
	author = {Michael Barr and Charles Wells},
	edition = {third},
	title = {Category Theory for Computing Science},
	isbn = {0133238091},
	publisher = {Prentice Hall},
	year = {1999}
},

@phdthesis{girard_interprtation_1972,
	author = {Jean-Yves Girard},
	type = {Thèse d'état},
	title = {Interprétation fonctionnelle et elimination des coupures de l'arithmétique d'ordre supérieur},
	school = {Université de Paris 7},
	year = {1972}
},

@article{parker_detection_1983,
	author = {{DS} Parker and {GJ} Popek and G Rudisin and A Stoughton and {BJ} Walker and E Walton and {JM} Chow and D Edwards and S Kiser and C Kline},
	title = {Detection of Mutual Inconsistency in Distributed Systems},
	volume = {{SE-9}},
	url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1703051},
	abstract = {Many distributed systems are now being developed to provide users with convenient access to data via some kind of communications network. In many cases it is desirable to keep the system functioning even when it is partitioned by network failures. A serious problem in this context is how one can support redundant copies of resources such as files (for the sake of reliability) while simultaneously monitoring their mutual consistency (the equality of multiple copies). This is difficult since network faiures can lead to inconsistency, and disrupt attempts at maintaining consistency. In fact, even the detection of inconsistent copies is a nontrivial problem. Naive methods either 1) compare the multiple copies entirely or 2) perform simple tests which will diagnose some consistent copies as inconsistent. Here a new approach, involving version vectors and origin points, is presented and shown to detect single file, multiple copy mutual inconsistency effectively. The approach has been used in the design of {LOCUS,} a local network operating system at {UCLA.}},
	number = {3},
	journal = {Software Engineering, {IEEE} Transactions on},
	year = {1983},
	keywords = {vc},
	pages = {240--247}
},

@misc{ferriss_scientific_????,
	author = {Tim Ferriss},
	title = {Scientific Speed Reading: How to Read 300\% Faster in 20 Minutes},
	url = {http://www.fourhourworkweek.com/blog/2009/07/30/speed-reading-and-accelerated-learning/},
	howpublished = {\url{http://www.fourhourworkweek.com/blog/2009/07/30/speed-reading-and-accelerated-learning/}}
},

@article{hinze_generics_2004,
	author = {Ralf Hinze},
	title = {Generics for the masses},
	volume = {39},
	url = {http://portal.acm.org/citation.cfm?id=1016882},
	doi = {10.1145/1016848.1016882},
	abstract = {A generic function is a function that can be instantiated on many data types to obtain data type specific functionality. Examples of generic functions are the functions that can be derived in Haskell, such as show, read, and '=='. The recent years have seen a number of proposals that support the definition of generic functions. Some of the proposals define new languages, some define extensions to existing languages. As a common characteristic none of the proposals can be made to work within Haskell 98: they all require something extra, either a more sophisticated type system or an additional language construct. The purpose of this pearl is to show that one can, in fact, program generically within Haskell 98 obviating to some extent the need for fancy type systems or separate tools. Haskell's type classes are at the heart of this approach: they ensure that generic functions can be defined succinctly and, in particular, that they can be used painlessly.},
	number = {9},
	journal = {{SIGPLAN} Not.},
	year = {2004},
	keywords = {generic programming, haskell 98, type classes},
	pages = {236--243}
},

@inproceedings{magnusson_fine-grained_1993,
	author = {Boris Magnusson and Ulf Asklund and Sten Min{\textbackslash}"{or}},
	title = {{Fine-Grained} Revision Control for Collaborative Software Development},
	url = {http://citeseer.ist.psu.edu/magnusson93finegrained.html},
	abstract = {This paper presents a framework for controlling the evolution of complex software systems concurrently developed by teams of software engineers. A general technique for fine-grained revision control of hierarchically structured information, such as programs and documents, is described and evaluated. All levels in the hierarchy are revision controlled, leaves as well as branch nodes. The technique supports sharing of unchanged nodes among revisions, automatic change propagation, and...},
	booktitle = {Proceedings of {ACM} {{SIGSOFT}} '93: Symposium on Foundations of Software Engineering},
	year = {1993},
	keywords = {vc},
	pages = {21--30}
},

@inproceedings{lh_open_2006,
	author = {Andres Löh and Ralf Hinze},
	address = {Venice, Italy},
	title = {Open data types and open functions},
	isbn = {1-59593-388-3},
	url = {http://portal.acm.org/citation.cfm?id=1140352},
	doi = {10.1145/1140335.1140352},
	abstract = {The problem of supporting the modular extensibility of both data and functions in one programming language at the same time is known as the expression problem. Functional languages traditionally make it easy to add new functions, but extending data (adding new data constructors) requires modifying existing code. We present a semantically and syntactically lightweight variant of open data types and open functions as a solution to the expression problem in the Haskell language. Constructors of open data types and equations of open functions may appear scattered throughout a program with several modules. The intended semantics is as follows: the program should behave as if the data types and functions were closed, defined in one place. The order of function equations is determined by best-fit pattern matching, where a specific pattern takes precedence over an unspecific one. We show that our solution is applicable to the expression problem, generic programming, and exceptions. We sketch two implementations: a direct implementation of the semantics, and a scheme based on mutually recursive modules that permits separate compilation},
	booktitle = {Proceedings of the 8th {ACM} {SIGPLAN} international conference on Principles and practice of declarative programming},
	publisher = {{ACM}},
	year = {2006},
	keywords = {expression problem, extensible data types, extensible exceptions, extensible functions, functional programming, generic programming, mutually recursive modules, open},
	pages = {133--144}
},

@misc{danvy_three_1991,
	author = {O Danvy},
	title = {Three steps for the {CPS} transformation},
	url = {http://citeseer.ist.psu.edu/294520.html},
	abstract = {Transforming a \#-term into continuation-passing style {(CPS)} might seem mystical at first, but in fact it can be characterized by three separate aspects: . The values of all intermediate applications are given a name. . The evaluation of these applications is sequentialized based on a traversal of their syntax tree. This traversal mimics the reduction strategy. . The resulting term is equipped with a continuation --- a \#-abstraction whose application to intermediate values yields the final ...},
	year = {1991},
	keywords = {cps}
},

@misc{wikipedia_contributors_software_2009,
	author = { {{Wikipedia} contributors}},
	title = {Software engineering},
	url = {http://en.wikipedia.org/w/index.php?title=Software_engineering&oldid=313559997},
	journal = {Wikipedia, The Free Encyclopedia},
	publisher = {Wikimedia Foundation},
	month = {sep},
	year = {2009}
},

@article{mcbride_view_2004,
	author = {Conor {McBride} and James {McKinna}},
	title = {The view from the left},
	volume = {14},
	number = {01},
	journal = {Journal of Functional Programming},
	year = {2004},
	pages = {69–111}
},

@incollection{paulin-mohring_inductive_1993,
	author = {Christine {Paulin-Mohring}},
	file = {:/home/bernardy/Papers/Inductive definitions in the system Coq -- rules and properties-1993.pdf:pdf},
	title = {Inductive definitions in the system {Coq} -- rules and properties},
	url = {http://dx.doi.org/10.1007/BFb0037116},
	abstract = {In the pure Calculus of Constructions, it is possible to represent data structures and predicates using higher-order quantification. However, this representation is not satisfactory, from the point of view of both the efficiency of the underlying programs and the power of the logical system. For these reasons, the calculus was extended with a primitive notion of inductive definitions [8]. This paper describes the rules for inductive definitions in the system Coq. They are general enough to be seen as one formulation of adding inductive definitions to a typed lambda-calculus. We prove strong normalization for a subsystem of Coq corresponding to the pure Calculus of Constructions plus Inductive Definitions with only weak eliminations.},
	booktitle = {Typed Lambda Calculi and Applications},
	editor = {Marc Bezem and Jan Friso Groote},
	publisher = {Springer},
	year = {1993},
	pages = {328--345}
},

@inproceedings{bagge_axiom-based_2008,
	author = {Anya Helene Bagge and Valentin David and Magne Haveraaen},
	address = {Nashville, {TN,} {USA}},
	title = {Axiom-based testing for {{C++}}},
	isbn = {978-1-60558-220-7},
	url = {http://portal.acm.org/citation.cfm?id=1449814.1449829},
	doi = {10.1145/1449814.1449829},
	abstract = {Axioms, known from program specification, allow program functionality to be described as rules or equations. The draft C++0x standard introduces axioms as part of the new concept feature. We will demonstrate a tool that uses these features for automated unit testing.},
	booktitle = {Companion to the 23rd {ACM} {SIGPLAN} conference on Object-oriented programming systems languages and applications},
	publisher = {{ACM}},
	year = {2008},
	keywords = {axioms, c++, c++0x, concepts, generative programming, mouldable programming, program transformation, specifications, test generation, unit testing},
	pages = {721--722}
},

@misc{hicks_adapting_2008,
	author = {Michael Hicks and Jeffrey S. Foster},
	file = {:/home/bernardy/Papers/Adapting Scrum to Managing a Research Group-2008.pdf:pdf},
	title = {Adapting Scrum to Managing a Research Group},
	year = {2008},
	url = {http://www.cs.umd.edu/~mwh/papers/scram.pdf}
},

@incollection{hughes_quickcheck_2007,
	author = {John Hughes},
	title = {{QuickCheck} Testing for Fun and Profit},
	url = {http://dx.doi.org/10.1007/978-3-540-69611-7_1},
	abstract = {One of the nice things about purely functional languages is that functions often satisfy simple properties, and enjoy simple
algebraic relationships. Indeed, if the functions of an {API} satisfy elegant laws, that in itself is a sign of a good design—the
laws not only indicate conceptual simplicity, but are useful in practice for simplifying programs that use the {API,} by equational
reasoning or otherwise.},
	booktitle = {Practical Aspects of Declarative Languages},
	publisher = {Springer},
	year = {2007},
	pages = {1--32}
},

@techreport{gregor_concepts_2006,
	author = {D Gregor},
	title = {Concepts for the {C++0x} Standard Library: Containers},
	year = {2006},
	keywords = {sibylle, wgp08}
},

@inproceedings{carlsson_monads_2002,
	author = {Magnus Carlsson},
	address = {Pittsburgh, {PA,} {USA}},
	title = {Monads for incremental computing},
	isbn = {1-58113-487-8},
	url = {http://portal.acm.org/citation.cfm?id=581482},
	doi = {10.1145/581478.581482},
	abstract = {This paper presents a monadic approach to incremental computation, suitable for purely functional languages such as Haskell. A program that uses incremental computation is able to perform an incremental amount of computation to accommodate for changes in input data. Recently, Acar, Blelloch and Harper presented a small Standard {ML} library that supports efficient, high-level incremental computations [1]. Here, we present a monadic variant of that library, written in Haskell extended with first-class references. By using monads, not only are we able to provide a purely functional interface to the library, the types also enforce "correct usage" without having to resort to any type-system extension. We also find optimization opportunities based on standard monadic {combinators.This} is an exercise in putting to work monad transformers with environments, references, and continuations.},
	booktitle = {Proceedings of the seventh {ACM} {SIGPLAN} international conference on Functional Programming},
	publisher = {{ACM}},
	year = {2002},
	pages = {26--35}
},

@article{swaine_time_2008,
	author = {Michael Swaine},
	title = {It's Time to Get Good at Functional Programming},
	issn = {{1044-789X}},
	url = {http://www.ddj.com/development-tools/212201710},
	journal = {Dr. Dobb's},
	month = {dec},
	year = {2008}
},

@unpublished{smith_galois_????,
	author = {Peter Smith},
	title = {The Galois Connection between syntax and semantics}
},

@inproceedings{dart_concepts_1991,
	author = {Susan Dart and Peter Feiler},
	title = {Concepts in Configuration Management Systems},
	url = {http://citeseer.ist.psu.edu/dart90concepts.html},
	abstract = {: There has been considerable progress con- 1.1 Definition of Configuration Management cerning support for software configuration management Software {CM} is a discipline for controlling the evolution {(CM)} in environments and tools. This paper's intent is to of software systems. Classic discussions about {CM} are highlight the user concepts provided by existing {CM} sys- given in texts such as [3] and [4]. A standard definition tems. These are shown as a spectrum. In the spectrum, taken from {IEEE...}},
	booktitle = {Proceedings of the 3rd International Workshop on Software Configuration Management},
	year = {1991},
	keywords = {vc},
	pages = {1--18}
},

@inproceedings{johann_initial_2007,
	author = {Patricia Johann and Neil Ghani},
	series = {Lecture Notes in Computer Science},
	title = {Initial Algebra Semantics Is Enough!},
	volume = {4583},
	url = {http://dx.doi.org/10.1007/978-3-540-73228-0_16},
	abstract = {Initial algebra semantics is a cornerstone of the theory of modern functional programming languages. For each inductive data
type, it provides a fold combinator encapsulating structured recursion over data of that type, a Church encoding, a build combinator which constructs data of that type, and a fold/build rule which optimises modular programs by eliminating intermediate data of that type. It has long been thought that initial
algebra semantics is not expressive enough to provide a similar foundation for programming with nested types. Specifically,
the folds have been considered too weak to capture commonly occurring patterns of recursion, and no Church encodings, build combinators, or fold/build rules have been given for nested types. This paper overturns this conventional wisdom by solving all of these problems.},
	booktitle = {Typed Lambda Calculi and Applications},
	publisher = {Springer},
	year = {2007},
	pages = {207--222}
},

@article{okasaki_call-by-need_1994,
	author = {Chris Okasaki and Peter Lee and David Tarditi},
	title = {Call-by-need and continuation-passing style},
	volume = {7},
	url = {http://dx.doi.org/10.1007/BF01019945},
	doi = {10.1007/BF01019945},
	abstract = {This paper examines the transformation of call-by-need ? terms into continuation-passing style {(CPS).} It begins by presenting a simple transformation of call-by-need ? terms into program graphs and a reducer for such graphs. From this, an informal derivation is carried out, resulting in a translation from ? terms into self-reducing program graphs, where the graphs are represented as {CPS} terms involving storage operations. Though informal, the derivation proceeds in simple steps, and the resulting translation is taken to be our canonical {CPS} transformation for call-by-need ? terms.},
	number = {1},
	journal = {{LISP} and Symbolic Computation},
	month = {jan},
	year = {1994},
	pages = {57--81}
},

@inproceedings{hughes_polish_2003,
	author = {R. John M. Hughes and S. Doaitse Swierstra},
	file = {:/home/bernardy/Papers/Polish parsers, step by step-2003.pdf:pdf},
	address = {Uppsala, Sweden},
	title = {Polish parsers, step by step},
	isbn = {1-58113-756-7},
	url = {http://portal.acm.org/citation.cfm?id=944705.944727},
	doi = {10.1145/944705.944727},
	abstract = {We present the derivation of a space efficient parser combinator library: the constructed parsers do not keep unnecessary references to the input, produce online results and efficiently handle ambiguous grammars. The underlying techniques can be applied in many contexts where traditionally backtracking is {used.We} present two data types, one for keeping track of the progress of the search process, and one for representing the final result in a linear way. Once these data types are combined into a single type, we can perform a breadth-first search, while returning parts of the result as early as possible.},
	booktitle = {Proceedings of the eighth {ACM} {SIGPLAN} international conference on Functional Programming},
	publisher = {{ACM}},
	year = {2003},
	keywords = {ambiguous grammars, breadth-first search, glr parsing, online results, parser combinators, polish representation},
	pages = {239--248}
},

@misc{asklund_identifying_1994,
	author = {U Asklund},
	title = {Identifying conflicts during structural merge},
	url = {http://citeseer.ist.psu.edu/asklund94identifying.html},
	abstract = {. This paper presents a model for controlling the evolution of documents concurrently developed by teams of authors. Optimistic check-out of revisions and alternatives, and hierarchic merge making use of default rules is presented. In particular the different situations occurring during a merge of parallel development lines and the benefit of storing the full evolution history is discussed. 1 Introduction To cooperate have always been hard. Now when the cooperating persons may be spread all...},
	year = {1994},
	keywords = {vc},
	annote = {{\textless}p{\textgreater}older version of other paper by Asklund{\textless}/p{\textgreater}}
},

@inproceedings{oury_power_2008,
	author = {Nicolas Oury and Wouter Swierstra},
	file = {:/home/bernardy/Papers/The power of Pi-2008.pdf:pdf},
	address = {Victoria, {BC}, Canada},
	title = {The power of {Pi}},
	isbn = {978-1-59593-919-7},
	url = {http://portal.acm.org/citation.cfm?id=1411204.1411213},
	doi = {10.1145/1411204.1411213},
	abstract = {This paper exhibits the power of programming with dependent types by dint of embedding three domain-specific languages: Cryptol, a language for cryptographic protocols; a small data description language; and relational algebra. Each example demonstrates particular design patterns inherent to dependently-typed programming. Documenting these techniques paves the way for further research in domain-specific embedded type systems.},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} international conference on Functional Programming},
	publisher = {{ACM}},
	year = {2008},
	keywords = {dependent types, domain-specific embedded languages},
	pages = {39--50}
},

@inproceedings{wadler_ad-hoc_1989,
	author = {Philip Wadler and Stephen Blott},
	title = {How to make ad-hoc polymorphism less ad hoc},
	isbn = {0897912942},
	doi = {10.1145/75277.75283},
	booktitle = {{POPL} '89: Proceedings of the 16th {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	year = {1989},
	keywords = {typeclass},
	pages = {60--76}
},

@inproceedings{gill_short_1993,
	author = {Andrew Gill and John Launchbury and Simon {Peyton Jones}},
	file = {:/home/bernardy/Papers/A short cut to deforestation-1993.pdf:pdf},
	address = {Copenhagen, Denmark},
	title = {A short cut to deforestation},
	isbn = {{0-89791-595-X}},
	url = {http://portal.acm.org/citation.cfm?id=165180.165214},
	doi = {10.1145/165180.165214},
	abstract = {Note: {OCR} errors may be found in this Reference List extracted from the full text article. {ACM} has opted to expose the complete List rather than only correct and linked references.},
	booktitle = {Proceedings of the conference on Functional programming languages and computer architecture},
	publisher = {{ACM}},
	year = {1993},
	pages = {223--232}
},

@inproceedings{rountev_off-line_2000,
	author = {Atanas Rountev and Satish Chandra},
	title = {Off-line variable substitution for scaling points-to analysis},
	booktitle = {{PLDI} '00: Proceedings of the {ACM} {SIGPLAN} 2000 conference on Programming language design and implementation},
	publisher = {{ACM}},
	year = {2000},
	keywords = {points-to},
	pages = {47--56}
},

@article{jones_dictionary-free_1994,
	author = {Mark P. Jones},
	title = {{Dictionary-Free} Overloading by Partial Evaluation},
	volume = {8},
	url = {http://dx.doi.org/10.1007/BF01019005},
	number = {3},
	journal = {{LISP} and Symbolic Computation},
	year = {1994},
	keywords = {sibylle, typeclass, wgp08},
	pages = {229--248}
},

@article{mckinna_type-correct_2006,
	author = {James Mckinna and Joel Wright},
	title = {A type-correct, stack-safe, provably correct, expression compiler},
	url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.105.4086},
	doi = {10.1.1.105.4086},
	journal = {in Epigram. Submitted to the Journal of Functional Programming},
	year = {2006}
},

@misc{glynn_type_2000,
	author = {K Glynn and P Stuckey and M Sulzmann},
	title = {Type classes and constraint handling rules},
	url = {http://citeseer.ist.psu.edu/334241.html},
	abstract = {Type classes give a clean approach to dene overloading in programming languages such as Haskell. Haskell 98 supports only single-parameter and constructor type classes. Other extensions such as multi-parameter type classes are highly desired but are still not ocially supported in Haskell 98. Subtle issues arise which possibly might lead to a loss of feasible type inference and ambiguous programs. A proper logical fundament for type class systems seems to be missing where such issues can...},
	year = {2000},
	keywords = {typeclass}
},

@inproceedings{kiselyov_strongly_2004,
	author = {Oleg Kiselyov and Ralf Lämmel and Keean Schupke},
	title = {Strongly typed heterogeneous collections},
	url = {http://dx.doi.org/http://doi.acm.org/10.1145/1017472.1017488},
	booktitle = {Haskell '04: Proceedings of the {ACM} {SIGPLAN} workshop on Haskell},
	publisher = {{ACM} Press},
	year = {2004},
	keywords = {hlist},
	pages = {96--107}
},

@inproceedings{hunt_distributed_1997,
	author = {James Hunt and Frank Lamers and Jurgen Reuter and Walter Tichy},
	title = {Distributed Configuration Management via Java and the World Wide Web},
	url = {http://citeseer.ist.psu.edu/hunt97distributed.html},
	abstract = {. The introduction of Java has been heralded as a revolution in network computing. Certainly, machine and operating system independent applets flittering through the Internet promised to jazz up web surfing; but could they be used to advantage for distributed computing ? The authors had encountered substantial problems in implementing a distributed revision control system, called {WWRC,} based on passive Web browsers. Java seemed to offer solutions to these problems. To this end, the...},
	booktitle = {System Configuration Management},
	year = {1997},
	keywords = {vc},
	pages = {161--174}
},

@article{cardelli_understanding_1985,
	author = {Luca Cardelli and Peter Wegner},
	file = {:/home/bernardy/Papers/On understanding types, data abstraction, and polymorphism-1985.pdf:pdf},
	title = {On understanding types, data abstraction, and polymorphism},
	volume = {17},
	issn = {0360-0300},
	doi = {10.1145/6041.6042},
	number = {4},
	journal = {{ACM} Computing Surveys},
	month = {12},
	year = {1985},
	pages = {471--523}
},

@inproceedings{svenningsson_shortcut_2002,
	author = {Josef Svenningsson},
	address = {Pittsburg {PA,} {USA}},
	title = {Shortcut fusion for accumulating parameters \& zip-like functions},
	url = {http://portal.acm.org/citation.cfm?id=581491},
	doi = {10.1145/583852.581491},
	abstract = {We present an alternative approach to shortcut fusion based on the function unfoldr,. Despite its simplicity the technique can remove intermediate lists in examples which are known to be difficult. We show that it can remove all lists from definitions involving zip-like functions and functions using accumulating parameters.},
	booktitle = {Proceedings of the seventh {ACM} {SIGPLAN} international conference on Functional Programming},
	publisher = {{ACM}},
	year = {2002},
	keywords = {deforestation, functional programming, intermediate data structures, optimisation, program transformation},
	pages = {124--132}
},

@inproceedings{monnier_singleton_2010,
	author = {Stefan Monnier and David Haguenauer},
	file = {:/home/bernardy/Papers/Singleton types here, singleton types there, singleton types everywhere-2010.pdf:pdf},
	address = {Madrid, Spain},
	title = {Singleton types here, singleton types there, singleton types everywhere},
	isbn = {978-1-60558-890-2},
	url = {http://portal.acm.org/citation.cfm?id=1707790.1707792},
	doi = {10.1145/1707790.1707792},
	abstract = {Singleton types are often considered a poor man's substitute for dependent types. But their generalization in the form of {GADTs} has found quite a following. The main advantage of singleton types and {GADTs} is to preserve the so-called phase distinction, which seems to be so important to make use of the usual compilation techniques.},
	booktitle = {Proceedings of the 4th {ACM} {SIGPLAN} workshop on Programming languages meets program verification},
	publisher = {{ACM}},
	year = {2010},
	keywords = {certified compilation, dependent types, singleton types},
	pages = {1--8},
	annote = {{{\textless}p{\textgreater}Figure} 7 is Reynolds embedding.{\textless}/p{\textgreater}}
},

@inproceedings{sulzmann_system_2007,
	author = {Martin Sulzmann and Manuel Chakravarty and Simon {Peyton Jones} and Kevin Donnelly},
	title = {System F with type equality coercions},
	isbn = {{159593393X}},
	url = {http://dx.doi.org/10.1145/1190315.1190324},
	booktitle = {{TLDI} '07: Proceedings of the 2007 {ACM} {SIGPLAN} international workshop on Types in languages design and implementation},
	publisher = {{ACM}},
	year = {2007},
	keywords = {typeclass},
	pages = {53--66}
},

@article{dybjer_inductive_1994,
	author = {Peter Dybjer},
	title = {Inductive families},
	volume = {6},
	url = {http://dx.doi.org/10.1007/BF01211308},
	doi = {10.1007/BF01211308},
	abstract = {A general formulation of inductive and recursive definitions in {Martin-Löf's} type theory is presented. It extends Backhouse's {‘Do-It-Yourself} Type Theory’ to include inductive definitions of families of sets and definitions of functions by recursion on the way elements of such sets are generated. The formulation is in natural deduction and is intended to be a natural generalisation to type theory of {Martin-Löf's} theory of iterated inductive definitions in predicate logic.},
	number = {4},
	journal = {Formal Aspects of Computing},
	month = {jul},
	year = {1994},
	pages = {440--465}
},

@incollection{glck_derivation_2004,
	author = {Robert Glück and Masahiko Kawabe},
	title = {Derivation of Deterministic Inverse Programs Based on {LR} Parsing},
	url = {http://www.springerlink.com/content/tfaxx9x8mxukcreb},
	abstract = {We present a method for automatic program inversion of functional programs based on methods of {LR} parsing. We formalize the transformation and illustrate it with the inversion of a program for run-length encoding. We solve one of the main problems of automatic program inversionâthe elimination of nondeterminismâby viewing an inverse program as a context-free grammar and applying to it methods of {LR} parsing to turn it into a recursive, deterministic inverse program. This improves the efficiency of the inverse programs and greatly expands the application range of our earlier method for program inversion.},
	booktitle = {Functional and Logic Programming},
	year = {2004},
	keywords = {aop},
	pages = {291--306}
},

@inproceedings{niu_category-theoretic_2005,
	author = {N Niu and S Easterbrook and M Sabetzadeh},
	title = {A category-theoretic approach to syntactic software merging},
	url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1510116},
	abstract = {Software merging is a common and essential activity during the lifespan of large-scale software systems. Traditional textual merge techniques are inadequate for detecting syntactic merge conflicts. In this paper, we propose a domain-independent approach for syntactic software merging that exploits the graph-based structure(s) of programs. We use morphisms between fuzzy graphs to capture the relationships between the structural elements of the programs to be merged, and apply a truth ordering lattice to express inconsistencies and evolutionary properties as we compute the merge. We demonstrate the approach with a three-way consolidation merge in a commercial software system; in particular, we show how analyzing merged call structures can help developers gain a better understanding and control of software evolution.},
	booktitle = {Software Maintenance, 2005. {ICSM'05.} Proceedings of the 21st {IEEE} International Conference on},
	year = {2005},
	keywords = {vc},
	pages = {197--206}
},

@article{wadler_girardreynolds_2007,
	author = {Philip Wadler},
	file = {:/home/bernardy/Papers/The GirardReynolds isomorphism-2007.pdf:pdf},
	title = {The {Girard–Reynolds} isomorphism (second edition)},
	volume = {375},
	number = {1--3},
	journal = {Theoretical Computer Science},
	year = {2007},
	pages = {201–226}
},

@techreport{gregor_core_2008,
	author = {D Gregor and A Lumsdaine},
	title = {Core Concepts for the {C++0x} Standard Library},
	year = {2008},
	keywords = {sibylle, wgp08},
	see = {related_library:gregor_concepts_2006}
},

@inproceedings{bernardy_parametricity_2010,
	author = {Jean-Philippe Bernardy and Patrik Jansson and Ross
 Paterson},
	address = {Baltimore, Maryland},
	title = {Parametricity and Dependent Types},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN} international conference on Functional programming},
	publisher = {{ACM}},
	doi = {10.1145/1863543.1863592},
	pages = {345--356},
	year = {2010}
},

@article{huet_zipper_1997,
	author = {Gérard Huet},
	title = {The Zipper},
	volume = {7},
	url = {http://portal.acm.org/citation.cfm?id=969872},
	abstract = {Almost every programmer has faced the problem of representing a tree together with a subtree that is the focus of attention, where that focus may move left, right, up or down the tree. The Zipper is Huet's nifty name for a nifty data structure which fulfills this need. I wish I had known of it when I faced this task, because the solution I came up with was not quite so efficient or elegant as the Zipper.},
	number = {5},
	journal = {J. Funct. Program.},
	year = {1997},
	pages = {549--554}
},

@article{pottier_polymorphic_2006,
	author = {Francois Pottier and Nadji Gauthier},
	title = {Polymorphic typed defunctionalization and concretization},
	volume = {19},
	url = {http://portal.acm.org/citation.cfm?id=1145530},
	abstract = {Defunctionalization is a program transformation that eliminates functions as first-class values. We show that defunctionalization can be viewed as a type-preserving transformation of an extension of F with guarded algebraic data types into itself. We also suggest that defunctionalization is an instance of concretization, a more general technique that allows eliminating constructs other than functions. We illustrate this point by presenting two new type-preserving transformations that can be viewed as instances of concretization. One eliminates Rémy-style polymorphic records; the other eliminates the dictionary records introduced by the standard compilation scheme for Haskell's type classes.},
	number = {1},
	journal = {{Higher-Order} Symbol. Comput.},
	year = {2006},
	keywords = {closure conversion, concretization, defunctionalization, dictionary records, polymorphic records, polymorphism, type classes, type-preserving compilation},
	pages = {125--162}
},

@inproceedings{abadi_formal_1993,
	author = {Martín Abadi and Luca Cardelli and {Pierre-Louis} Curien},
	address = {Charleston, South Carolina, United States},
	title = {Formal parametric polymorphism},
	isbn = {0-89791-560-7},
	doi = {10.1145/158511.158622},
	abstract = {A polymorphic function is parametric if its behavior does not depend on the type at which it is instantiated. Starting with Reynolds' work, the study of parametricity is typically semantic. In this paper, we develop a syntactic approach to parametricity, and a formal system that embodies this approach: system R . Girard's system F deals with terms and types; R is an extension of F that deals also with relations between types. In R **, it is possible to derive theorems about functions from their types, or “theorems for free”, as Wadler calls them. An easy “theorem for free” asserts that the type {∀XX→} Bool contains only constant functions; this is not provable in F. There are many harder and more substantial examples. Various metatheorems can also be obtained, such as a syntactic version of Reynolds' abstraction theorem.},
	booktitle = {Proceedings of the 20th {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	year = {1993},
	pages = {157--170}
},

@phdthesis{dogan_javascript_2009,
	author = {Deniz Dogan},
	type = {{MSc} Thesis},
	title = {A {JavaScript} Mode for Yi},
	school = {Chalmers University of Technology},
	year = {2009}
},

@book{harper_practical_????,
	author = {Robert Harper},
	file = {:/home/bernardy/Papers/Practical Foundations for Programming Languages-????.pdf:pdf},
	title = {Practical Foundations for Programming Languages},
	url = {http://www.cs.cmu.edu/~rwh/plbook/book.pdf}
},

@misc{mens_taxonomy_2003,
	author = {T Mens and J Buckley and M Zenger and A Rashid},
	title = {Towards a Taxonomy of Software Evolution},
	url = {http://citeseer.ist.psu.edu/601028.html},
	abstract = {Previous taxonomies of software evolution have focused on the purpose of the change (i.e., the why) rather than the underlying mechanisms. This paper proposes a taxonomy of software evolution based on the characterizing mechanisms of change and the factors that influence these mechanisms. The taxonomy is organized into the following logical groupings: temporal properties, objects of change, system properties, and change support.},
	year = {2003},
	keywords = {evolution}
},

@article{swierstra_combinator_2000,
	author = {S. Doaitse Swierstra},
	title = {Combinator parsers: From toys to tools.},
	volume = {41},
	shorttitle = {generators; D.3.4 {[Programming} languages]},
	url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.30.7601},
	doi = {10.1.1.30.7601},
	number = {1},
	journal = {Electronic Notes in Theoretical Computer Science},
	year = {2000}
},

@article{hinze_church_2005,
	author = {Ralf Hinze},
	file = {:/home/bernardy/Papers/Church Numerals, Twice!-2005.pdf:pdf},
	title = {Church Numerals, Twice!},
	volume = {15},
	url = {http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=266743},
	doi = {10.1017/S0956796804005313},
	number = {1},
	journal = {Journal of Functional Programming},
	year = {2005},
	pages = {1--13}
},

@article{reynolds_definitional_1998,
	author = {John C. Reynolds},
	title = {Definitional Interpreters for {Higher-Order} Programming Languages},
	volume = {11},
	url = {http://portal.acm.org/citation.cfm?id=609184},
	abstract = {Higher-order programming languages (i.e., languages in which procedures or labels can occur as values) are usually defined by interpreters that are themselves written in a programming language based on the lambda calculus (i.e., an applicative language such as pure {LISP).} Examples include {McCarthy‘s} definition of {LISP,} Landin‘s {SECD} machine, the Vienna definition of {PL/I,} Reynolds‘ definitions of {GEDANKEN,} and recent unpublished work by L. Morris and C. Wadsworth. Such definitions can be classified according to whether the interpreter contains higher-order functions, and whether the order of application (i.e., call by value versus call by name) in the defined language depends upon the order of application in the defining language. As an example, we consider the definition of a simple applicative programming language by means of an interpreter written in a similar language. Definitions in each of the above classifications are derived from one another by informal but constructive methods. The treatment of imperative features such as jumps and assignment is also discussed.},
	number = {4},
	journal = {Higher-Order and Symbolic Computation},
	year = {1998},
	keywords = {applicative language, closure, continuation, gedanken, higher-order function, interpreter, j-operator, lambda calculus, language definition, lisp, order of application, pal, programming language, reference, secd machine},
	pages = {363--397}
},

@misc{nilsson_scalacheck_2009,
	author = {Rickard Nilsson},
	title = {{ScalaCheck}},
	url = {http://code.google.com/p/scalacheck/},
	journal = {Google Code},
	month = {7},
	year = {2009},
	howpublished = {\url{http://code.google.com/p/scalacheck/}}
},

@incollection{bierman_upgradej_2008,
	author = {Gavin Bierman and Matthew Parkinson and James Noble},
	title = {{UpgradeJ:} Incremental Typechecking for Class Upgrades},
	url = {http://dx.doi.org/10.1007/978-3-540-70592-5_11},
	abstract = {One of the problems facing developers is the constant evolution of components that are used to build applications. This evolution is typical of any multi-person or multi-site software project. How can we program in this environment? More precisely, how can language design address such evolution? In this paper we attack two significant issues that arise from constant component evolution: we propose language-level extensions that permit multiple, co-existing versions of classes and the ability to dynamically upgrade from one version of a class to another, whilst still maintaining type safety guarantees and requiring only lightweight extensions to the runtime infrastructure. We show how our extensions, whilst intuitive, provide a great deal of power by giving a number of examples. Given the subtlety of the problem, we formalize a core fragment of our language and prove a number of important safety properties.},
	booktitle = {{ECOOP} 2008 â {Object-Oriented} Programming},
	year = {2008},
	keywords = {evolution},
	pages = {235--259}
},

@article{gandy_axiom_1956,
	author = {R. O. Gandy},
	title = {On the Axiom of {Extensionality–Part} I},
	volume = {21},
	number = {1},
	journal = {The Journal of Symbolic Logic},
	year = {1956},
	pages = {36–48}
},

@phdthesis{lattner_llvm_2002,
	author = {Chris Lattner},
	title = {{{LLVM:} An Infrastructure for {Multi-Stage} Optimization}},
	url = {http://llvm.org/pubs/2002-12-LattnerMSThesis.pdf},
	year = {2002},
	keywords = {bibtex-import, llvm},
	annote = {{\textless}p{\textgreater}(private-note){{\textbackslash}em See {{\textbackslash}tt http://llvm.cs.uiuc.edu}.}{\textless}/p{\textgreater}}
},

@book{girard_proofs_1989,
	author = {Jean Yves Girard and Yves Lafont and Paul Taylor},
	file = {:/home/bernardy/Papers/Proofs and Types-1989.pdf:pdf},
	title = {Proofs and Types},
	isbn = {0-521-37181-3},
	url = {http://www.paultaylor.eu/stable/Proofs\%2BTypes.html},
	publisher = {Cambridge University Press},
	year = {1989}
},

@article{johann_principled_2009,
	author = {Patricia Johann and Neil Ghani},
	title = {A principled approach to programming with nested types in Haskell},
	volume = {22},
	url = {http://dx.doi.org/10.1007/s10990-009-9047-7},
	doi = {10.1007/s10990-009-9047-7},
	abstract = {Abstract  Initial algebra semantics is one of the cornerstones of the theory of modern functional programming languages. For each inductive
data type, it provides a Church encoding for that type, a build combinator which constructs data of that type, a fold combinator which encapsulates structured recursion over data of that type, and a fold/build rule which optimises modular programs by eliminating from them data constructed using the buildcombinator, and immediately consumed using the foldcombinator, for that type. It has long been thought that initial algebra semantics is not expressive enough to provide a similar
foundation for programming with nested types in Haskell. Specifically, the standard folds derived from initial algebra semantics have been considered too weak to capture commonly occurring patterns of recursion
over data of nested types in Haskell, and no build combinators or fold/build rules have until now been defined for nested types. This paper shows that standard folds are, in fact, sufficiently expressive for programming with nested types in Haskell. It also defines buildcombinators and fold/build fusion rules for nested types. It thus shows how initial algebra semantics provides a principled, expressive, and elegant
foundation for programming with nested types in Haskell.},
	number = {2},
	journal = {{Higher-Order} and Symbolic Computation},
	month = {jun},
	year = {2009},
	pages = {155--189}
},

@unpublished{takeuti_theory_2004,
	author = {Izumi Takeuti},
	title = {The Theory of Parametricity in Lambda Cube},
	year = {2004},
	note = {Manuscript},
	keywords = {parametricity}
},

@article{wagner_efficient_1998,
	author = {Tim A. Wagner and Suzan L. Graham},
	file = {:/home/bernardy/Papers/Efficient and Flexible Incremental Parsing-1998.pdf:pdf},
	title = {Efficient and Flexible Incremental Parsing},
	volume = {20},
	number = {5},
	journal = {{ACM} Transactions on Programming Languages and Systems},
	year = {1998},
	pages = {980--1013},
	see = {:ghezzi_incremental_1979}
},

@article{abbott_data_2004,
	author = {Michael Abbott and Thorsten Altenkirch and Conor {McBride} and Neil Ghani},
	title = {∂ for Data: Differentiating Data Structures},
	volume = {65},
	shorttitle = {∂ for Data},
	url = {http://portal.acm.org/citation.cfm?id=1227145},
	abstract = {This paper and our conference paper {(Abbott,} Altenkirch, Ghani, and {McBride,} 2003b) explain and analyse the notion of the derivative of a data structure as the type of its one-hole contexts based on the central observation made by {McBride} (2001). To make the idea precise we need a generic notion of a data type, which leads to the notion of a container, introduced in {(Abbott,} Altenkirch, and Ghani, 2003a) and investigated extensively in {(Abbott,} 2003). Using containers we can provide a notion of linear map which is the concept missing from {McBride's} first analysis. We verify the usual laws of differential calculus including the chain rule and establish laws for initial algebras and terminal coalgebras.},
	number = {1-2},
	journal = {Fundam. Inf.},
	year = {2004},
	pages = {1--28}
},

@techreport{rodriguez_generic_????,
	author = {Alexey Rodriguez and Stefan Holdermans and Andres Löh and Johan Jeuring},
	title = {Generic programming with fixed points for mutually recursive datatypes},
	number = {{UU-CS-2008-019}},
	institution = {Utrecht University},
	keywords = {multirec}
},

@book{davey_introduction_2002,
	author = {Brian A. Davey and Hilary A. Priestley},
	title = {Introduction to lattices and order},
	isbn = {0521784514, 9780521784511},
	publisher = {Cambridge University Press},
	year = {2002}
},

@article{cardone_history_2006,
	author = {F. Cardone and J. R. Hindley and N. {MRRS}},
	title = {History of lambda-calculus and combinatory logic},
	volume = {5},
	journal = {Handbook of the History of Logic},
	year = {2006}
},

@misc{sheeran_searching_2007,
	author = {Mary Sheeran},
	type = {talk},
	title = {Searching for prefix networks to fit in a context using a lazy functional programming language},
	year = {2007}
},

@article{claessen_poor_1999,
	author = {Koen Claessen},
	file = {:/home/bernardy/Papers/A poor man's concurrency monad-1999.pdf:pdf},
	title = {A poor man's concurrency monad},
	volume = {9},
	url = {http://portal.acm.org/citation.cfm?id=968592.968596},
	abstract = {Without adding any primitives to the language, we define a concurrency monad transformer in Haskell. This allows us to add a limited form of concurrency to any existing monad. The atomic actions of the new monad are lifted actions of the underlying monad. Some extra operations, such as fork, to initiate new processes, are provided. We discuss the implementation, and use some examples to illustrate the usefulness of this construction.},
	number = {3},
	journal = {J. Funct. Program.},
	year = {1999},
	pages = {313--323}
},

@article{plaice_new_1993,
	author = {J Plaice and {WW} Wadge},
	title = {A new approach to version control},
	volume = {19},
	url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=221137},
	abstract = {A method for controlling versions of software and other hierarchically structured entities is presented. Using the variant structure principle, a particular version of an entire system is formed by combining the most relevant existing versions of the various components of the system. An algebraic version language that allows histories (numbered series), subversions (or variants), and joins is described. It is shown that the join operation is simply the lattice least upper bound and together with the variant structure principle, provides a systematic framework for recombining divergent variants. The utility of this approach is demonstrated using {LEMUR,} a programming environment for modular C programs, which was developed using itself. The ways in which this notion of versions is related to the possible world semantics of intensional logic are discussed},
	number = {3},
	journal = {Software Engineering, {IEEE} Transactions on},
	year = {1993},
	keywords = {cm, vc},
	pages = {268--276},
	annote = {{\textless}p{\textgreater}ignores the problem of merging{\textless}/p{\textgreater}}
},

@inproceedings{stewart_dynamic_2005,
	author = {Don Stewart and Manuel Chakravarty},
	title = {Dynamic applications from the ground up},
	isbn = {{159593071X}},
	url = {http://dx.doi.org/10.1145/1088348.1088352},
	booktitle = {Haskell '05: Proceedings of the 2005 {ACM} {SIGPLAN} workshop on Haskell},
	publisher = {{ACM} Press},
	year = {2005},
	keywords = {haskell},
	pages = {27--38}
},

@article{hutton_monadic_1998,
	author = {G. Hutton and E. Meijer},
	title = {Monadic parsing in Haskell},
	volume = {8},
	number = {04},
	journal = {Journal of Functional Programming},
	year = {1998},
	pages = {437--444}
},

@inproceedings{coquand_analysis_1986,
	author = {Thierry Coquand},
	file = {:/home/bernardy/Papers/An Analysis of Girard's Paradox-1986.ps:ps},
	title = {An Analysis of {Girard}'s Paradox},
	booktitle = {Logic in computer science},
	publisher = {IEEE Computer Society},
	year = {1986},
	pages = {227--236}
},

@book{pierce_basic_1991,
	author = {Benjamin C. Pierce},
	edition = {1},
	title = {Basic Category Theory for Computer Scientists},
	isbn = {0262660717},
	publisher = {The {MIT} Press},
	month = {aug},
	year = {1991}
},

@book{pierce_types_2002,
	author = {Benjamin C. Pierce},
	edition = {1},
	title = {Types and Programming Languages},
	isbn = {0-262-16209-1},
	publisher = {The {MIT} Press},
	year = {2002}
},

@unpublished{bernardy_abstraction_2010,
	author = {Jean-Philippe Bernardy and Patrik Jansson and Ross Paterson},
	file = {:/home/bernardy/Papers/An abstraction theorem for pure type systems-2010.pdf:pdf},
	type = {manuscript},
	title = {An abstraction theorem for pure type systems},
	url = {http://www.cse.chalmers.se/~bernardy/ParDep/abstraction-pts.pdf},
	year = {2010},
	note = {Available from \url{http://www.cse.chalmers.se/~bernardy/ParDep/abstraction-pts.pdf}},
	see = {machine_proof:bernardy_proof_2010}
},

@article{hoffman_testing_1998,
	author = {Daniel Hoffman and Jayakrishnan Nair and Paul Strooper},
	title = {Testing generic {{Ada}} packages with {APE}},
	volume = {{XVIII}},
	url = {http://portal.acm.org/citation.cfm?id=301687.289640},
	doi = {10.1145/301687.289640},
	abstract = {Note: {OCR} errors may be found in this Reference List extracted from the full text article. {ACM} has opted to expose the complete List rather than only correct and linked references.},
	number = {6},
	journal = {Ada Letters},
	year = {1998},
	pages = {255--262}
},

@phdthesis{werner_une_1994,
	author = {Benjamin Werner},
	type = {{PhD} Thesis},
	title = {Une théorie des constructions inductives},
	school = {Université de Paris 7},
	year = {1994}
},

@article{wadler_girardreynolds_2003,
	author = {Philip Wadler},
	title = {The {Girard–Reynolds} isomorphism},
	volume = {186},
	url = {http://portal.acm.org/citation.cfm?id=957696},
	abstract = {The second-order polymorphic lambda calculus, F2, was independently discovered by Girard and Reynolds. Girard additionally proved a Representation Theorem: every function on natural numbers that can be proved total in second-order intuitionistic predicate logic, P2, can be represented in F2. Reynolds additionally proved an Abstraction Theorem: for a suitable notion of logical relation, every term in F2 takes related arguments into related results. We observe that the essence of Girard's result is a projection from P2 into F2, and that the essence of Reynolds's result is an embedding of F2 into P2, and that the Reynolds embedding followed by the Girard projection is the identity. The Girard projection discards all first-order quantifiers, so it seems unreasonable to expect that the Girard projection followed by the Reynolds embedding should also be the identity. However, we show that in the presence of Reynolds's parametricity property that this is indeed the case, for propositions corresponding to inductive definitions of naturals or other algebraic types.},
	number = {2},
	journal = {Information and Computation},
	year = {2003},
	pages = {260--284},
	see = {version:wadler_girardreynolds_2007}
},

@inproceedings{bernardy_testing_2010,
	author = {Jean-Philippe Bernardy and Patrik Jansson and Koen
 Claessen},
	affiliation = {Chalmers University of Technology},
	series = {Lecture Notes in Computer Science},
	title = {Testing Polymorphic Properties},
	editor = {Gordon, Andrew},
	volume = {6012},
	pages = {125--144},
	doi = {10.1007/978-3-642-11957-6_8},
	documenturl = {http://www.cse.chalmers.se/~bernardy/PolyTest.pdf},
	abstract = {This paper is concerned with testing properties of
                  polymorphic functions. The problem is that testing
                  can only be performed on specific monomorphic
                  instances, whereas parametrically polymorphic
                  functions are expected to work for any type. We
                  present a schema for constructing a monomorphic
                  instance for a polymorphic property, such that
                  correctness of that single instance implies
                  correctness for all other instances. We also give a
                  formal definition of the class of polymorphic
                  properties the schema can be used for. Compared to
                  the standard method of testing such properties, our
                  schema leads to a significant reduction of necessary
                  test cases.},
	booktitle = {European Symposium on Programming},
	publisher = {Springer},
	year = {2010},
	keywords = {Programvaruteknik}
},

@inproceedings{siek_essential_2005,
	author = {Jeremy Siek and Andrew Lumsdaine},
	address = {Chicago, {{IL},} {{USA}}},
	title = {Essential Language Support for Generic Programming},
	url = {http://dx.doi.org/http://doi.acm.org/10.1145/1065010.1065021},
	booktitle = {{{PLDI}} '05: Proceedings of the {{ACM}} {{SIGPLAN}} 2005 conference on Programming language design and implementation},
	publisher = {{{ACM}} Press},
	year = {2005},
	keywords = {concept, file-import-08-06-27},
	pages = {73--84}
},

@misc{danvy_representing_????,
	author = {Olivier Danvy and Andrzej Filinski},
	title = {Representing control: a study of the {CPS} transformation},
	url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.84},
	abstract = {This paper investigates the transformation of v-terms into continuation-passing style {(CPS).} We show that by appropriate j-expansion of Fischer and Plotkin's two-pass equational specification of the {CPS} transform, we can obtain a static and context-free separation of the result terms into \&quot;essential \&quot; and \&quot;administrative \&quot; constructs. Interpreting the former as syntax builders and the latter as directly executable code, we obtain a simple and efficient one-pass transformation algorithm, easily extended to conditional expressions, recursive definitions, and similar constructs. This new transformation algorithm leads to a simpler proof of Plotkin's simulation and indifference results. We go on to show how {CPS-based} control operators similar to, but more general than, Scheme's call/cc can be naturally accommodated by the new transformation algorithm. To demonstrate the expressive power of these operators, we use them to present an equivalent but even more concise formulation of the efficient {CPS} transformation algorithm. Finally, we relate the fundamental ideas underlying this derivation to similar concepts from other works on program manipulation; we derive a one-pass {CPS} transformation of n-terms; and we outline some promising areas for future research.},
	keywords = {cps},
	howpublished = {\url{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.84}}
},

@incollection{ratzinger_eq-mine_2007,
	author = {Jacek Ratzinger and Martin Pinzger and Harald Gall},
	title = {{EQ-Mine:} Predicting {Short-Term} Defects for Software Evolution},
	url = {http://dx.doi.org/10.1007/978-3-540-71289-3_3},
	abstract = {We use 63 features extracted from sources such as versioning and issue tracking systems to predict defects in short time frames of two months. Our multivariate approach covers aspects of software projects such as size, team structure, process orientation, complexity of existing solution, difficulty of problem, coupling aspects, time constrains, and testing data. We investigate the predictability of several severities of defects in software projects. Are defects with high severity difficult to predict? Are prediction models for defects that are discovered by internal staff similar to models for defects reported from the field? We present both an exact numerical prediction of future defect numbers based on regression models as well as a classification of software components as defect-prone based on the C4.5 decision tree. We create models to accurately predict short-term defects in a study of 5 applications composed of more than 8.000 classes and 700.000 lines of code. The model quality is assessed based on 10-fold cross validation.},
	booktitle = {Fundamental Approaches to Software Engineering},
	year = {2007},
	keywords = {evolution},
	pages = {12--26}
},

@misc{bernardy_derivation_2010,
	author = {Jean-Philippe Bernardy},
	title = {Derivation Trees Haskell Package},
	url = {http://hackage.haskell.org/packages/archive/derivation-trees/},
	abstract = {A library to typeset derivation trees via Laurent Mehats metapost package.
  Also contains a module to ease the generation of trees for (coloured) pure type systems.},
	year = {2010}
},

@inproceedings{magnusson_fine_1996,
	author = {Boris Magnusson and Ulf Asklund},
	title = {Fine Grained Version Control of Configurations in {COOP/Orm}},
	url = {http://citeseer.ist.psu.edu/19322.html},
	abstract = {. This paper describes a unified approach to version control of documents and configurations. Hierarchical structure, which is present in most documents such as programs, is recognized and utilized in a fine-grained version control system. The same mechanism is used for version control of configurations and extended to handle {DAGs} as well as trees. Change propagation within one hierarchical document is automatic while bindings between documents are explicit. The model is novel because of its...},
	booktitle = {System Configuration Management},
	year = {1996},
	keywords = {vc},
	pages = {31--48},
	annote = {{\textless}p{\textgreater}blabla{\textless}/p{\textgreater}}
},

@inproceedings{lmmel_expression_2008,
	author = {Ralf Lämmel and Ondrej Rypacek},
	title = {{{The} expression lemma}},
	booktitle = {{{Proceedings} of Mathematics of Program Construction {(MPC)} 2008}},
	publisher = {Springer},
	year = {2008},
	keywords = {open},
	annote = {{{\textless}p{\textgreater}To} appear{\textless}/p{\textgreater}}
},

@inproceedings{stewart_xmonad_2007,
	author = {Don Stewart and Spencer Sjanssen},
	title = {Xmonad},
	isbn = {9781595936745},
	url = {http://dx.doi.org/10.1145/1291201.1291218},
	booktitle = {Haskell '07: Proceedings of the {ACM} {SIGPLAN} workshop on Haskell workshop},
	publisher = {{ACM}},
	year = {2007},
	keywords = {haskell},
	pages = {119}
},

@unpublished{altenkirch_dependent_2005,
	author = {T. Altenkirch and C. {McBride} and J. {McKinna}},
	title = {Why dependent types matter},
	url = {http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf},
	year = {2005},
	see = {talk:mckinna_dependent_2006}
},

@techreport{rountev_practical_2000,
	author = {A Rountev and B Ryder},
	title = {Practical points-to analysis for programs built with libraries},
	url = {#},
	year = {2000},
	keywords = {points-to}
},

@inproceedings{altenkirch_generic_2003,
	author = {Thorsten Altenkirch and Conor {McBride}},
	title = {Generic Programming within Dependently Typed Programming},
	isbn = {1402073747},
	url = {http://portal.acm.org/citation.cfm?id=647100.717294},
	booktitle = {Proceedings of the {IFIP} {TC2/WG2.1} Working Conference on Generic Programming},
	publisher = {Kluwer, {B.V.}},
	year = {2003},
	keywords = {aop, generic},
	pages = {1--20}
},

@inproceedings{claessen_quickcheck_2000,
	author = {Koen Claessen and John Hughes},
	file = {:/home/bernardy/Papers/QuickCheck a lightweight tool for random testing of Haskell programs-2000.pdf:pdf},
	title = {{QuickCheck:} a lightweight tool for random testing of {Haskell} programs},
	isbn = {1-58113-202-6},
	shorttitle = {{QuickCheck}},
	doi = {10.1145/351240.351266},
	abstract = {Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.},
	booktitle = {Proceedings of the fifth {ACM} {SIGPLAN} international conference on Functional Programming},
	publisher = {{ACM}},
	year = {2000},
	pages = {268--279}
},

@inproceedings{nielsen_call-by-name_1995,
	author = {Kristian Nielsen and Morten Heine Sørensen},
	title = {{Call-By-Name} {CPS-Translation} as a {Binding-Time} Improvement},
	isbn = {3-540-60360-3},
	url = {http://portal.acm.org/citation.cfm?id=717677},
	booktitle = {Proceedings of the Second International Symposium on Static Analysis},
	publisher = {{Springer-Verlag}},
	year = {1995},
	pages = {296--313}
},

@inproceedings{jones_system_1993,
	author = {Mark Jones},
	title = {A system of constructor classes: overloading and implicit higher-order polymorphism},
	isbn = {{089791595X}},
	url = {http://dx.doi.org/10.1145/165180.165190},
	booktitle = {{FPCA} '93: Proceedings of the conference on Functional programming languages and computer architecture},
	publisher = {{ACM} Press},
	year = {1993},
	keywords = {typeclass},
	pages = {52--61}
},

@article{sheeran_hardware_2005,
	author = {Mary Sheeran},
	title = {Hardware Design and Functional Programming: a Perfect Match},
	volume = {11},
	abstract = {This paper aims to explain why I am still fascinated by the use of functional languages in hardware design. I hope that some readers will be tempted to tackle some of the hard problems that I outline in the final section. In particular, I believe that programming language researchers have much to contribute to the field of hardware design.},
	number = {7},
	journal = {Journal of Universal Computer Science},
	year = {2005},
	note = {{\textbar}http://www.jucs.org/jucs\_11\_7/hardware\_design\_and\_functional{\textbar}},
	pages = {1135–1158}
},

@inproceedings{saff_theory-infected_2007,
	author = {David Saff},
	address = {Montreal, Quebec, Canada},
	title = {Theory-infected: or how i learned to stop worrying and love universal quantification},
	isbn = {978-1-59593-865-7},
	shorttitle = {Theory-infected},
	url = {http://portal.acm.org/citation.cfm?id=1297919},
	doi = {10.1145/1297846.1297919},
	abstract = {Writing developer tests as software is built can provide peace of mind. As the software grows, running the tests can prove that everything still works as the developer envisioned it. But what about the behavior the developer failed to envision? Although verifying a few well-picked scenarios is often enough, experienced developers know bugs can often lurk even in well-tested code, when correct but untested inputs provoke obviously wrong responses. This leads to worry.},
	booktitle = {Companion to the 22nd {ACM} {SIGPLAN} conference on Object-oriented programming systems and applications companion},
	publisher = {{ACM}},
	year = {2007},
	keywords = {junit, partial specification, testing, theories},
	pages = {846--847}
},

@incollection{abbott_categories_2003,
	author = {Michael Abbott and Thorsten Altenkirch and Neil Ghani},
	series = {Lecture Notes in Computer Science},
	title = {Categories of Containers},
	volume = {2620},
	isbn = {0302-9743},
	doi = {10.1007/3-540-36576-1_2},
	abstract = {We introduce the notion of containers as a mathematical formalisation of the idea that many important datatypes consist of
templates where data is stored. We show that containers have good closure properties under a variety of constructions including
the formation of initial algebras and final coalgebras. We also show that containers include strictly positive types and shapely
types but that there are containers which do not correspond to either of these. Further, we derive a representation result
classifying the nature of polymorphic functions between containers. We finish this paper with an application to the theory
of shapely types and refer to a forthcoming paper which applies this theory to differentiable types.},
	booktitle = {Foundations of Software Science and Computation Structures},
	publisher = {Springer, Heidelberg},
	year = {2003},
	pages = {23--38}
},

@phdthesis{norell_practical_2007,
	author = {Ulf Norell},
	type = {{PhD} Thesis},
	title = {Towards a practical programming language based on dependent type theory},
	url = {http://publications.lib.chalmers.se/cpl/record/index.xsql?pubid=46311},
	abstract = {Dependent type theories have a long history of being used for theorem proving. One aspect of type theory which makes it very powerful as a proof language is that it mixes deduction with computation. This also makes type theory a good candidate for programming---the strength of the type system allows properties of programs to be stated and established, and the computational properties provide semantics for the programs. This thesis is concerned with bridging the gap between the theoretical presentations of type theory and the requirements on a practical programming language. Although there are many challenging research problems left to solve before we have an industrial scale programming language based on type theory, this thesis takes us a good step along the way.},
	school = {Chalmers Tekniska Högskola},
	year = {2007},
	keywords = {type theory, programming, dependent types, pattern matching, metavariables, type checking}
},

@inproceedings{rodriguez_comparing_2008,
	author = {Alexey Rodriguez and Johan Jeuring and Patrik Jansson and Alex Gerdes and Oleg Kiselyov and Bruno C. d. S. Oliveira},
	address = {Victoria, {BC,} Canada},
	title = {Comparing libraries for generic programming in haskell},
	isbn = {978-1-60558-064-7},
	url = {http://portal.acm.org/citation.cfm?id=1411286.1411301},
	doi = {10.1145/1411286.1411301},
	abstract = {Datatype-generic programming is defining functions that depend on the structure, or "shape", of datatypes. It has been around for more than 10 years, and a lot of progress has been made, in particular in the lazy functional programming language Haskell. There are more than 10 proposals for generic programming libraries orlanguage extensions for Haskell. To compare and characterise the many generic programming libraries in atyped functional language, we introduce a set of criteria and develop a generic programming benchmark: a set of characteristic examples testing various facets of datatype-generic programming. We have implemented the benchmark for nine existing Haskell generic programming libraries and present the evaluation of the libraries. The comparison is useful for reaching a common standard for generic programming, but also for a programmer who has to choose a particular approach for datatype-generic programming.},
	booktitle = {Proceedings of the first {ACM} {SIGPLAN} symposium on Haskell},
	publisher = {{ACM}},
	year = {2008},
	keywords = {datatype-generic programming, libraries comparison},
	pages = {111--122},
	see = {:hinze_generic_2009;:sheard_generic_2007}
},

@misc{pfenning_15-816_????,
	author = {Frank Pfenning},
	title = {15-816 Linear Logic / Schedule},
	url = {http://www.cs.cmu.edu/~fp/courses/linear/schedule.html},
	howpublished = {\url{http://www.cs.cmu.edu/~fp/courses/linear/schedule.html}}
},

@inproceedings{peyton_jones_type_1997,
	author = {Simon {Peyton Jones} and Mark Jones and Erik Meijer},
	title = {Type classes: an exploration of the design space},
	url = {http://research.microsoft.com/en-us/um/people/simonpj/papers/type-class-design-space/},
	abstract = {When type classes were first introduced in Haskell they were regarded as a fairly experimental language feature, and therefore warranted a fairly conservative design. Since that time, practical experience has convinced many programmers of the benefits and convenience of type classes. However, on occasion, these same programmers have discovered examples where seemingly natural applications for type class overloading are prevented by the restrictions imposed by the Haskell design. It is possible...},
	year = {1997},
	keywords = {typeclass},
	booktitle = {{Haskell} Workshop}
},

@inproceedings{lippe_operation-based_1992,
	author = {Ernst Lippe and Norbert van Oosterom},
	title = {Operation-based merging},
	isbn = {0163-5948},
	url = {http://dx.doi.org/10.1145/142868.143753},
	booktitle = {{SDE} 5: Proceedings of the fifth {ACM} {SIGSOFT} symposium on Software development environments},
	publisher = {{ACM} Press},
	year = {1992},
	keywords = {change-based, good, vc, vc-project},
	pages = {78--87},
	annote = {{\textless}p{\textgreater}== introduces changed-based {VC} == conflict-free = commutation{\textless}/p{\textgreater}}
},

@incollection{bove_formalising_2006,
	author = {Ana Bove and Thierry Coquand},
	title = {Formalising Bitonic Sort in Type Theory},
	url = {http://dx.doi.org/10.1007/11617990_6},
	abstract = {We discuss two complete formalisations of bitonic sort in constructive type theory. Bitonic sort is one of the fastest sorting
algorithms where the sequence of comparisons is not data-dependent. In addition, it is a general recursive algorithm. In the
formalisation we face two main problems: only structural recursion is allowed in type theory, and a formal proof of the correctness
of the algorithm needs to consider quite a number of cases. In our first formalisation we define bitonic sort over dependently-typed
binary trees with information in the leaves and we make use of the 0-1-principle to prove that the algorithm sorts inputs
of arbitrary types. In our second formalisation we use notions from linear orders, lattice theory and monoids. The correctness
proof is directly performed for any ordered set and not only for Boolean values.},
	booktitle = {Types for Proofs and Programs},
	year = {2006},
	pages = {82--97}
},

@article{tillmann_parameterized_2005,
	author = {Nikolai Tillmann and Wolfram Schulte},
	title = {Parameterized unit tests},
	volume = {30},
	url = {http://portal.acm.org/citation.cfm?id=1081749},
	doi = {10.1145/1095430.1081749},
	abstract = {Parameterized unit tests extend the current industry practice of using closed unit tests defined as parameterless methods. Parameterized unit tests separate two concerns: 1) They specify the external behavior of the involved methods for all test arguments. 2) Test cases can be re-obtained as traditional closed unit tests by instantiating the parameterized unit tests. Symbolic execution and constraint solving can be used to automatically choose a minimal set of inputs that exercise a parameterized unit test with respect to possible code paths of the implementation. In addition, parameterized unit tests can be used as symbolic summaries which allows symbolic execution to scale for arbitrary abstraction levels. We have developed a prototype tool which computes test cases from parameterized unit tests. We report on its first use testing parts of the {.NET} base class library.},
	number = {5},
	journal = {{SIGSOFT} Software Engineering Notes},
	year = {2005},
	keywords = {algebraic data types, automatic test input generation, constraint solving, symbolic execution, unit testing},
	pages = {253--262}
},

@incollection{robbes_approach_2007,
	author = {Romain Robbes and Michele Lanza and Mircea Lungu},
	title = {An Approach to Software Evolution Based on Semantic Change},
	url = {http://dx.doi.org/10.1007/978-3-540-71289-3_4},
	abstract = {The analysis of the evolution of software systems is a useful source of information for a variety of activities, such as reverse engineering, maintenance, and predicting the future evolution of these systems. Current software evolution research is mainly based on the information contained in versioning systems such as {CVS} and {SubVersion.} But the evolutionary information contained therein is incomplete and of low quality, hence limiting the scope of evolution research. It is incomplete because the historical information is only recorded at the explicit request of the developers (a commit in the classical checkin/checkout model). It is of low quality because the file-based nature of versioning systems leads to a view of software as being a set of files. In this paper we present a novel approach to software evolution analysis which is based on the recording of all semantic changes performed on a system, such as refactorings. We describe our approach in detail, and demonstrate how it can be used to perform fine-grained software evolution analysis.},
	booktitle = {Fundamental Approaches to Software Engineering},
	year = {2007},
	keywords = {evolution},
	pages = {27--41}
},

@book{austern_generic_1998,
	author = {Matthew Austern},
	title = {Generic programming and the {STL:} using and extending the C++ Standard Template Library},
	isbn = {0201309564},
	url = {http://portal.acm.org/citation.cfm?id=288771},
	publisher = {{Addison-Wesley} Longman Publishing Co., Inc.},
	year = {1998},
	keywords = {concept}
},

@incollection{ruffell_pervasiveness_2006,
	author = {Fraser Ruffell and Jason Selby},
	title = {The Pervasiveness of Global Data in Evolving Software Systems},
	url = {http://dx.doi.org/10.1007/11693017_30},
	abstract = {In this research, we investigate the role of common coupling in evolving software systems. It can be argued that most software developers understand that the use of global data has many harmful side-effects, and thus should be avoided. We are therefore interested in the answer to the following question: if global data does exist within a software project, how does global data usage evolve over a software projectâs lifetime? Perhaps the constant refactoring and perfective maintenance eliminates global data usage, or conversely, perhaps the constant addition of features and rapid development introduce an increasing reliance on global data? We are also interested in identifying if global data usage patterns are useful as a software metric that is indicative of an interesting or significant event in the softwareâs lifetime.},
	booktitle = {Fundamental Approaches to Software Engineering},
	year = {2006},
	keywords = {coupling, evolution},
	pages = {396--410}
},

@article{johnsson_efficient_1998,
	author = {Thomas Johnsson},
	file = {:/home/bernardy/Papers/Efficient graph algorithms using lazy monolithic arrays-1998.pdf:pdf},
	title = {Efficient graph algorithms using lazy monolithic arrays},
	volume = {8},
	url = {http://portal.acm.org/citation.cfm?id=969592.969594},
	abstract = {Many, perhaps even most, algorithms that involve data structures are traditionally expressed by incremental updates of the data structures. In functional languages, however, incremental updates are usually both clumsy and inefficient, especially when the data structure is an {array.In} functional languages, we instead prefer to express such array algorithms using monolithic arrays – wholesale creation of the final answer – both for succinctness of expression, efficiency (only one array created) and (sometimes) implicit parallelism. The ease with which the solution can be reformulated of course depends on the problem, and varies from trivial (e.g. matrix multiplication), to challenging (e.g. solving linear equation systems using Gauss elimination, which in fact can be done by creating only two arrays, recursively defined, of which one is the answer). Other problems have been notoriously resistant to attack; these usually involve some unpredictable processing order of the elements. One such problem is graph marking, i.e. marking the nodes reachable from a set of roots. Hitherto, no functional method has been known except emulating the traditional imperative solution {(King} \& Launchbury, 1995; Launchbury \& Peyton Jones, {1995).The} contribution of this paper is to show how this problem, and some related ones, can be solved using a novel array creation primitive, lazier than previous ones.},
	number = {4},
	journal = {J. Funct. Program.},
	year = {1998},
	pages = {323--333},
	annote = {{{\textless}p{\textgreater}lazyArray} :: {(Int,} Int) -\&gt; [(int,a)] -\&gt; Array Int [a]{\textless}/p{\textgreater}}
},

@techreport{becker_working_2007,
	author = {Pete Becker},
	title = {Working Draft, Standard for Programming Language {\textbackslash}{\textbackslash}cpp},
	year = {2007},
	keywords = {sibylle, wgp08}
},

@inproceedings{schrijvers_type_2008,
	author = {Tom Schrijvers and Simon {Peyton Jones} and Manuel Chakravarty and Martin Sulzmann},
	address = {Victoria, {BC,} Canada},
	title = {Type checking with open type functions},
	isbn = {978-1-59593-919-7},
	url = {http://portal.acm.org/citation.cfm?id=1411204.1411215},
	doi = {10.1145/1411204.1411215},
	abstract = {We report on an extension of Haskell with open type-level functions and equality constraints that unifies earlier work on {GADTs,} functional dependencies, and associated types. The contribution of the paper is that we identify and characterise the key technical challenge of entailment checking; and we give a novel, decidable, sound, and complete algorithm to solve it, together with some practically-important variants. Our system is implemented in {GHC,} and is already in active use.},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} international conference on Functional Programming},
	publisher = {{ACM}},
	year = {2008},
	keywords = {haskell, type checking, type families, type functions},
	pages = {51--62}
},

@inproceedings{kiselyov_lightweight_2007,
	author = {Oleg Kiselyov and {Chung-Chieh} Shan},
	title = {Lightweight static resources, for safe embedded and systems programming},
	url = {http://okmij.org/ftp/Haskell/types.html#ls-resources},
	abstract = {It is an established trend to develop low-level code -- embedded software, device drivers, and operating systems -- using high-level languages, especially functional languages with advanced facilities to abstract and generate code. To be reliable and secure, low-level code must correctly manage space, time, and other resources, so special type systems and verification tools arose to regulate resource access statically. However, a general-purpose functional language practical today can provide the same static assurances, also without run-time overhead. We substantiate this claim and promote the trend with two security kernels in the domain of device drivers: * one built around raw pointers, to track and arbitrate the size, alignment, write permission, and other properties of memory areas across indexing and casting; * the other built around a device register, to enforce protocol and timing requirements while reading from the register. Our style is convenient in Haskell thanks to custom kinds and predicates (as type classes); type-level numbers, functions, and records (using functional dependencies); and mixed type- and term-level programming (enabling partial type signatures).},
	booktitle = {Draft Proceedings of Trends in Functional Programming},
	publisher = {Seton Hall University},
	year = {2007},
	keywords = {programming, typelevel}
},

@inproceedings{arts_testing_2006,
	author = {Thomas Arts and John Hughes and Joakim Johansson and Ulf Wiger},
	address = {Portland, Oregon, {USA}},
	title = {Testing telecoms software with quviq {QuickCheck}},
	isbn = {1-59593-490-1},
	url = {http://portal.acm.org/citation.cfm?id=1159792},
	doi = {10.1145/1159789.1159792},
	abstract = {We present a case study in which a novel testing tool, Quviq {QuickCheck,} is used to test an industrial implementation of the Megaco protocol. We considered positive and negative testing and we used our developed specification to test an old version in order to estimate how useful {QuickCheck} could potentially be when used early in {development.The} results of the case study indicate that, by using Quviq {QuickCheck,} we would have been able to detect faults early in the {development.We} detected faults that had not been detected by other testing techniques. We found unclarities in the specifications and potential faults when the software is used in a different setting. The results are considered promising enough to Ericsson that they are investing in an even larger case study, this time from the beginning of the development of a new product.},
	booktitle = {Proceedings of the 2006 {ACM} {SIGPLAN}  workshop on Erlang},
	publisher = {{ACM}},
	year = {2006},
	keywords = {property based testing, test automation},
	pages = {2--10}
},

@inproceedings{voigtlnder_proving_2008,
	author = {Janis Voigtländer},
	file = {:/home/bernardy/Papers/Proving correctness via free theorems the case of the destroybuild-rule-2008.pdf:pdf},
	address = {San Francisco, California, {USA}},
	title = {Proving correctness via free theorems: the case of the destroy/build-rule},
	isbn = {978-1-59593-977-7},
	shorttitle = {Proving correctness via free theorems},
	url = {http://portal.acm.org/citation.cfm?id=1328408.1328412},
	doi = {10.1145/1328408.1328412},
	abstract = {Free theorems feature prominently in the field of program transformation for pure functional languages such as Haskell. However, somewhat disappointingly, the semantic properties of so based transformations are often established only very superficially. This paper is intended as a case study showing how to use the existing theoretical foundations and formal methods for improving the situation. To that end, we investigate the correctness issue for a new transformation rule in the short cut fusion family. This destroy/build-rule provides a certain reconciliation between the competing foldr/build- and destroy/unfoldr-approaches to eliminating intermediate lists. Our emphasis is on systematically and rigorously developing the rule's correctness proof, even while paying attention to semantic aspects like potential nontermination and mixed strict/nonstrict evaluation.},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} symposium on Partial evaluation and semantics-based program manipulation},
	publisher = {{ACM}},
	year = {2008},
	keywords = {correctness proofs, intermediate data structures, program transformations, rank-2 types, relational parametricity, shortcut deforestation, theorems for free},
	pages = {13--20}
},

@inproceedings{neis_non-parametric_2009,
	author = {Georg Neis and Derek Dreyer and Andreas Rossberg},
	file = {:/home/bernardy/Papers/Non-parametric parametricity-2009.pdf:pdf},
	address = {Edinburgh, Scotland},
	title = {Non-parametric parametricity},
	isbn = {978-1-60558-332-7},
	url = {http://portal.acm.org/citation.cfm?id=1596550.1596572},
	doi = {10.1145/1596550.1596572},
	abstract = {Type abstraction and intensional type analysis are features seemingly at odds-type abstraction is intended to guarantee parametricity and representation independence, while type analysis is inherently non-parametric. Recently, however, several researchers have proposed and implemented "dynamic type generation" as a way to reconcile these features. The idea is that, when one defines an abstract type, one should also be able to generate at run time a fresh type name, which may be used as a dynamic representative of the abstract type for purposes of type analysis. The question remains: in a language with non-parametric polymorphism, does dynamic type generation provide us with the same kinds of abstraction guarantees that we get from parametric polymorphism?},
	booktitle = {Proceedings of the 14th {ACM} {SIGPLAN} international conference on Functional Programming},
	publisher = {{ACM}},
	year = {2009},
	keywords = {intensional type analysis, parametricity, representation independence, step-indexed logical relations, type-safe cast},
	pages = {135--148}
},

@inproceedings{fegaras_revisiting_1996,
	author = {Leonidas Fegaras and Tim Sheard},
	address = {St. Petersburg Beach, Florida, United States},
	title = {Revisiting catamorphisms over datatypes with embedded functions (or, programs from outer space)},
	isbn = {0-89791-769-3},
	url = {http://portal.acm.org/citation.cfm?id=237792},
	doi = {10.1145/237721.237792},
	abstract = {Note: {OCR} errors may be found in this Reference List extracted from the full text article. {ACM} has opted to expose the complete List rather than only correct and linked references.},
	booktitle = {Proceedings of the 23rd {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	year = {1996},
	pages = {284--294}
},

@article{hughes_novel_1986,
	author = {R J M Hughes},
	title = {A novel representation of lists and its application to the function "reverse"},
	volume = {22},
	url = {http://portal.acm.org/citation.cfm?id=8468.8475},
	number = {3},
	journal = {Inf. Process. Lett.},
	year = {1986},
	pages = {141--144}
},

@article{zeller_unified_1997,
	author = {Andreas Zeller and Gregor Snelting},
	title = {Unified versioning through feature logic},
	volume = {6},
	url = {http://citeseer.ist.psu.edu/188532.html},
	abstract = {Software Configuration Management {(SCM)} suffers from tight coupling between {SCM} versioning models and the imposed {SCM} processes. In order to adapt {SCM} tools to {SCM} processes, rather than vice versa, we propose a unified versioning model, the version set model. Version sets denote versions, components, and configurations by feature terms, that is, boolean terms over (feature: value)-attributions. Through feature logic, we deduce consistency of abstract configurations as well as features of...},
	number = {4},
	journal = {{ACM} Transactions on Software Engineering and Methodology},
	year = {1997},
	keywords = {vc},
	pages = {398--441}
},

@unpublished{mcbride_ornamental_2010,
	author = {Conor Mcbride},
	title = {Ornamental Algebras, Algebraic Ornaments},
	year = {2010},
	note = {Manuscript available online},
	url = {http://personal.cis.strath.ac.uk/~conor/pub/OAAO/Ornament.pdf}
},

@article{fokkinga_datatype_1996,
	author = {Maarten M. Fokkinga},
	title = {Datatype Laws Without Signatures},
	volume = {6},
	url = {http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=4131224},
	doi = {10.1017/S0960129500000852},
	number = {01},
	journal = {Mathematical Structures in Computer Science},
	year = {1996},
	pages = {1--32}
},

@inproceedings{hinze_type-indexed_2002,
	author = {Ralf Hinze and Johan Jeuring and Andres Löh},
	file = {:/home/bernardy/Papers/Type-Indexed Data Types-2002.pdf:pdf},
	title = {{Type-Indexed} Data Types},
	isbn = {3-540-43857-2},
	url = {http://portal.acm.org/citation.cfm?id=747315},
	booktitle = {Proceedings of the 6th International Conference on Mathematics of Program Construction},
	publisher = {{Springer-Verlag}},
	year = {2002},
	pages = {148--174}
},

@misc{miquel_type_????,
	author = {Alexandre Miquel},
	title = {Type Theory: Impredicative Part},
	url = {http://www.math.chalmers.se/~miquel/},
	howpublished = {\url{http://www.math.chalmers.se/~miquel/}}
},

@phdthesis{miquel_calcul_2001,
	author = {Alexandre Miquel},
	file = {:/home/bernardy/Papers/Le Calcul des Constructions implicite syntaxe et smantique-2001.pdf:pdf},
	title = {Le Calcul des Constructions implicite: syntaxe et sémantique},
	type = {Thèse de doctorat},
	school = {Université Paris 7},
	month = {12},
	year = {2001}
},

@inproceedings{jrvi_library_2007,
	author = {J Järvi and M Marcus and J Smith and C Consel and J Lawall},
	title = {Library composition and adaptation using {{{\textbackslash}{\textbackslash}Cpp}} concepts},
	booktitle = {Generative Programming and Component Engineering, 6th International Conference, {GPCE} 2007, Salzburg, Austria, October 1-3, 2007, Proceedings},
	year = {2007},
	keywords = {sibylle, wgp08},
	pages = {73--82}
},

@article{swierstra_data_2008,
	author = {Wouter Swierstra},
	file = {:/home/bernardy/Papers/Data types  la carte-2008.pdf:pdf},
	title = {Data types à la carte},
	volume = {Forthcoming},
	url = {http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=1813324},
	abstract = {This paper describes a technique for assembling both data types and functions from isolated individual components. We also explore how the same technology can be used to combine free monads and, as a result, structure Haskell's monolithic {IO} monad.},
	number = {-1},
	journal = {Journal of Functional Programming},
	year = {2008},
	keywords = {aop, open},
	pages = {1--14}
},

@inproceedings{voigtlnder_bidirectionalization_2009,
	author = {Janis Voigtländer},
	file = {:/home/bernardy/Papers/Bidirectionalization for free! (Pearl)-2009.pdf:pdf},
	address = {Savannah, {GA,} {USA}},
	title = {Bidirectionalization for free! {(Pearl)}},
	isbn = {978-1-60558-379-2},
	doi = {10.1145/1480881.1480904},
	abstract = {A bidirectional transformation consists of a function get that takes a source (document or value) to a view and a function put that takes an updated view and the original source back to an updated source, governed by certain consistency conditions relating the two functions. Both the database and programming language communities have studied techniques that essentially allow a user to specify only one of get and put and have the other inferred automatically. All approaches so far to this bidirectionalization task have been syntactic in nature, either proposing a domain-specific language with limited expressiveness but built-in (and composable) backward components, or restricting get to a simple syntactic form from which some algorithm can synthesize an appropriate definition for put. Here we present a semantic approach instead. The idea is to take a general-purpose language, Haskell, and write a higher-order function that takes (polymorphic) get-functions as arguments and returns appropriate put-functions. All this on the level of semantic values, without being willing, or even able, to inspect the definition of get, and thus liberated from syntactic restraints. Our solution is inspired by relational parametricity and uses free theorems for proving the consistency conditions. It works beautifully.},
	booktitle = {Proceedings of the 36th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	year = {2009},
	keywords = {bidirectionalization, free theorems, generic programming, program transformation, relational parametricity, view-update problem},
	pages = {165--176}
},

@inproceedings{wadler_well-typed_2009,
	author = {Philip Wadler and Robert Bruce Findler},
	address = {York, {UK}},
	title = {{Well-Typed} Programs Can't Be Blamed},
	isbn = {978-3-642-00589-3},
	url = {http://portal.acm.org/citation.cfm?id=1532976},
	abstract = {We introduce the blame calculus, which adds the notion of blame from Findler and Felleisen's contracts to a system similar to Siek and Taha's gradual types and Flanagan's hybrid types. We characterise where positive and negative blame can arise by decomposing the usual notion of subtype into positive and negative subtypes, and show that these recombine to yield naive subtypes. Naive subtypes previously appeared in type systems that are unsound, but we believe this is the first time naive subtypes play a role in establishing type soundness.},
	booktitle = {Proceedings of the 18th European Symposium on Programming Languages and Systems: Held as Part of the Joint European Conferences on Theory and Practice of Software, {ETAPS} 2009},
	publisher = {{Springer-Verlag}},
	year = {2009},
	pages = {1--16}
},

@article{malde_calculating_2006,
	author = {Ketil Malde and Robert Giegerich},
	title = {Calculating {PSSM} probabilities with lazy dynamic programming},
	volume = {16},
	url = {http://portal.acm.org/citation.cfm?id=1114011},
	abstract = {Position-specific scoring matrices are one way to represent approximate string patterns, which are commonly encountered in the field of bioinformatics. An important problem that arises with their application is calculating the statistical significance of matches. We review the currently most efficient algorithm for this task, and show how it can be implemented in Haskell, taking advantage of the built-in non-strictness of the language. The resulting program turns out to be an instance of dynamic programming, using lists rather the typical dynamic programming matrix.},
	number = {1},
	journal = {J. Funct. Program.},
	year = {2006},
	keywords = {dynamic programming},
	pages = {75--81}
},

@book{peyton_jones_haskell_2003,
	author = {Simon {Peyton Jones}},
	title = {Haskell 98 Language and Libraries: the Revised Report},
	publisher = {Cambridge University Press},
	year = {2003}
},

@incollection{sowrirajan_managing_2003,
	author = {Sundararajan Sowrirajan and Andre Hoek},
	title = {Managing the Evolution of Distributed and Interrelated Components},
	url = {http://www.springerlink.com/content/pkjprnpx6ffk30ud},
	abstract = {Software systems are increasingly being built by integrating pre-existing components developed by different, geographically distributed organizations. Each component typically evolves independently over time, not only in terms of its functionality, but also in terms of its exposed interfaces and dependencies on other components. Given that those other components may also evolve, creating an application by assembling sets of components typically involves managing a complex web of evolving dependencies. Traditional configuration management systems assume a form of centralized control that simply does not suffice in these situations. Needed are new configuration management systems that span multiple organizations, operate in a distributed and decentralized fashion, and help in managing the consistent evolution of independently developed, inter-related sets of components. A critical aspect of these new configuration management systems is that they must respect the different levels of autonomy, privacy, and trust that exist among different organizations. In this paper, we introduce {TWICS,} an early example of such a new configuration management system. Key aspects of {TWICS} are that it maintains traditional configuration management functionality to support the development of individual components, but integrates policy-driven deployment functionality to support different organizations in evolving their inter-related components.},
	booktitle = {Software Configuration Management},
	year = {2003},
	keywords = {evolution},
	pages = {217--230}
},

@inproceedings{mckinna_dependent_2006,
	author = {James {McKinna}},
	address = {Charleston, South Carolina, {USA}},
	title = {Why dependent types matter},
	isbn = {1-59593-027-2},
	doi = {10.1145/1111037.1111038},
	abstract = {Language designers have in recent years proposed a wealth of richer type systems for programming which seek to extend the range of statically enforced guarantees on data and code. Most such proposals have been evolutionary extensions of {ML} or Haskell, offering programmers a balanced compromise between expressive strength and existing well-understood technology. Typically they revolve around type- or kind-indexed types such as {GADTs,} supported by limited equality reasoning at the type-checking level, thus separating the dynamic behaviour of programs from the (simpler) static behaviour of indexing information occurring in their {types.I} want to argue in this talk for a more radical departure from such practice by examining full spectrum type dependency, lifting such restrictions on the data upon which types may depend. Conor {McBride} and I designed the language {EPIGRAM} for experiments in programming with inductive families of data (of which {GADTs} are a special case). Using it for illustration, I will explore some of the possibilities and challenges afforded by full spectrum type dependency at the static and dynamic level:},
	booktitle = {Conference record of the 33rd {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	year = {2006},
	pages = {1--1}
},

@inproceedings{plotkin_logic_1993,
	author = {Gordon Plotkin and Martín Abadi},
	file = {:/home/bernardy/Papers/A logic for parametric polymorphism-1993.pdf:pdf},
	title = {A logic for parametric polymorphism},
	volume = {664},
	booktitle = {Proceedings of the International Conference on Typed Lambda Calculi and Applications},
	series = {Lecture Notes in Computer Science},
	publisher = {Springer},
	year = {1993},
	pages = {361–375}
},

@misc{lh_principled_????,
	author = {Andres Löh and Wouter Swierstra and Daan Leijen},
	title = {A Principled Approach to Version Control},
	keywords = {vc, vc-project},
	howpublished = {\url{}}
},

@article{celentano_incremental_1978,
	author = {A. Celentano},
	title = {Incremental {LR} parsers},
	volume = {10},
	number = {4},
	journal = {Acta Informatica},
	year = {1978},
	pages = {307--321}
},

@article{bhm_automatic_1985,
	author = {Corrado Böhm and Alessandro Berarducci},
	title = {Automatic synthesis of typed Lambda-programs on term algebras},
	volume = {39},
	number = {2-3},
	journal = {Theoretical Computer Science},
	year = {1985},
	pages = {135--154}
},

@misc{schrijvers_open_2007,
	author = {Tom Schrijvers and Martin Sulzmann and Simon {Peyton Jones} and Manuel Chakravarty},
	title = {Towards open type functions for Haskell},
	abstract = {We report on an extension of Haskell with type(-level) functions and equality constraints. We illustrate their usefulness in the context of phantom types, {GADTs} and type classes. Problems in the context of type checking are identified and we sketch our solution: a decidable type checking algorithm for a restricted class of type functions. Moreover, functional dependencies are now obsolete: we show how they can be encoded as type functions.},
	journal = {Implementing Functional Languages},
	year = {2007},
	keywords = {open, typeclass},
	howpublished = {\url{}}
},

@inproceedings{lmmel_generic_2002,
	author = {Ralf Lämmel},
	address = {Pittsburgh, Pennsylvania},
	title = {Towards generic refactoring},
	isbn = {1-58113-606-4},
	url = {http://portal.acm.org/citation.cfm?doid=570186.570188},
	doi = {10.1145/570186.570188},
	abstract = {We define a challenging and meaningful benchmark for genericity in language processing, namely the notion of generic program refactoring. We provide the first implementation of the benchmark based on functional strategic programming in Haskell. We use the basic refactoring of abstraction extraction as the running example. Our implementation comes as a functional programming framework with hot spots for the language-specific ingredients for refactoring, e.g., means for abstraction construction and destruction, and recognisers for name analysis. The language-parametric framework can be instantiated for various, rather different languages, e.g., Java, Prolog, Haskell, or {XML} schema.},
	booktitle = {Proceedings of the 2002 {ACM} {SIGPLAN} workshop on Rule-based programming},
	publisher = {{ACM}},
	year = {2002},
	keywords = {frameworks, functional programming, generic programming, language, program transformation, refactoring, reuse, strafunski},
	pages = {15--28}
},

@article{wilcox_design_1976,
	author = {Thomas R. Wilcox and Alan M. Davis and Michael H. Tindall},
	title = {The design and implementation of a table driven, interactive diagnostic programming system},
	volume = {19},
	url = {http://portal.acm.org/citation.cfm?id=360363.360367},
	doi = {10.1145/360363.360367},
	abstract = {{CAPS} is a highly interactive diagnostic compiler/interpreter that allows beginning programmers to prepare, debug, and execute fairly simple programs at a graphics display terminal. Complete syntax checking and most semantic analysis is performed as the program is entered and as it is subsequently edited. Analysis is performed character by character. The most remarkable feature of {CAPS} is its ability to automatically diagnose errors both at compile time and at run time. Errors are not automatically corrected. Instead, {CAPS} interacts with the student to help him find the cause of his error. Most components of {CAPS} are table driven, both to reduce the space needed for implementation and to increase the flexibility of the multilingual system. Over 500 students have used {CAPS} to learn Fortran, {PL/I,} or Cobol in conjunction with a computer assisted course on introductory computer science.},
	number = {11},
	journal = {Commun. {ACM}},
	year = {1976},
	keywords = {computer assisted instruction, computer science education, debugging, error correction, interactive programming, interpreters, table driven compilers},
	pages = {609--616}
},

@article{bahlke_psg_1986,
	author = {Rolf Bahlke and Gregor Snelting},
	title = {The {PSG} system: from formal language definitions to interactive programming environments},
	volume = {8},
	shorttitle = {The {PSG} system},
	url = {http://portal.acm.org/citation.cfm?id=6465.20890},
	doi = {10.1145/6465.20890},
	abstract = {The {PSG} programming system generator developed at the Technical University of Darmstadt produces interactive, language-specific programming environments from formal language definitions. All language-dependent parts of the environment are generated from an entirely nonprocedural specification of the language's syntax, context conditions, and dynamic semantics. The generated environment consists of a language-based editor, supporting systematic program development by named program fragments, an interpreter, and a fragment library system. The major component of the environment is a full-screen editor, which allows both structure and text editing. In structure mode the editor guarantees prevention of both syntactic and semantic errors, whereas in textual mode it guarantees their immediate recognition. {PSG} editors employ a novel algorithm for incremental semantic analysis which is based on unification. The algorithm will immediately detect semantic errors even in incomplete program fragments. The dynamic semantics of the language are defined in denotational style using a functional language based on the lambda calculus. Program fragments are compiled to terms of the functional language which are executed by an interpreter. The {PSG} generator has been used to produce environments for Pascal, {ALGOL} 60, {MODULA-2,} and the formal language definition language itself.},
	number = {4},
	journal = {{ACM} Trans. Program. Lang. Syst.},
	year = {1986},
	pages = {547--576}
},

@inproceedings{greenwald_agreeing_2006,
	author = {Michael Greenwald and Sanjeev Khanna and Keshav Kunal and Benjamin Pierce and Alan Schmitt and Shlomi Dolev},
	title = {Agreeing to Agree: {{C}onflict} Resolution for Optimistically Replicated Data},
	booktitle = {International Symposium on Distributed Computing {(DISC)}},
	year = {2006},
	keywords = {bibtex-import, vc}
},

@article{rhiger_type-safe_????,
	author = {Morten Rhiger},
	file = {:/home/bernardy/Papers/Type-safe pattern combinators-????.pdf:pdf},
	title = {Type-safe pattern combinators},
	url = {http://www.itu.dk/people/mir/typesafepatterns.pdf},
	journal = {Journal of Functional Programming},
	keywords = {open}
},

@misc{hughes_restricted_1999,
	author = {J Hughes},
	title = {Restricted Datatypes in Haskell},
	url = {http://citeseer.ist.psu.edu/hughes99restricted.html},
	abstract = {The implementations of abstract type constructors must often restrict the type parameters: for example, one implementation of sets may require equality on the element type, while another implementation requires an ordering. Haskell has no mechanism to abstract over such restrictions, which can hinder us from replacing one implementation by another, or making several implementations instances of the same class. This paper proposes a language extension called restricted data types to...},
	year = {1999}
},

@incollection{mairson_outline_1991,
	author = {Harry Mairson},
	series = {Lecture Notes in Computer Science},
	title = {Outline of a proof theory of parametricity},
	volume = {523},
	doi = {10.1007/3540543961_15},
	abstract = {Reynolds' Parametricity Theorem (also known as the Abstraction Theorem), a result concerning the model theory of the second order polymorphic typed λ-calculus {(F2),} has recently been used by Wadler to prove some unusual and interesting properties of programs. We present a purely syntactic version of the Parametricity Theorem, showing that it is simply an example of formal theorem proving in second order minimal logic over a first order equivalence theory on λ-terms. We analyze the use of parametricity in proving program equivalences, and show that structural induction is still required: parametricity is not enough.},
	booktitle = {Proceedings of the 5th {ACM} conference on Functional programming languages and computer architecture},
	publisher = {{Springer-Verlag}},
	year = {1991},
	pages = {313--327}
},

@inproceedings{willcock_formalization_2004,
	author = {Jeremiah Willcock and Jaakko J{Ã¤}rvi and Andrew Lumsdaine and David Musser},
	title = {A Formalization of Concepts for Generic Programming},
	booktitle = {Concepts: a Linguistic Foundation of Generic Programming at Adobe Tech Summit},
	publisher = {{{Adobe} Systems}},
	year = {2004},
	keywords = {sibylle, wgp08}
},

@inproceedings{runciman_smallcheck_2008,
	author = {Colin Runciman and Matthew Naylor and Fredrik Lindblad},
	address = {Victoria, {BC,} Canada},
	title = {Smallcheck and lazy smallcheck: automatic exhaustive testing for small values},
	isbn = {978-1-60558-064-7},
	shorttitle = {Smallcheck and lazy smallcheck},
	url = {http://portal.acm.org/citation.cfm?id=1411292},
	doi = {10.1145/1411286.1411292},
	abstract = {This paper describes two Haskell libraries for property-based testing. Following the lead of {QuickCheck,} these testing libraries {SmallCheck} and Lazy {SmallCheck} also use type-based generators to obtain test-sets of finite values for which properties are checked, and report any counter-examples found. But instead of using a sample of randomly generated values they test properties for all values up to some limiting depth, progressively increasing this limit. The paper explains the design and implementation of both libraries and evaluates them in comparison with each other and with {QuickCheck.}},
	booktitle = {Proceedings of the first {ACM} {SIGPLAN} symposium on Haskell},
	publisher = {{ACM}},
	year = {2008},
	keywords = {embedded language, exhaustive search, lazy evaluation, property-based testing, type classes},
	pages = {37--48}
},

@misc{peyton_jones_bulk_1996,
	author = {Simon {Peyton Jones}},
	title = {Bulk types with class},
	url = {http://citeseer.ist.psu.edu/peytonjones97bulk.html},
	abstract = {Bulk types --- such as lists, bags, sets, finite maps, and priority queues --- are ubiquitous in programming. Yet many languages don't support them well, even though they have received a great deal of attention, especially from the database community. Haskell is currently among the culprits. This paper has two aims: to identify some of the technical difficulties, and to attempt to address them using Haskell's constructor classes. This paper appears in the proceedings of the 1997 Haskell...},
	year = {1996},
	keywords = {typeclass}
},

@inproceedings{bernardy_editor_2008,
	author = {Jean-Philippe Bernardy},
	address = {Victoria, {BC,} Canada},
	title = {Yi: an editor in {{Haskell}} for {{Haskell}}},
	isbn = {978-1-60558-064-7},
	shorttitle = {Yi},
	url = {http://portal.acm.org/citation.cfm?id=1411286.1411294},
	doi = {10.1145/1411286.1411294},
	abstract = {Yi is a text editor written in Haskell and extensible in Haskell. We take advantage of Haskell's expressive power to define embedded {DSLs} that form the foundation of the editor. In turn, these {DSLs} provide a flexible mechanism to create extended versions of the editor. Yi also provides some support for editing Haskell code.},
	booktitle = {Proceedings of the first {ACM} {SIGPLAN} symposium on Haskell},
	publisher = {{ACM}},
	year = {2008},
	keywords = {editor, functional programming},
	pages = {61--62}
},

@misc{glineau_samuels_2009,
	author = {Samuel Gélineau},
	title = {Samuel's Really Straightforward Proof of the Parametricity Result, extended (trivially) to dependent types.},
	url = {http://gelisam.blogspot.com/2009/09/samuels-really-straightforward-proof-of.html},
	year = {2009},
	howpublished = {\url{http://gelisam.blogspot.com/2009/09/samuels-really-straightforward-proof-of.html}}
},

@inproceedings{gibbons_parametric_2009,
	author = {Jeremy Gibbons and Ross Paterson},
	address = {Edinburgh, Scotland},
	title = {Parametric datatype-genericity},
	isbn = {978-1-60558-510-9},
	url = {http://portal.acm.org/citation.cfm?id=1596626},
	doi = {10.1145/1596614.1596626},
	abstract = {Datatype-generic programs are programs that are parametrized by a datatype or type functor: whereas polymorphic programs abstract from the "integers" in "lists of integers",datatype-generic programs abstract from the "lists of". There are two main styles of datatype-generic programming: the Algebra of Programming approach, characterized by structured recursion operators arising from initial algebras and final coalgebras, and the Generic Haskell approach, characterized by case analysis over the structure of a datatype. We show that the former enjoys a kind of higher-order naturality, relating the behaviours of generic functions at different types; in contrast, the latter is ad{\textasciitilde}hoc, with no coherence required or provided between the various clauses of a definition. Moreover, the naturality properties arise "for free", simply from the parametrized types of the generic functions: we present a higher-order parametricity theorem for datatype-generic operators.},
	booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN} workshop on Generic programming},
	publisher = {{ACM}},
	year = {2009},
	keywords = {folds, free theorems, functional programming, generic programming, higher-order functions, higher-order natural transformations, parametricity, unfolds},
	pages = {85--93}
},

@misc{bernardy_proof_2010,
	author = {Jean-Philippe Bernardy},
	title = {A proof of the Abstraction theorem for pure type systems (unary case)},
	url = {http://www.cse.chalmers.se/~bernardy/ParDep/html/Theorem.html},
	year = {2010},
	howpublished = {\url{http://www.cse.chalmers.se/~bernardy/ParDep/html/Theorem.html}}
},

@misc{bernardy_lightweight_2010,
	author = {Jean-Philippe Bernardy},
	title = {Lightweight Free Theorems: Agda Library},
	url = {http://wiki.portal.chalmers.se/agda/agda.php?n=Libraries.LightweightFreeTheorems},
	year = {2010},
	howpublished = {\url{http://wiki.portal.chalmers.se/agda/agda.php?n=Libraries.LightweightFreeTheorems}}
},

@article{xi_guarded_2003,
	author = {Hongwei Xi and Chiyan Chen and Gang Chen},
	title = {Guarded recursive datatype constructors},
	volume = {38},
	url = {http://portal.acm.org/citation.cfm?id=604150&dl=GUIDE&coll=GUIDE&CFID=38830212&CFTOKEN=12075942},
	doi = {10.1145/640128.604150},
	abstract = {We introduce a notion of guarded recursive (g.r.) datatype constructors, generalizing the notion of recursive datatypes in functional programming languages such as {ML} and Haskell. We address both theoretical and practical issues resulted from this generalization. On one hand, we design a type system to formalize the notion of g.r. datatype constructors and then prove the soundness of the type system. On the other hand, we present some significant applications (e.g., implementing objects, implementing staged computation, etc.) of g.r. datatype constructors, arguing that g.r. datatype constructors can have far-reaching consequences in programming. The main contribution of the paper lies in the recognition and then the formalization of a programming notion that is of both theoretical interest and practical use.},
	number = {1},
	journal = {{SIGPLAN} Not.},
	year = {2003},
	keywords = {{GADT,} guarded recursive datatype constructors},
	pages = {224--235},
	annote = {{{\textless}p{\textgreater}The} {GADT} paper{\textless}/p{\textgreater}}
},

@article{hinze_generic_2009,
	author = {Ralf Hinze and Andres Löh},
	title = {Generic programming in {3D}},
	volume = {74},
	url = {http://portal.acm.org/citation.cfm?id=1537539},
	abstract = {Support for generic programming consists of three essential ingredients: support for overloaded functions, a run-time type representation, and a generic view on data. Different approaches to datatype-generic programming occupy different points in this design space. In this article, we revisit the {''Scrap} your boilerplate'' approach and identify its location within the three-dimensional design space. The characteristic features of {''Scrap} your boilerplate'' are its two generic views, the 'spine' view for consuming and transforming data, and the 'type-spine' view for producing data. We show how to combine these views with different overloading mechanisms and type representations.},
	number = {8},
	journal = {Sci. Comput. Program.},
	year = {2009},
	keywords = {generic programming, haskell 98, language design, type classes},
	pages = {590--628}
},

@unpublished{conor_lets_????,
	author = {{McBride} Conor},
	file = {:/home/bernardy/Papers/Let's see how things unfold-????.pdf:pdf},
	title = {Let's see how things unfold},
	url = {http://strictlypositive.org/ObsCoin.pdf}
},

@article{backhouse_generic_1999,
	author = {R. Backhouse and P. Jansson and J. Jeuring and L. Meertens},
	title = {Generic programming -- An introduction},
	journal = {Lecture notes in Computer Science},
	year = {1999},
	pages = {28–115}
},

@article{ghezzi_augmenting_1980,
	author = {C. Ghezzi and D. Mandrioli},
	title = {Augmenting Parsers to Support Incrementality},
	volume = {27},
	number = {3},
	journal = {Journal of the {ACM} {(JACM)}},
	year = {1980},
	pages = {564--579}
},

@inproceedings{johann_free_2004,
	author = {Patricia Johann and Janis Voigtländer},
	address = {Venice, Italy},
	title = {Free theorems in the presence of seq},
	isbn = {{1-58113-729-X}},
	booktitle = {Proceedings of the 31st {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	year = {2004},
	pages = {99--110}
},

@incollection{christiansen_easycheck_2008,
	author = {Jan Christiansen and Sebastian Fischer},
	series = {Lecture Notes in Computer Science},
	title = {{EasyCheck} — Test Data for Free},
	volume = {4989},
	url = {http://dx.doi.org/10.1007/978-3-540-78969-7_23},
	abstract = {We present a lightweight, automated tool for specification-based testing of declarative programs written in the functional
logic programming language Curry and emphasize the usefulness of logic features in its implementation and use. Free variables,
nondeterminism and encapsulated search turn out to be elegant and powerful means to express test-data generation.},
	booktitle = {Functional and Logic Programming},
	publisher = {Springer},
	year = {2008},
	pages = {322--336}
},

@inproceedings{bernardy_lazy_2009,
	author = {Jean-Philippe Bernardy},
	address = {Edinburgh, Scotland},
	title = {Lazy functional incremental parsing},
	isbn = {978-1-60558-508-6},
	url = {http://portal.acm.org/citation.cfm?id=1596638.1596645},
	doi = {10.1145/1596638.1596645},
	abstract = {Structured documents are commonly edited using a free-form editor. Even though every string is an acceptable input, it makes sense to maintain a structured representation of the edited document. The structured representation has a number of uses: structural navigation (and optional structural editing), structure highlighting, etc. The construction of the structure must be done incrementally to be efficient: the time to process an edit operation should be proportional to the size of the change, and (ideally) independent of the total size of the document. We show that combining lazy evaluation and caching of intermediate (partial) results enables incremental parsing. We build a complete incremental parsing library for interactive systems with support for error-correction.},
	booktitle = {Proceedings of the 2nd {ACM} {SIGPLAN} symposium on Haskell},
	publisher = {{ACM}},
	year = {2009},
	keywords = {dynamic programming, editor, haskell, incremental computing, lazy evaluation, parsing, polish representation},
	pages = {49--60},
	see = {cites:wagner_efficient_1998;cites:ghezzi_incremental_1979}
},

@book{knuth_art_1997,
	author = {Donald E. Knuth},
	title = {The Art of Computer Programming, Volume 1: Fundamental Algorithms},
	isbn = {0201896834},
	shorttitle = {Art of Computer Programming, Volume 1},
	publisher = {{Addison-Wesley} Professional},
	year = {1997}
},

@book{knuth_art_1998,
	author = {Donald E. Knuth},
	edition = {2},
	title = {The Art of Computer Programming, Volume 3: Sorting and Searching (2nd Edition)},
	isbn = {0201896850},
	shorttitle = {Art of Computer Programming, Volume 3},
	publisher = {{Addison-Wesley} Professional},
	month = {5},
	year = {1998}
},

@article{conradi_version_1998,
	author = {Reidar Conradi and Bernhard Westfechtel},
	title = {Version models for software configuration management},
	volume = {30},
	issn = {0360-0300},
	url = {http://dx.doi.org/10.1145/280277.280280},
	number = {2},
	journal = {{ACM} Comput. Surv.},
	month = {jun},
	year = {1998},
	keywords = {vc},
	pages = {232--282}
},

@book{luo_computation_1994,
	author = {Zhaohui Luo},
	title = {Computation and reasoning: a type theory for computer science},
	isbn = {0-19-853835-9},
	shorttitle = {Computation and reasoning},
	url = {http://portal.acm.org/citation.cfm?id=184757},
	publisher = {Oxford University Press, Inc.},
	year = {1994}
},

@article{chakravarty_associated_2005,
	author = {Manuel Chakravarty and Gabriele Keller and Simon {Peyton Jones}},
	title = {Associated type synonyms},
	volume = {40},
	issn = {0362-1340},
	url = {http://dx.doi.org/10.1145/1090189.1086397},
	number = {9},
	journal = {{SIGPLAN} Not.},
	year = {2005},
	keywords = {typeclass},
	pages = {241--253}
},

@misc{miquel_theorie_????,
	author = {Alexandre Miquel},
	title = {Theorie de la demonstration},
	url = {http://perso.ens-lyon.fr/alexandre.miquel/enseignement/index.html},
	howpublished = {\url{http://perso.ens-lyon.fr/alexandre.miquel/enseignement/index.html}}
},

@inproceedings{danvy_defunctionalization_2001,
	author = {Olivier Danvy and Lasse R. Nielsen},
	address = {Florence, Italy},
	title = {Defunctionalization at work},
	isbn = {{1-58113-388-X}},
	url = {http://portal.acm.org/citation.cfm?id=773184.773202},
	doi = {10.1145/773184.773202},
	abstract = {Reynolds's defunctionalization technique is a whole-program transformation from higher-order to first-order functional programs. We study practical applications of this transformation and uncover new connections between seemingly unrelated higher-order and first-order specifications and between their correctness proofs. Defunctionalization therefore appearsboth as a springboard for rev ealing new connections and as a bridge for transferring existing results between the first-order world and the higher-order world.},
	booktitle = {Proceedings of the 3rd {ACM} {SIGPLAN} international conference on Principles and practice of declarative programming},
	publisher = {{ACM}},
	year = {2001},
	keywords = {church encoding, closure conversion, continuation-passing style (cps), continuations, cps transformation, defunctionalization, direct-style transformation, first-order programs, higher-order programs, lambda-lifting, ml, regular expressions, scheme, supercombinator conversion, syntactic theories},
	pages = {162--174}
},

@inproceedings{hughes_design_1995,
	author = {John Hughes},
	title = {The Design of a Pretty-printing Library},
	isbn = {3-540-59451-5},
	url = {http://portal.acm.org/citation.cfm?id=734154},
	booktitle = {Advanced Functional Programming, First International Spring School on Advanced Functional Programming {Techniques-Tutorial} Text},
	publisher = {{Springer-Verlag}},
	year = {1995},
	pages = {53--96}
},

@inproceedings{sheard_template_2002,
	author = {Tim Sheard and Simon {Peyton Jones}},
	title = {Template meta-programming for Haskell},
	booktitle = {Proceedings of the 2002 ACM SIGPLAN workshop on Haskell},
	series = {Haskell '02},
	year = {2002},
	isbn = {1-58113-605-6},
	location = {Pittsburgh, Pennsylvania},
	pages = {1--16},
	numpages = {16},
	url = {http://doi.acm.org/10.1145/581690.581691},
	doi = {http://doi.acm.org/10.1145/581690.581691},
	acmid = {581691},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {meta programming, templates}
},

@article{birkedal_categorical_2005,
	author = {Lars Birkedal and Rasmus E. Møgelberg},
	file = {:/home/bernardy/Papers/Categorical models for Abadi and Plotkin's logic for parametricity-2005.pdf:pdf},
	title = {Categorical models for Abadi and Plotkin's logic for parametricity},
	volume = {15},
	url = {http://portal.acm.org/citation.cfm?id=1089909},
	abstract = {We propose a new category-theoretic formulation of relational parametricity based on a logic for reasoning about parametricity given by Abadi and Plotkin {(Plotkin} \& Abadi 1993). The logic can be used to reason about parametric models, such that we may prove consequences of parametricity that to our knowledge have not been proved before for existing category-theoretic notions of relational parametricity. We provide examples of parametric models and describe a way of constructing parametric models from given models of the second-order lambda calculus.},
	number = {4},
	journal = {Mathematical. Structures in Comp. Sci.},
	year = {2005},
	pages = {709--772}
},

@article{voigtlnder_much_2008,
	author = {Janis Voigtländer},
	file = {:/home/bernardy/Papers/Much ado about two (pearl) a pearl on parallel prefix computation-2008.pdf:pdf},
	title = {Much ado about two (pearl): a pearl on parallel prefix computation},
	volume = {43},
	shorttitle = {Much ado about two (pearl)},
	url = {http://portal.acm.org/citation.cfm?id=1328445},
	doi = {10.1145/1328897.1328445},
	abstract = {This pearl develops a statement about parallel prefix computation in the spirit of Knuth's {0-1-Principle} for oblivious sorting algorithms. It turns out that 0-1 is not quite enough here. The perfect hammer for the nails we are going to drive in is relational parametricity.},
	number = {1},
	journal = {{SIGPLAN} Not.},
	year = {2008},
	keywords = {0-1-principle, free theorems, parallel prefix computation, relational parametricity},
	pages = {29--35}
},

@inproceedings{swierstra_fast_1999,
	author = {S. Doaitse Swierstra and Pablo R. Azero Alcocer},
	file = {:/home/bernardy/Papers/Fast, Error Correcting Parser Combinators A Short Tutorial-1999.pdf:pdf},
	title = {Fast, Error Correcting Parser Combinators: A Short Tutorial},
	isbn = {{3-540-66694-X}},
	shorttitle = {Fast, Error Correcting Parser Combinatiors},
	url = {http://portal.acm.org/citation.cfm?id=647009.712536&coll=ACM&dl=ACM&CFID=13026192&CFTOKEN=34892732},
	booktitle = {Proceedings of the 26th Conference on Current Trends in Theory and Practice of Informatics},
	publisher = {{Springer-Verlag}},
	year = {1999},
	pages = {112--131}
},

@inproceedings{kim_program_2006,
	author = {Miryung Kim and David Notkin},
	title = {Program element matching for multi-version program analyses},
	isbn = {1595933972},
	url = {http://dx.doi.org/10.1145/1137983.1137999},
	booktitle = {{MSR} '06: Proceedings of the 2006 international workshop on Mining software repositories},
	publisher = {{ACM} Press},
	year = {2006},
	keywords = {evolution, vc},
	pages = {58--64}
},

@inproceedings{zeller_yesterday_1999,
	author = {Andreas Zeller},
	title = {Yesterday, my program worked. Today, it does not. Why?},
	isbn = {0163-5948},
	url = {http://dx.doi.org/10.1145/318773.318946},
	booktitle = {{ESEC/FSE-7:} Proceedings of the 7th European software engineering conference held jointly with the 7th {ACM} {SIGSOFT} international symposium on Foundations of software engineering},
	publisher = {{Springer-Verlag}},
	year = {1999},
	keywords = {dd},
	pages = {253--267},
	annote = {How to find a minimal set of changes that introduced a bug. Various heuristics to avoid testing inconsistent subsets of changes.}
},

@phdthesis{carlsson_fudgets_1998,
	author = {M. Carlsson and T. Hallgren},
	file = {:/home/bernardy/Papers/Fudgets Purely Functional Processes with Applications to Graphical User Interfaces-1998.ps:ps},
	type = {{PhD} Thesis},
	title = {Fudgets: Purely Functional Processes with Applications to Graphical User Interfaces},
	school = {Chalmers Tekniska Högskola},
	year = {1998}
},

@inproceedings{washburn_boxes_2003,
	author = {Geoffrey Washburn and Stephanie Weirich},
	file = {:/home/bernardy/Papers/Boxes go bananas encoding higher-order abstract syntax with parametric polymorphism-2003.pdf:pdf},
	address = {Uppsala, Sweden},
	title = {Boxes go bananas: encoding higher-order abstract syntax with parametric polymorphism},
	isbn = {1-58113-756-7},
	shorttitle = {Boxes go bananas},
	url = {http://portal.acm.org/citation.cfm?id=944728},
	doi = {10.1145/944705.944728},
	abstract = {Higher-order abstract syntax is a simple technique for implementing languages with functional programming. Object variables and binders are implemented by variables and binders in the host language. By using this technique, one can avoid implementing common and tricky routines dealing with variables, such as capture-avoiding substitution. However, despite the advantages this technique provides, it is not commonly used because it is difficult to write sound elimination forms (such as folds or catamorphisms) for higher-order abstract syntax. To fold over such a datatype, one must either simultaneously define an inverse operation (which may not exist) or show that all functions embedded in the datatype are {parametri.In} this paper, we show how first-class polymorphism can be used to guarantee the parametricity of functions embedded in higher-order abstract syntax. With this restriction, we implement a library of iteration operators over data-structures containing functionals. From this implementation, we derive "fusion laws" that functional programmers may use to reason about the iteration operator. Finally, we show how this use of parametric polymorphism corresponds to the Schürmann, Despeyroux and Pfenning method of enforcing parametricity through modal types. We do so by using this library to give a sound and complete encoding of their calculus into System F?. This encoding can serve as a starting point for reasoning about higher-order structures in polymorphic languages.},
	booktitle = {Proceedings of the eighth {ACM} {SIGPLAN} international conference on Functional Programming},
	publisher = {{ACM}},
	year = {2003},
	keywords = {catamorphism, higher-order abstract syntax, modal type system, parametricity, parametric polymorphism},
	pages = {249--262}
},

@inproceedings{danielsson_fast_2006,
	author = {Nils Anders Danielsson and John Hughes and Patrik Jansson and Jeremy Gibbons},
	title = {Fast and loose reasoning is morally correct},
	booktitle = {Conference record of the 33rd {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	url = {http://portal.acm.org/citation.cfm?id=1111320.1111056},
	doi = {10.1145/1111320.1111056},
	abstract = {Functional programmers often reason about programs as if they were written in a total language, expecting the results to carry over to non-total (partial) languages. We justify such {reasoning.Two} languages are defined, one total and one partial, with identical syntax. The semantics of the partial language includes partial and infinite values, and all types are lifted, including the function spaces. A partial equivalence relation {(PER)} is then defined, the domain of which is the total subset of the partial language. For types not containing function spaces the {PER} relates equal values, and functions are related if they map related values to related {values.It} is proved that if two closed terms have the same semantics in the total language, then they have related semantics in the partial language. It is also shown that the {PER} gives rise to a bicartesian closed category which can be used to reason about values in the domain of the relation.},
	year = {2006},
	keywords = {equational reasoning, inductive and coinductive types, lifted types, non-strict and strict languages, partial and infinite values, partial and total languages},
	acmid = {1111056},
	pages = {206--217}
},

@inproceedings{bernardy_reviving_2002,
	author = {Jean-Philippe Bernardy},
	address = {Oxford, {UK}},
	title = {Reviving Pacbase {COBOL-Generated} Code},
	doi = {http://doi.ieeecomputersociety.org/10.1109/CMPSAC.2002.1045091},
	abstract = {We have migrated a large scale application from Pacbase to {COBOL.} The technique is to apply, in an iterative fashion, a set of small transformation patterns on Pacbase {COBOL-output.} Thus, equivalence with the Pacbase code is easily verified.},
	booktitle = {{COMPSAC} 2002 Proceedings},
	publisher = {IEEE Computer Society},
	year = {2002},
	pages = {741--743}
},

@article{longo_genericity_1993,
	author = {Giuseppe Longo and Kathleen Milsted and Sergei Soloviev and Kathleen Milsted},
	title = {The Genericity Theorem and the Notion of Parametricity in the Polymorphic {lambda-Calculus}},
	volume = {121},
	url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.4136},
	journal = {{THEORETICAL} {COMPUTER} {SCIENCE}},
	year = {1993},
	pages = {323---349}
},

@book{bird_algebra_1997,
	author = {Richard Bird and Oege {de Moor}},
	title = {Algebra of programming},
	isbn = {{013507245X}},
	url = {http://portal.acm.org/citation.cfm?id=248932},
	publisher = {{Prentice-Hall,} Inc.},
	year = {1997},
	keywords = {aop}
},

@incollection{sozeau_first-class_2008,
	author = {Matthieu Sozeau and Nicolas Oury},
	title = {{First-Class} Type Classes},
	url = {http://dx.doi.org/10.1007/978-3-540-71067-7_23},
	abstract = {Type Classes have met a large success in Haskell and Isabelle, as a solution for sharing notations by overloading and for specifying with abstract structures by quantification on contexts.
However, both systems are limited by second-class implementations of these constructs, and these limitations are only overcomed
by ad-hoc extensions to the respective systems. We propose an embedding of type classes into a dependent type theory that
is first-class and supports some of the most popular extensions right away. The implementation is correspondingly cheap, general
and integrates well inside the system, as we have experimented in Coq. We show how it can be used to help structured programming
and proving by way of examples.},
	booktitle = {Theorem Proving in Higher Order Logics},
	year = {2008},
	pages = {278--293}
},

@article{johann_impact_2006,
	author = {Patricia Johann and Janis Voigtländer},
	title = {The Impact of seq on Free Theorems-based Program Transformations},
	volume = {69},
	url = {http://portal.acm.org/citation.cfm?id=1227251},
	abstract = {Parametric polymorphism constrains the behavior of pure functional programs in a way that allows the derivation of interesting theorems about them solely from their types, i.e., virtually for free. Unfortunately, standard parametricity results - including so-called free theorems - fail for nonstrict languages supporting a polymorphic strict evaluation primitive such as Haskell's seq. A folk theorem maintains that such results hold for a subset of Haskell corresponding to a {Girard-Reynolds} calculus with fixpoints and algebraic datatypes even when seq is present provided the relations which appear in their derivations are required to be bottom-reflecting and admissible. In this paper we show that this folklore is incorrect, but that parametricity results can be recovered in the presence of seq by restricting attention to left-closed, total, and admissible relations instead. The key novelty of our approach is the asymmetry introduced by left-closedness, which leads to "inequational" versions of standard parametricity results together with preconditions guaranteeing their validity even when seq is present. We use these results to derive criteria ensuring that both equational and inequational versions of short cut fusion and related program transformations based on free theorems hold in the presence of seq},
	number = {1-2},
	journal = {Fundamenta Informaticae},
	year = {2006},
	keywords = {control primitives, correctness proofs, denotational semantics, functional programming languages, haskell, logical relations, mixing strict and nonstrict evaluation, parametricity, polymorphism, program transformations, rank-2 types, short cut fusion, theorems for free},
	pages = {63--102}
},

@inproceedings{wadler_theorems_1989,
	author = {Philip Wadler},
	address = {Imperial College, London, United Kingdom},
	title = {Theorems for free!},
	isbn = {0-89791-328-0},
	url = {http://portal.acm.org/citation.cfm?id=99404},
	doi = {10.1145/99370.99404},
	abstract = {Note: {OCR} errors may be found in this Reference List extracted from the full text article. {ACM} has opted to expose the complete List rather than only correct and linked references.},
	booktitle = {Proceedings of the fourth international conference on Functional programming languages and computer architecture},
	publisher = {{ACM}},
	year = {1989},
	keywords = {parametricity},
	pages = {347--359}
},

@inproceedings{johann_foundations_2008,
	author = {Patricia Johann and Neil Ghani},
	title = {Foundations for structured programming with {GADTs}},
	isbn = {9781595936899},
	url = {http://dx.doi.org/10.1145/1328438.1328475},
	booktitle = {{POPL} '08: Proceedings of the 35th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	year = {2008},
	keywords = {aop},
	pages = {297--308}
},

@article{buckley_taxonomy_2005,
	author = {Jim Buckley and Tom Mens and Matthias Zenger and Awais Rashid and GÃ¼nter Kniesel},
	title = {Towards a taxonomy of software change},
	volume = {17},
	url = {http://dx.doi.org/10.1002/smr.319},
	abstract = {Previous taxonomies of software change have focused on the purpose of the change (i.e., the why) rather than the underlying mechanisms. This paper proposes a taxonomy of software change based on characterizing the mechanisms of change and the factors that influence these mechanisms. The ultimate goal of this taxonomy is to provide a framework that positions concrete tools, formalisms and methods within the domain of software evolution. Such a framework would considerably ease comparison between the various mechanisms of change. It would also allow practitioners to identify and evaluate the relevant tools, methods and formalisms for a particular change scenario. As an initial step towards this taxonomy, the paper presents a framework that can be used to characterize software change support tools and to identify the factors that impact on the use of these tools. The framework is evaluated by applying it to three different change support tools and by comparing these tools based on this analysis. Copyright Â© 2005 John Wiley \& Sons, Ltd.},
	number = {5},
	journal = {Journal of Software Maintenance and Evolution: Research and Practice},
	year = {2005},
	keywords = {evolution},
	pages = {309--332}
},

@article{allison_lazy_1992,
	author = {L. Allison},
	file = {:/home/bernardy/Papers/Lazy Dynamic-Programming Can Be Eager-1992.ps:ps},
	title = {Lazy {Dynamic-Programming} Can Be Eager},
	volume = {43},
	number = {4},
	journal = {Information Processing Letters},
	year = {1992},
	pages = {207--212}
},

@book{hinze_typed_2006,
	author = {Ralf Hinze and Johan Jeuring and Andres Löh},
	title = {Typed Contracts for Functional Programming},
	volume = {3945},
	url = {http://dx.doi.org/10.1007/11737414_15},
	abstract = {A robust software component fulfills a contract: it expects data satisfying a certain property and promises to return data satisfying another property. The object-oriented community uses the design-by-contract approach extensively. Proposals for language extensions that add contracts to higher-order functional programming have appeared recently. In this paper we propose an embedded domain-specific language for typed, higher-order and first-class contracts, which is both more expressive than previous proposals, and allows for a more informative blame assignment. We take some first steps towards an algebra of contracts, and we show how to define a generic contract combinator for arbitrary algebraic data types. The contract language is implemented as a library in Haskell using the concept of generalised algebraic data types.},
	month = {jan},
	year = {2006},
	keywords = {blame, contract, invariant},
	pages = {208--225}
},

@article{boudol_semantics_2000,
	author = {Gérard Boudol},
	file = {:/home/bernardy/Papers/On the semantics of the call-by-name CPS transform-2000.pdf:pdf},
	title = {On the semantics of the call-by-name {CPS} transform},
	volume = {234},
	url = {http://portal.acm.org/citation.cfm?id=331681},
	number = {1-2},
	journal = {Theor. Comput. Sci.},
	year = {2000},
	keywords = {böhm-out technique, continuation-passing-style transforms, lévy-longo trees, \&lgr;-calculus},
	pages = {309--321}
},

@misc{mens_uniform_????,
	author = {Tom Mens and Kim Mens},
	title = {A Uniform Declarative Framework for Automated Software Merging},
	url = {http://citeseer.ist.psu.edu/mens00uniform.html},
	abstract = {We report on a prototype tool that automates the time-consuming and error-prone process of software merging. Our tool is significantly more flexible than existing merge techniques, as it can detect syntactic, structural as well as semantic conflicts. It is implemented as a general framework for software evolution that can be customised to many different domains. Because of this, it can be used to support evolution of any kind of software artifact, independent of the target language or the...},
	keywords = {evolution, vc}
},

@inproceedings{xu_static_2009,
	author = {Dana N. Xu and Simon {Peyton Jones} and Koen Claessen},
	file = {:/home/bernardy/Papers/Static contract checking for Haskell-2009.pdf:pdf},
	address = {Savannah, {GA,} {USA}},
	title = {Static contract checking for {H}askell},
	isbn = {978-1-60558-379-2},
	url = {http://portal.acm.org/citation.cfm?id=1480881.1480889},
	doi = {10.1145/1480881.1480889},
	abstract = {Program errors are hard to detect and are costly both to programmers who spend significant efforts in debugging, and for systems that are guarded by runtime checks. Static verification techniques have been applied to imperative and object-oriented languages, like Java and C\#, but few have been applied to a higher-order lazy functional language, like Haskell. In this paper, we describe a sound and automatic static verification framework for Haskell, that is based on contracts and symbolic execution. Our approach is modular and gives precise blame assignments at compile-time in the presence of higher-order functions and laziness.},
	booktitle = {Proceedings of the 36th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	year = {2009},
	keywords = {contract satisfaction, static contract checking},
	pages = {41--52}
},

@incollection{frandsen_dynamic_1995,
	author = {Gudmund Frandsen and Thore Husfeldt and Peter Miltersen and Theis Rauhe and Søren Skyum},
	title = {Dynamic algorithms for the Dyck languages},
	url = {http://dx.doi.org/10.1007/3-540-60220-8_54},
	abstract = {We study Dynamic Membership problems for the Dyck languages, the class of strings of properly balanced parentheses. We also study the Dynamic Word problem for the free group. We present deterministic algorithms and data structures which maintain a string under replacements of symbols, insertions, and deletions of symbols, and language membership queries. Updates and queries are handled in polylogarithmic time. We also give both Las Vegas- and Monte Carlo-type randomised algorithms to achieve better running times, and present lower bounds on the complexity for variants of the problems.},
	booktitle = {Algorithms and Data Structures},
	year = {1995},
	pages = {98--108}
},

@inproceedings{pennings_using_1992,
	author = {Maarten Pennings and S. Doaitse Swierstra and Harald Vogt},
	title = {Using Cached Functions and Constructors for Incremental Attribute Evaluation},
	isbn = {3-540-55844-6},
	url = {http://portal.acm.org/citation.cfm?id=646448.756843&coll=ACM&dl=ACM&CFID=13026192&CFTOKEN=34892732},
	booktitle = {Proceedings of the 4th International Symposium on Programming Language Implementation and Logic Programming},
	publisher = {{Springer-Verlag}},
	year = {1992},
	pages = {130--144}
},

@incollection{sheard_generic_2007,
	author = {Tim Sheard},
	title = {Generic Programming in Ωmega},
	volume = {Volume 4719/2007},
	url = {http://dx.doi.org/10.1007/978-3-540-76786-2_5},
	abstract = {Generic programming is about making programs more adaptable by making them more general. Generic programs often embody non-traditional kinds of abstraction; ordinary programs are obtained from them by suitably instantiating their parameters. In contrast with normal programs, the parameters of a generic program are often quite rich in structure; for example they may be other programs, types or type constructors, class hierarchies, or even programming paradigms.},
	booktitle = {{Datatype-Generic} Programming},
	year = {2007},
	keywords = {wgp08},
	pages = {258--284},
	see = {:hinze_generic_2009}
},

@book{krivine_lambda-calcul_1997,
	author = {Jean-Louis Krivine},
	file = {:/home/bernardy/Papers/Lambda-calcul types et modèles-1990.pdf:pdf},
	title = {Lambda-calcul -- types et modèles},
	isbn = {2225820910},
	publisher = {Dunod},
	year = {1997}
},

@inproceedings{meijer_functional_1991,
	author = {Erik Meijer and Maarten Fokkinga and Ross Paterson},
	file = {:/home/bernardy/Papers/Functional programming with bananas, lenses, envelopes and barbed wire-1991.pdf:pdf},
	address = {Cambridge, Massachusetts, United States},
	title = {Functional programming with bananas, lenses, envelopes and barbed wire},
	isbn = {0-387-54396-1},
	url = {http://portal.acm.org/citation.cfm?id=128035},
	booktitle = {Proceedings of the 5th {ACM} conference on Functional programming languages and computer architecture},
	publisher = {{Springer-Verlag}},
	year = {1991},
	pages = {124--144}
},

@inproceedings{atkey_syntax_????,
	author = {Robert Atkey},
	title = {Syntax For Free: Representing Syntax with Binding using Parametricity}
},

@techreport{gregor_proposed_2007,
	author = {D Gregor and B Stroustrup and J Siek and James Widman},
	title = {Proposed {{W}ording} for {{C}oncepts} {({R}evision} 4)},
	year = {2007},
	keywords = {sibylle, wgp08},
	annote = {{{\textless}p{\textgreater}Draft,} will be published as a revision to {{\textbackslash}cite{Gregor:2007:PWC}{\textless}/p{\textgreater}}}
},

@phdthesis{peng_programmable_????,
	author = {Li Peng},
	type = {{PhD} Thesis},
	title = {{PROGRAMMABLE} {CONCURRENCY} {IN} A {PURE} {AND} {LAZY}
{LANGUAGE}},
	url = {http://www.cis.upenn.edu/~lipeng/homepage/papers/dissertation.pdf},
	school = {University of Pennsylvania}
},

@article{tichy_rcs_1985,
	author = {Walter Tichy},
	title = {{RCS} --- A System for Version Control},
	volume = {15},
	url = {http://citeseer.ist.psu.edu/tichy85rcs.html},
	abstract = {An important problem in program development and maintenance is version control, i.e., the task of keeping a software system consisting of many versions and configurations well organized. The Revision Control System {(RCS)} is a software tool that assists with that task. {RCS} manages revisions of text documents, in particular source programs, documentation, and test data. It automates the storing, retrieval, logging and identification of revisions, and it provides selection mechanisms for composing ...},
	number = {7},
	journal = {Software --- Practice and Experience},
	year = {1985},
	keywords = {vc},
	pages = {637--654}
},

@inproceedings{lerner_composing_2002,
	author = {Sorin Lerner and David Grove and Craig Chambers},
	title = {Composing dataflow analyses and transformations},
	volume = {37},
	isbn = {1581134509},
	url = {http://dx.doi.org/10.1145/503272.503298},
	booktitle = {{POPL} '02: Proceedings of the 29th {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM} Press},
	month = {jan},
	year = {2002},
	keywords = {cool},
	pages = {270--282}
},

@incollection{ma_types_1992,
	author = {{QingMing} Ma and John C. Reynolds},
	title = {Types, abstraction, and parametric polymorphism, part 2},
	url = {http://dx.doi.org/10.1007/3-540-55511-0_1},
	abstract = {The concept of relations over sets is generalized to relations over an arbitrary category, and used to investigate the abstraction (or logical-relations) theorem, the identity extension lemma, and parametric polymorphism, for Cartesian-closed-category models of the simply typed lambda calculus and {PL-category} models of the polymorphic typed lambda calculus. Treatments of Kripke relations and of complete relations on domains are included.},
	booktitle = {Mathematical Foundations of Programming Semantics},
	year = {1992},
	keywords = {parametricity},
	pages = {1--40}
},

@inproceedings{angelov_visual_2005,
	author = {Krasimir Angelov and Simon Marlow},
	address = {Tallinn, Estonia},
	title = {Visual haskell: a full-featured haskell development environment},
	isbn = {{159593071X}},
	url = {http://dx.doi.org/10.1145/1088348.1088350},
	booktitle = {Haskell '05: Proceedings of the 2005 {ACM} {SIGPLAN} workshop on Haskell},
	publisher = {{ACM}},
	year = {2005},
	keywords = {haskell},
	pages = {5--16}
},

@article{mens_state-of-the-art_2002,
	author = {T Mens},
	title = {A state-of-the-art survey on software merging},
	volume = {28},
	url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1000449},
	abstract = {Software merging is an essential aspect of the maintenance and evolution of large-scale software systems. This paper provides a comprehensive survey and analysis of available merge approaches. Over the years, a wide variety of different merge techniques has been proposed. While initial techniques were purely based on textual merging, more powerful approaches also take the syntax and semantics of the software into account. There is a tendency towards operation-based merging because of its increased expressiveness. Another tendency is to try to define merge techniques that are as general, accurate, scalable, and customizable as possible, so that they can be used in any phase in the software life-cycle and detect as many conflicts as possible. After comparing the possible merge techniques, we suggest a number of important open problems and future research directions},
	number = {5},
	journal = {Software Engineering, {IEEE} Transactions on},
	year = {2002},
	keywords = {survey, vc, vc-project},
	pages = {449--462}
},

@inproceedings{morris_indexed_2009,
	author = {Peter Morris and Thorsten Altenkirch},
	title = {Indexed Containers},
	booktitle = {{Twenty-Fourth} {IEEE} Symposium on Logic in Computer Science},
	year = {2009},
	issn = {1043-6871},
	pages = {277-285},
	doi = {http://doi.ieeecomputersociety.org/10.1109/LICS.2009.33},
	publisher = {IEEE Computer Society},
	address = {Los Alamitos, CA, USA}
},

@inproceedings{baars_typed_2009,
	author = {Arthur Baars and Doaitse Swierstra and Marcos Viera},
	address = {New York, {NY,} {USA}},
	title = {Typed Transformations of Typed Abstract Syntax},
	booktitle = {{TLDI} '09: fourth {ACM} {SIGPLAN} Workshop on Types in Language Design and Implementation},
	year = {2009}
},

@article{church_set_1933,
	author = {Alonzo Church},
	series = {Second Series},
	title = {A Set of Postulates For the Foundation of Logic},
	volume = {34},
	issn = {{0003486X}},
	url = {http://www.jstor.org/stable/1968702},
	number = {4},
	journal = {The Annals of Mathematics},
	month = {oct},
	year = {1933},
	note = {{ArticleType:} primary\_article / Full publication date: Oct., 1933 / Copyright © 1933 Annals of Mathematics},
	pages = {839--864}
},

@inproceedings{chakravarty_associated_2005-1,
	author = {Manuel Chakravarty and Gabriele Keller and Simon {Peyton Jones} and Simon Marlow},
	forcedkey = {chakravarty_associated_2005-1},
	title = {Associated types with class},
	isbn = {{158113830X}},
	url = {http://dx.doi.org/10.1145/1040305.1040306},
	booktitle = {{POPL} '05: Proceedings of the 32nd {ACM} {SIGPLAN-SIGACT} sysposium on Principles of programming languages},
	publisher = {{ACM} Press},
	year = {2005},
	keywords = {typeclass},
	pages = {1--13}
},

@article{ghezzi_incremental_1979,
	author = {Carlo Ghezzi and Dino Mandrioli},
	title = {Incremental Parsing},
	volume = {1},
	url = {http://portal.acm.org/citation.cfm?id=357062.357066},
	doi = {10.1145/357062.357066},
	abstract = {An incremental parser is a device which is able to perform syntax analysis in an incremental way, avoiding complete reparsing of a program after each modification. The incremental parser presented extends the conventional {LR} parsing algorithm and its performance is compared with that of a conventional parser. Suggestions for an implementation and possible extensions to other parsing methods are also discussed.},
	number = {1},
	journal = {{ACM} Trans. Program. Lang. Syst.},
	year = {1979},
	pages = {58--70}
},

@inproceedings{elliott_functional_1997,
	author = {Conal Elliott and Paul Hudak},
	file = {:/home/bernardy/Papers/Functional reactive animation-1997.pdf:pdf},
	address = {Amsterdam, The Netherlands},
	title = {Functional reactive animation},
	isbn = {0-89791-918-1},
	url = {http://portal.acm.org/citation.cfm?id=258948.258973&type=series},
	doi = {10.1145/258948.258973},
	abstract = {Fran {(Functional} Reactive Animation) is a collection of data types and functions for composing richly interactive, multimedia animations. The key ideas in Fran are its notions of behaviors and events. Behaviors are time-varying, reactive values, while events are sets of arbitrarily complex conditions, carrying possibly rich information. Most traditional values can be treated as behaviors, and when images are thus treated, they become animations. Although these notions are captured as data types rather than a programming language, we provide them with a denotational semantics, including a proper treatment of real time, to guide reasoning and implementation. A method to effectively and efficiently perform event detection using interval analysis is also described, which relies on the partial information structure on the domain of event times. Fran has been implemented in Hugs, yielding surprisingly good performance for an interpreter-based system. Several examples are given, including the ability to describe physical phenomena involving gravity, springs, velocity, acceleration, etc. using ordinary differential equations.},
	booktitle = {Proceedings of the second {ACM} {SIGPLAN} international conference on Functional Programming},
	publisher = {{ACM}},
	year = {1997},
	pages = {263--273}
},

@misc{foster_harmony_2005,
	author = {Nathan Foster},
	title = {Harmony: A Generic Synchronization Framework for Heterogeneous, Replicated Data},
	year = {2005},
	keywords = {bibtex-import, vc},
	annote = {{{\textless}p{\textgreater}(private-note)Poster} at {DB-IR} Day.{\textless}/p{\textgreater}}
},

@incollection{frank_one_1999,
	author = {Andrew Frank},
	title = {One Step up the Abstraction Ladder: Combining Algebras - From Functional Pieces to a Whole},
	url = {http://dx.doi.org/10.1007/3-540-48384-5_7},
	abstract = {A fundamental scientific question today is how to construct complex systems from simple parts. Science today seems mostly to analyze limited pieces of the puzzle; the combination of these pieces to form a whole is left for later or others. The lack of efficient methods to deal with the combination problem is likely the main reason. How to combine individual results is a dominant question in cognitive science or geography, where phenomena are studied from individuals and at different scales, but the results cannot be brought together. This paper proposes to use parameterized algebras much the same way that we use functional abstraction (procedures in programming languages) to create abstract building blocks which can be combined later. Algebras group operations (which are functional abstractions) and can be combined to construct more complex algebras. Algebras operate therefore at a higher level of abstraction. A table shows the parallels between procedural abstraction and the abstraction by parameterized algebras. This paper shows how algebras can be combined to form more complex pieces and compares the steps to the combination of procedures in programming. The novel contribution is to parameterize algebras and make them thus ready for reuse. The method is first explained with the familiar construction of vector space and then applied to a larger example, namely the description of geometric operations for {GIS,} as proposed in the current draft standard document {ISO} 15046 Part 7: Spatial Schema. It is shown how operations can be grouped, reused, and combined, and useful larger systems built from the pieces. The paper compares the method to combine algebras â which are independent of an implementation â with the current use of object-orientation in programming languages (and in the {UML} notation often used for specification). The widely usedâ structuralâ (or subset) polymorphism is justified by implementation considerations, but not appropriate for theory development and abstract specifications for standardization. Parametric polymorphism used for algebras avoids the contravariance of function types (which its semantically confusing consequences). Algebraic methods relate cleanly to the mathematical category theory and the method translates directly to modern functional programming or Java.},
	booktitle = {Spatial Information Theory. Cognitive and Computational Foundations of Geographic Information Science},
	year = {1999},
	keywords = {aop},
	pages = {751}
},

@article{benke_universes_2003,
	author = {Marcin Benke and Peter Dybjer and Patrik Jansson},
	title = {Universes for generic programs and proofs in dependent type theory},
	volume = {10},
	url = {http://portal.acm.org/citation.cfm?id=985801},
	abstract = {We show how to write generic programs and proofs in {Martin-Löf} type theory. To this end we consider several extensions of {Martin-Löf's} logical framework for dependent types. Each extension has a universe of codes (signatures) for inductively defined sets with generic formation, introduction, elimination, and equality rules. These extensions are modeled on Dybjer and Setzer's finitely axiomatized theories of inductive-recursive definitions, which also have universes of codes for sets, and generic formation, introduction, elimination, and equality rules. Here we consider several smaller universes of interest for generic programming and universal algebra. We formalize one-sorted and many-sorted term algebras, as well as iterated, generalized, parameterized, and indexed inductive definitions. We also show how to extend the techniques of generic programming to these universes. Furthermore, we give generic proofs of reflexivity and substitutivity of a generic equality test: Most of the definitions in the paper have been implemented using the proof assistant Alfa for dependent type theory.},
	number = {4},
	journal = {Nordic Journal of Computing},
	year = {2003},
	keywords = {algebraic specifications, dependent types, generic programming, inductive definitions, martin-löf type theory, polytypic programming},
	pages = {265--289}
},

@book{vandevoorde_c++_2002,
	author = {David Vandevoorde and Nicolai Josuttis},
	title = {C++ Templates: The Complete Guide},
	isbn = {0201734842},
	url = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20&path=ASIN/0201734842},
	publisher = {{{Addison-Wesley} Professional}},
	month = {nov},
	year = {2002},
	keywords = {cpp, templates, wgp08}
},

@inproceedings{bernardy_comparison_2008,
	author = {Jean-Philippe Bernardy and Patrik Jansson and Marcin Zalewski and Sibylle Schupp and Andreas Priesnitz},
	address = {Victoria, {BC,} Canada},
	title = {A comparison of {C++} concepts and {Haskell} type classes},
	isbn = {978-1-60558-060-9},
	url = {http://dx.doi.org/10.1145/1411318.1411324},
	abstract = {Earlier studies have introduced a list of high-level evaluation criteria to assess how well a language supports generic programming. Since each language that meets all criteria is considered generic, those criteria are not fine-grained enough to differentiate between languages for generic programming. We refine these criteria into a taxonomy that captures differences between type classes in Haskell and concepts in C++, and discuss which differences are incidental and which ones are due to other language features. The taxonomy allows for an improved understanding of language support for generic programming, and the comparison is useful for the ongoing discussions among language designers and users of both languages.},
	booktitle = {{WGP} '08: Proceedings of the {ACM} {SIGPLAN} workshop on Generic programming},
	publisher = {{ACM}},
	year = {2008},
	keywords = {self},
	pages = {37--48}
},

@inproceedings{saraiva_functional_2000,
	author = {João Saraiva and S. Doaitse Swierstra and Matthijs F. Kuiper},
	title = {Functional Incremental Attribute Evaluation},
	isbn = {{3-540-67263-X}},
	url = {http://portal.acm.org/citation.cfm?id=647476.727632&coll=ACM&dl=ACM&CFID=13026192&CFTOKEN=34892732},
	booktitle = {Proceedings of the 9th International Conference on Compiler Construction},
	publisher = {{Springer-Verlag}},
	year = {2000},
	pages = {279--294}
},

@misc{kiselyov_polymorphic_2006,
	author = {Oleg Kiselyov},
	title = {Polymorphic variants: solving the expression problem},
	url = {http://okmij.org/ftp/Haskell/generics.html#PolyVariant},
	month = {jul},
	year = {2006},
	keywords = {open},
	howpublished = {\url{http://okmij.org/ftp/Haskell/generics.html#PolyVariant}}
},

@article{reynolds_types_1983,
	author = {John C. Reynolds},
	file = {:/home/bernardy/Papers/Types, abstraction and parametric polymorphism-1983.pdf:pdf},
	title = {Types, abstraction and parametric polymorphism},
	volume = {83},
	number = {1},
	journal = {Information processing},
	year = {1983},
	pages = {513--523},
	see = {part2:ma_types_1992}
},

@article{johann_generalization_2002,
	author = {Patricia Johann},
	title = {A Generalization of Short-cut Fusion and its Correctness Proof},
	volume = {15},
	url = {http://dx.doi.org/10.1023/A:1022982420888},
	doi = {10.1023/A:1022982420888},
	abstract = {Short-cut fusion is a program transformation technique that uses a single, local transformation—called the foldr-build rule—to remove certain intermediate lists from modularly constructed functional programs. Arguments that short-cut fusion is correct typically appeal either to intuition or to “free theorems”—even though the latter have not been known to hold for the languages supporting higher-order polymorphic functions and fixed point recursion in which short-cut fusion is usually applied. In this paper we use Pitts' recent demonstration that contextual equivalence in such languages is relationally parametric to prove that programs in them which have undergone short-cut fusion are contextually equivalent to their unfused counterparts. For each algebraic data type we then define a generalization of build which constructs substitution instances of its associated data structures, and use Pitts' techniques to prove the correctness of a contextual equivalence-preserving fusion rule which generalizes short-cut fusion. These rules optimize compositions of functions that uniformly consume algebraic data structures with functions that uniformly produce substitution instances of those data sructures.},
	number = {4},
	journal = {{Higher-Order} and Symbolic Computation},
	month = {dec},
	year = {2002},
	pages = {273--300}
},

@misc{kiselyov_httpokmij.orgftphaskelltypes.htmlclass-based-dispatch_????,
	author = {Oleg Kiselyov},
	title = {{http://okmij.org/ftp/Haskell/types.html\#class-based-dispatch}},
	url = {http://okmij.org/ftp/Haskell/types.html#class-based-dispatch},
	abstract = {This message gives an example of a dynamic type class cast in Haskell. We want to dispatch on a class of a type rather on a type itself. In other words, we would like to simulate {IsInstanceOf.}},
	keywords = {typeclass},
	howpublished = {\url{http://okmij.org/ftp/Haskell/types.html#class-based-dispatch}}
},

@inproceedings{jrvi_algorithm_2006,
	author = {Jaakko Järvi and Douglas Gregor and Jeremiah Willcock and Andrew Lumsdaine and Jeremy Siek},
	title = {Algorithm specialization in generic programming: challenges of constrained generics in C++},
	isbn = {1595933204},
	url = {http://dx.doi.org/10.1145/1133981.1134014},
	booktitle = {{PLDI} '06: Proceedings of the 2006 {ACM} {SIGPLAN} conference on Programming language design and implementation},
	publisher = {{ACM}},
	year = {2006},
	keywords = {c, concept, typeclass},
	pages = {272--282}
},

@inproceedings{voigtlnder_free_2009,
	author = {Janis Voigtländer},
	title = {Free theorems involving type constructor classes: {Functional pearl}},
	shorttitle = {Free theorems involving type constructor classes},
	url = {http://portal.acm.org/citation.cfm?id=1631687.1596577},
	doi = {10.1145/1631687.1596577},
	abstract = {Free theorems are a charm, allowing the derivation of useful statements about programs from their (polymorphic) types alone. We show how to reap such theorems not only from polymorphism over ordinary types, but also from polymorphism over type constructors restricted by class constraints. Our prime application area is that of monads, which form the probably most popular type constructor class of Haskell. To demonstrate the broader scope, we also deal with a transparent way of introducing difference lists into a program, endowed with a neat and general correctness proof.},
	booktitle = {Proceedings of the 14th ACM SIGPLAN international conference on Functional Programming},
	isbn = {978-1-60558-332-7},
	location = {Edinburgh, Scotland},
	pages = {173--184},
	numpages = {12},
	acmid = {1596577},
	publisher = {ACM},
	address = {New York, NY, USA},
	year = {2009},
	keywords = {relational parametricity}
},

@incollection{wallace_partial_2008,
	author = {Malcolm Wallace},
	file = {:/home/bernardy/Papers/Partial Parsing Combining Choice with Commitment-2008.pdf:pdf},
	series = {Lecture Notes in Computer Science},
	title = {Partial Parsing: Combining Choice with Commitment},
	volume = {5083/2008},
	shorttitle = {Partial Parsing},
	url = {http://dx.doi.org/10.1007/978-3-540-85373-2_6},
	abstract = {Parser combinators, often monadic, are a venerable and widely-used solution to read data from some external format. However,
the capability to return a partial parse has, until now, been largely missing. When only a small portion of the entire data
is desired, it has been necessary either to parse the entire input in any case, or to break up the grammar into smaller pieces
and move some work outside the world of combinators.

This paper presents a technique for mixing lazy, demand-driven, parsing with strict parsing, all within the same set of combinators.
The grammar specification remains complete and unbroken, yet only sufficient input is consumed to satisfy the result demanded.
It is built on a combination of applicative and monadic parsers. Monadic parsing alone is insufficient to allow a choice operator to coexist with the early commitment needed for
lazy results. Applicative parsing alone can give partial results, but does not permit context-sensitive grammars. But used
together, we gain both partiality and a flexible ease of use.



Performance results demonstrate that partial parsing is often faster and more space-efficient than strict parsing, but never
worse. The trade-off is that partiality has consequences when dealing with ill-formed input.},
	booktitle = {Implementation and Application of Functional Languages},
	publisher = {Springer},
	year = {2008},
	pages = {93--110}
},

@misc{the_coq_development_team_coq_2010,
	author = { {{The} Coq development team}},
	title = {The {{Coq}} proof assistant},
	url = {http://coq.inria.fr},
	year = {2010}
},

@misc{the_coq_development_team_coq_2011,
	author = { {{The} Coq development team}},
	title = {The {{Coq}} proof assistant},
	url = {http://coq.inria.fr},
	year = {2011}
},

@misc{the_coq_development_team_coq_2012,
	author = { {{The} Coq development team}},
	title = {The {{Coq}} proof assistant},
	url = {http://coq.inria.fr},
	year = {2012}
},

@misc{danielsson_agda_2010,
	author = {Nils Anders Danielsson},
	title = {The {Agda} standard library},
	url = {http://www.cs.nott.ac.uk/~nad/repos/lib/},
	year = {2010}
},

@misc{danielsson_agda_2011,
	author = {Nils Anders Danielsson and  {The Agda Team}},
	title = {The {Agda} standard library},
	url = {http://www.cs.nott.ac.uk/~nad/repos/lib/},
	year = {2011}
},

@misc{danielsson_agda_2013,
	author = {Nils Anders Danielsson and  {The Agda Team}},
	title = {The {Agda} standard library, version 0.7},
	url = {http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Libraries.StandardLibrary},
	year = {2013}
},

@phdthesis{karlsson_robust_2009,
	author = {Anders Karlsson},
	type = {{MSc} Thesis},
	title = {Robust and Precise Incremental Parsing of Haskell},
	school = {Chalmers University of Technology},
	year = {2009},
	see = {cites:bernardy_lazy_2009;:wagner_efficient_1998;:ghezzi_incremental_1979}
},

@phdthesis{eliasson_precision-preserving_2011,
	author = {Andreas Eliasson},
	type = {{MSc} Thesis},
	title = {A precision-preserving summary-based points-to
                  analysis in LLVM},
	school = {Chalmers University of Technology},
	year = {2011}
},

@phdthesis{bth_sjblom_agda_2013,
	author = {Thomas {Bååth Sjöblom}},
	type = {{MSc} Thesis},
	title = {An {Agda} proof of the correctness of {Valiant}'s algorithm for context free parsing},
	school = {Chalmers University of Technology},
	year = {2013}
},

@phdthesis{hansson_tool_2014,
	author = {Kristoffer Hansson and Jonas Hugo},
	type = {{MSc} Thesis},
	title = {A tool to generate an incremental lexer from a lexical specification},
	school = {Chalmers University of Technology},
	year = {2014}
},

@phdthesis{olausson_implementing_2014,
	author = {Tobias Olausson},
	type = {{MSc} Thesis},
	title = {Implementing incremental and parallel parsing},
	school = {Chalmers University of Technology},
	year = {2014}
},

@inproceedings{da_silva_lighthouse_2006,
	author = {Isabella {da Silva} and Ping Chen and Christopher Van der Westhuizen and Roger Ripley and Andr{\textbackslash}'e van der Hoek},
	title = {Lighthouse: coordination through emerging design},
	isbn = {1595936211},
	url = {http://dx.doi.org/10.1145/1188835.1188838},
	booktitle = {eclipse '06: Proceedings of the 2006 {OOPSLA} workshop on eclipse technology {eXchange}},
	publisher = {{ACM} Press},
	year = {2006},
	keywords = {conflict-avoidance},
	pages = {11--15}
},

@book{bertot_interactive_2004,
	author = {Y. Bertot and P. Castéran and G. Huet and Christine {Paulin-Mohring}},
	file = {:/home/bernardy/Papers/Interactive theorem proving and program development Coq'Art the calculus of inductive constructions-2004.pdf:pdf},
	title = {Interactive theorem proving and program development: {Coq'Art:} the calculus of inductive constructions},
	shorttitle = {Interactive theorem proving and program development},
	publisher = {{Springer-Verlag} New York Inc},
	year = {2004}
},

@article{degano_efficient_1988,
	author = {Pierpaolo Degano and Stefano Mannucci and Bruno Mojana},
	title = {Efficient incremental {LR} parsing for syntax-directed editors},
	volume = {10},
	url = {http://portal.acm.org/citation.cfm?doid=44501.214503},
	doi = {10.1145/44501.214503},
	abstract = {A technique for generating parsers which is an extension to {LR} techniques and is based on parsing table splitting, is presented. Then this technique is slightly extended to support incremental syntax analysis. Given a context-free grammar and a set {“IC”} of nonterminals devised to be incremental, a set of subtables is generated to drive the analysis of program fragments derivable from nonterminals in {IC.} The proposed technique generates parsing tables which are considerably smaller than the standard ones, even when incrementality is not exploited. Thus, these tables may be stored as arrays permitting faster access and accurate error handling. Furthermore, our tables are suitable for generating syntax-directed editors which provide a full analytic mode. The efficiency of the analytic component of a syntax-directed editor obtained in this way and its easy integration with the generative component stress the advantages of incremental program writing.},
	number = {3},
	journal = {{ACM} Trans. Program. Lang. Syst.},
	year = {1988},
	pages = {345--373}
},

@inproceedings{mcbride_clowns_2008,
	author = {Conor {McBride}},
	file = {:/home/bernardy/Papers/Clowns to the left of me, jokers to the right (pearl) dissecting data structures-2008.pdf:pdf},
	address = {San Francisco, California, {USA}},
	title = {Clowns to the left of me, jokers to the right (pearl): dissecting data structures},
	isbn = {978-1-59593-689-9},
	shorttitle = {Clowns to the left of me, jokers to the right (pearl)},
	url = {http://portal.acm.org/citation.cfm?id=1328474&dl=GUIDE&coll=GUIDE&CFID=17840475&CFTOKEN=88160233},
	doi = {10.1145/1328438.1328474},
	abstract = {This paper introduces a small but useful generalisation to the 'derivative' operation on datatypes underlying Huet's notion of 'zipper', giving a concrete representation to one-hole contexts in data which is undergoing transformation. This operator, 'dissection', turns a container-like functor into a bifunctor representing a one-hole context in which elements to the left of the hole are distinguished in type from elements to its right.},
	booktitle = {Proceedings of the 35th annual {ACM} {SIGPLAN-SIGACT} symposium on Principles of programming languages},
	publisher = {{ACM}},
	year = {2008},
	keywords = {datatype, differentiation, dissection, division, generic programming, iteration, stack, tail recursion, traversal, zipper},
	pages = {287--295}
},

@article{schrijvers_monadic_2009,
	author = {Tom Schrijvers and Peter Stuckey and Philip Wadler},
	title = {Monadic constraint programming},
	journal = {Journal of Functional Programming},
	pages = {1--35},
	year = {2009},
	publisher = {Cambridge Univ Press},
	volume = {19},
	issue = {06}
},

@techreport{gonthier_ssreflect_tutorial_2009,
	author = {G. Gonthier and S. Le and  others},
	forcedkey = {gonthier_ssreflect_tutorial_2009},
	title = {An {Ssreflect} Tutorial},
	year = {2009},
	institution = {{INRIA}}
},

@inproceedings{gonthier_ssreflect_2009,
	author = {G. Gonthier},
	title = {Ssreflect: Structured Scripting for Higher-Order
                  Theorem Proving},
	booktitle = {PLMMS’09},
	pages = {1},
	year = {2009},
	publisher = {ACM}
},

@misc{sheeran_hardware_2007,
	author = {Mary Sheeran},
	title = {Hardware Design and Functional Programming: a Perfect Match},
	howpublished = {Talk at Hardware Design and Functional Languages},
	year = {2007}
},

@InProceedings{jansson_testing_2007,
	author = {Patrik Jansson and Johan Jeuring and  {students of the
                  Utrecht University Generic Programming class}},
	title = {Testing properties of generic functions},
	booktitle = {Proceedings of IFL 2006},
	pages = {217--234},
	year = {2007},
	editor = {Zoltan Horvath},
	volume = {4449},
	series = {Lecture Notes in Computer Science},
	publisher = {Springer},
	citations = {1 (2009-03-23)}
},

@book{appel_compiling_1992,
	author = {Andrew W Appel},
	title = {Compiling with continuations},
	year = {1992},
	publisher = {Cambridge University Press}
},

@Article{bellin_-calculus_1994,
	author = {Gianluigi Bellin and Philip J. Scott},
	title = {On the π-calculus and Linear Logic},
	journal = {Theoretical Computer Science},
	year = {1994},
	volume = {135},
	number = {1},
	pages = {11--65}
},

@inproceedings{thielecke_control_2003,
	author = {Hayo Thielecke},
	title = {From control effects to typed continuation passing},
	booktitle = {ACM SIGPLAN Notices},
	volume = {38},
	number = {1},
	pages = {139--149},
	year = {2003},
	organization = {ACM}
},

@inproceedings{dolan_fun_2013,
	author = {Stephen Dolan},
	title = {Fun with Semirings: A Functional Pearl on the Abuse
                  of Linear Algebra},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} International
                  Conference on Functional Programming},
	series = {ICFP '13},
	year = {2013},
	isbn = {978-1-4503-2326-0},
	location = {Boston, Massachusetts, USA},
	pages = {101--110},
	numpages = {10},
	doi = {10.1145/2500365.2500613},
	acmid = {2500613},
	publisher = {ACM},
	address = {New York, NY, USA},
	keywords = {closed semirings, linear systems, shortest paths,
                  transitive closure}
},

@inproceedings{oury_pisigma_2010,
	author = {Thorsten Altenkirch and
 Nils Anders Danielsson and
 Andres L{\"o}h and
 Nicolas Oury},
	title = {PiSigma: Dependent Types without the Sugar},
	booktitle = {FLOPS},
	year = {2010},
	pages = {40-55},
	ee = {http://dx.doi.org/10.1007/978-3-642-12251-4_5},
	crossref = {DBLP:conf/flops/2010},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@article{brady_idris_2013,
	author = {Edwin Brady},
	title = {Idris, a general-purpose dependently typed programming language:
               Design and implementation},
	journal = {J. Funct. Program.},
	volume = {23},
	number = {5},
	year = {2013},
	pages = {552-593},
	ee = {http://dx.doi.org/10.1017/S095679681300018X},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@inproceedings{xi_combining_2005,
	author = {Chiyan Chen and
 Hongwei Xi},
	title = {Combining programming with theorem proving},
	booktitle = {ICFP},
	year = {2005},
	pages = {66-77},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@inproceedings{hammond_lightweight_2008,
	author = {Edwin Brady and
 Christoph A. Herrmann and
 Kevin Hammond},
	title = {Lightweight Invariants with Full Dependent Types},
	booktitle = {Trends in Functional Programming},
	year = {2008},
	pages = {161-177},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@article{coquand_simple_2009,
	author = {Thierry Coquand and Yoshiki Kinoshita and Bengt Nordström and Makoto Takeyama},
	title = {A simple type-theoretic language: Mini-TT},
	year = {2009}
},

@inproceedings{uustalu_normalization_2004,
	author = {Thorsten Altenkirch and
 Tarmo Uustalu},
	title = {Normalization by Evaluation for lambda$^{\mbox{-2}}$},
	booktitle = {FLOPS},
	year = {2004},
	pages = {260-275},
	ee = {http://dx.doi.org/10.1007/978-3-540-24754-8_19},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@inproceedings{abel_semi-continuous_2006,
	author = {Andreas Abel},
	title = {Semi-continuous Sized Types and Termination},
	booktitle = {CSL},
	year = {2006},
	pages = {72-88},
	ee = {http://dx.doi.org/10.1007/11874683_5},
	bibsource = {DBLP, http://dblp.uni-trier.de}
},

@InProceedings{TFPIE15_DSLsofMath_IonescuJansson,
  author =       {Cezar Ionescu and Patrik Jansson},
  title =        {Domain-Specific Languages of Mathematics: Presenting
                  Mathematical Analysis using Functional Programming},
  booktitle =    {Proceedings 4th International Workshop on Trends in
                  Functional Programming in Education},
  year =         2015,
  series =       "Electronic Proceedings in Theoretical Computer
                  Science",
  publisher =    "Open Publishing Association",
  TODOpages = {},
  TODOdoi   = {},
  TODOISSN  = {}
},
